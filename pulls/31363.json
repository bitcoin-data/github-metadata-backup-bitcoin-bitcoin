{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363",
    "id": 2196846832,
    "node_id": "PR_kwDOABII586C8Tjw",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/31363",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/31363.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/31363.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/41b4434fed169570ce0976c6e58db0d4a9614aaa",
    "number": 31363,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "cluster mempool: introduce TxGraph",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "Part of cluster mempool: #30289.\r\n\r\n### 1. Overview\r\n\r\nThis introduces the `TxGraph` class, which encapsulates knowledge about the (effective) fees, sizes, and dependencies between all mempool transactions, but nothing else. In particular, it lacks knowledge about `CTransaction`, inputs, outputs, txids, wtxids, prioritization, validatity, policy rules, and a lot more. Being restricted to just those aspects of the mempool makes the behavior very easy to fully specify (ignoring the actual linearizations produced), and write simulation-based tests for (which are included in this PR).\r\n\r\n### 2. Interface\r\n\r\nThe interface can be largely categorized into:\r\n* Mutation functions:\r\n  * `AddTransaction` (add a new transaction with specified feerate, and get a `Ref` object back to identify it).\r\n  * `RemoveTransaction` (given a `Ref` object, remove the transaction).\r\n  * `AddDependency` (given two `Ref` objects, add a dependency between them).\r\n  * `SetTransactionFee` (modify the fee associated with a Ref object).\r\n* Inspector functions:\r\n  * `GetAncestors` (get the ancestor set in the form of `Ref*` pointers)\r\n  * `GetAncestorsUnion` (like above, but for the union of ancestors of multiple `Ref*` pointers)\r\n  * `GetDescendants` (get the descendant set in the form of `Ref*` pointers)\r\n  * `GetDescendantsUnion` (like above, but for the union of ancestors of multiple `Ref*` pointers)\r\n  * `GetCluster` (get the connected component set in the form of `Ref*` pointers, in the order they would be mined).\r\n  * `GetIndividualFeerate` (get the feerate of a transaction)\r\n  * `GetChunkFeerate` (get the mining score of a transaction)\r\n  * `CountDistinctClusters` (count the number of distinct clusters a list of `Ref`s belong to)\r\n* Staging functions:\r\n  * `StartStaging` (make all future mutations operate on a proposed transaction graph)\r\n  * `CommitStaging` (apply all the changes that are staged)\r\n  * `AbortStaging` (discard all the changes that are staged)\r\n* Miscellaneous functions:\r\n  * `DoWork` (do queued-up computations now, so that future operations are fast)\r\n\r\nThis `TxGraph::Ref` type used as a \"handle\" on transactions in the graph can be inherited from, and the idea is that in the full cluster mempool implementation (#28676, after it is rebased on this), `CTxMempoolEntry` will inherit from it, and all actually used Ref objects will be `CTxMempoolEntry`s. With that, the mempool code can just cast any `Ref*` returned by txgraph to `CTxMempoolEntry*`.\r\n\r\n### 3. Implementation\r\n\r\nInternally the graph data is kept in clustered form (partitioned into connected components), for which linearizations are maintained and updated as needed using the `cluster_linearize.h` algorithms under the hood, but this is hidden from the users of this class. Implementation-wise, mutations are generally applied lazily, appending to queues of to-be-removed transactions and to-be-added dependencies, so they can be batched for higher performance. Inspectors will generally only evaluate as much as is needed to answer queries, with roughly 5 levels of processing to go to fully instantiated and acceptable cluster linearizations, in order:\r\n1. `ApplyRemovals` (take batches of to-be-removed transactions and translate them to \"holes\" in the corresponding Clusters/DepGraphs).\r\n2. `SplitAll` (creating holes in Clusters may cause them to break apart into smaller connected components, so make turn them into separate Clusters/linearizations).\r\n3. `GroupClusters` (figure out which Clusters will need to be combined in order to add requested to-be-added dependencies, as these may span clusters).\r\n4. `ApplyDependencies` (actually merge Clusters as precomputed by `GroupClusters`, and add the dependencies between them).\r\n5. `MakeAcceptable` (perform the LIMO linearization algorithm on Clusters to make sure their linearizations are acceptable).\r\n\r\n### 4. Future work\r\n\r\nThis is only an initial version of TxGraph, and some functionality is missing before #28676 can be rebased on top of it:\r\n* The ability to get comparative feerate diagrams before/after for the set of staged changes (to evaluate RBF incentive-compatibility).\r\n* Mining interface (ability to iterate transactions quickly in mining score order) (see #31444).\r\n* Eviction interface (reverse of mining order, plus memory usage accounting) (see #31444).\r\n* Ability to fix oversizedness of clusters (before or after committing) - this is needed for reorgs where aborting/rejecting the change just is not an option (see #31553).\r\n* Interface for controlling how much effort is spent on LIMO. In this PR it is hardcoded.\r\n\r\nThen there are further improvements possible which would not block other work:\r\n* Making Cluster a virtual class with different implementations based on transaction count (which could dramatically reduce memory usage, as most Clusters are just a single transaction, for which the current implementation is overkill).\r\n* The ability to have background thread(s) for improving cluster linearizations.",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "created_at": "2024-11-24T15:59:18Z",
    "updated_at": "2025-03-23T18:16:02Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "c6f4782ce7edcbcecabd8a23ee49a5c381252e2f",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202411_txgraph",
      "ref": "202411_txgraph",
      "sha": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 20,
        "stargazers_count": 90,
        "watchers_count": 90,
        "size": 258254,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-23T17:54:10Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2025-02-27T11:11:39Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "770d39a37652d40885533fecce37e9f71cc0d051",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 36949,
        "stargazers_count": 82597,
        "watchers_count": 82597,
        "size": 278753,
        "default_branch": "master",
        "open_issues_count": 691,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-03-23T16:41:16Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-03-23T17:47:25Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 3360,
    "deletions": 150,
    "changed_files": 11,
    "commits": 25,
    "review_comments": 255,
    "comments": 39
  },
  "events": [
    {
      "event": "commented",
      "id": 2496083772,
      "node_id": "IC_kwDOABII586Uxzc8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2496083772",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-24T15:59:21Z",
      "updated_at": "2025-03-22T00:06:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31363.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [jonatack](https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2520463595) |\n| Stale ACK | [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2665558763), [ajtowns](https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2743809558), [instagibbs](https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2743883179) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#30605](https://github.com/bitcoin/bitcoin/pull/30605) (Cluster linearization: separate tests from tests-of-tests by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2496083772",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15410951192,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOWkHQY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15410951192",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "eff65737e508a6b6a1254858bbbe1792f3c36da6",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/eff65737e508a6b6a1254858bbbe1792f3c36da6",
      "created_at": "2024-11-24T16:20:24Z"
    },
    {
      "event": "commented",
      "id": 2496093320,
      "node_id": "IC_kwDOABII586Ux1yI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2496093320",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-24T16:20:29Z",
      "updated_at": "2024-11-24T16:20:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/33443336095</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2496093320",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "labeled",
      "id": 15410951366,
      "node_id": "LE_lADOABII586gNt5RzwAAAAOWkHTG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15410951366",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-24T16:20:29Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15411081261,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOWknAt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15411081261",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1e432cae6b5005db209c10c28e9aa47cc3ac68df",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/1e432cae6b5005db209c10c28e9aa47cc3ac68df",
      "created_at": "2024-11-24T17:24:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15411231038,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOWlLk-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15411231038",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "36a9db46b664e2637a8add9201d2b5a91d7c24f1",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/36a9db46b664e2637a8add9201d2b5a91d7c24f1",
      "created_at": "2024-11-24T18:46:41Z"
    },
    {
      "event": "unlabeled",
      "id": 15411323294,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAOWliGe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15411323294",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-24T19:39:22Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15421286163,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOXLicT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15421286163",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "aa430ddacab7e119f36bc73dd46dd19ee4ac9180",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/aa430ddacab7e119f36bc73dd46dd19ee4ac9180",
      "created_at": "2024-11-25T14:04:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15421321817,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOXLrJZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15421321817",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "84fcb24ee16802e3538a0e7ee40d66b78bfad2e2",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/84fcb24ee16802e3538a0e7ee40d66b78bfad2e2",
      "created_at": "2024-11-25T14:07:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15427571318,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOXjg52",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15427571318",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a93de3b63fbd20ef3a2c0a5019f41f0e5c6ad8da",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a93de3b63fbd20ef3a2c0a5019f41f0e5c6ad8da",
      "created_at": "2024-11-25T22:35:30Z"
    },
    {
      "event": "labeled",
      "id": 15459146457,
      "node_id": "LE_lADOABII586gNt5RzwAAAAOZb9rZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15459146457",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-11-28T01:34:01Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15500928592,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOb7WZQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15500928592",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "c4b4e1f358c05415e691f7ceaba4cb203fffb127",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/c4b4e1f358c05415e691f7ceaba4cb203fffb127",
      "created_at": "2024-12-02T23:54:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15532933633,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOd1cIB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15532933633",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "18184f4e73404a7d41579fb408bd21f14c73668d",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/18184f4e73404a7d41579fb408bd21f14c73668d",
      "created_at": "2024-12-04T21:50:40Z"
    },
    {
      "event": "commented",
      "id": 2520463595,
      "node_id": "IC_kwDOABII586WOzjr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2520463595",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-05T14:22:51Z",
      "updated_at": "2024-12-05T14:22:51Z",
      "author_association": "MEMBER",
      "body": "Concept ACK",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2520463595",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15732581373,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOpvCP9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15732581373",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "19cd5a8c32da47b08721cec4b6f92b13080bb9df",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/19cd5a8c32da47b08721cec4b6f92b13080bb9df",
      "created_at": "2024-12-20T13:15:31Z"
    },
    {
      "event": "commented",
      "id": 2557349002,
      "node_id": "IC_kwDOABII586YbgyK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2557349002",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-20T16:33:51Z",
      "updated_at": "2024-12-20T16:33:51Z",
      "author_association": "MEMBER",
      "body": "I'm aware this is a big chunk of code, but perhaps this can aid review a bit.\r\n\r\nThe biggest commits is [txgraph: (feature) add initial version](https://github.com/bitcoin/bitcoin/pull/31363/commits/afc6a665770004411f1b57f4f43dda916dadd8f7). To get an idea of what is going on, I think it's useful to look (in order) at:\r\n* The `src/txgraph.h` file added in that commit, as it defines the public interface.\r\n* The `src/test/fuzz/txgraph.cpp` test added in the next commit ([txgraph: (tests) add simulation fuzz test](https://github.com/bitcoin/bitcoin/pull/31363/commits/fe5cba87972f192faa286473b3fbff96d2b1df29)), as it does to an extent show how the interface is used, and what is expected of it.\r\n* The data structures (`TxGraphImpl` and `Cluster`) in `src/txgraph.cpp`, and the internal functions corresponding to the 5 processing steps that happen:\r\n  * **Batch removal of queued transaction removals**: `TxGraphImpl::ApplyRemovals` and `Cluster::ApplyRemovals`.\r\n  * **Splitting of clusters into components after removing transactions**: `TxGraphImpl::SplitAll`, `TxGraphImpl::Split`, and `Cluster::Split`\r\n  * **Computing which clusters will need to be combined due to queued dependencies being added between them**: `TxGraphImpl::GroupClusters`.\r\n  * **Merging of clusters and applying queued dependencies to them**: `TxGraphImpl::ApplyDependencies`, `TxGraphImpl::Merge`, `Cluster::Merge`, `Cluster::ApplyDependencies`.\r\n  * **Making the linearization of clusters acceptable**: `TxGraphImpl::MakeAcceptable` and `Cluster::Relinearize`.\r\n* The interface implementation functions that are built on top in `TxGraphImpl`: `AddTransaction`, `RemoveTransaction`, `AddDependency`, `SetTransactionFee`, `Cleanup`, `GetAncestors`, `GetDescendants`, `GetCluster`, `GetChunkFeerate`, etc.\r\n\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2557349002",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15742002242,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOqS-RC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15742002242",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "72d3ca13b56b9ae17da1234f61a3e24874ab6d00",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/72d3ca13b56b9ae17da1234f61a3e24874ab6d00",
      "created_at": "2024-12-22T17:18:41Z"
    },
    {
      "event": "commented",
      "id": 2558527144,
      "node_id": "IC_kwDOABII586YgAao",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2558527144",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-22T17:23:23Z",
      "updated_at": "2024-12-23T03:21:54Z",
      "author_association": "MEMBER",
      "body": "I have pushed a substantial change to the `TxGraphImpl::GroupClusters` function (in commit \"txgraph: (feature) add initial version\"). In a benchmark with 64000 transactions being combined into 1000 clusters, this makes it go from ~160ms to ~16ms. I will add the benchmark to this PR when I clean it up.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2558527144",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "reviewed",
      "id": 2522187404,
      "node_id": "PRR_kwDOABII586WVYaM",
      "url": null,
      "actor": null,
      "commit_id": "72d3ca13b56b9ae17da1234f61a3e24874ab6d00",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\n\r\n> GetChunkFeerate (get the mining score of a transaction)\r\n\r\n\r\nFrom reading the description and skimming through the code, IIUC `TxGraph` encapsulates knowledge about fees and sizes but lacks knowledge about prioritization. This implies that the fee it uses is the effective fee, not the modified fee that includes prioritization.\r\n\r\nHow are we accounting for the real mining score of a  `Ref` without that prioritization knowledge? The current mining algorithm uses the modified ancestor fee to calculate the mining score.\r\n\r\nCould you clarify how prioritization will be handled post-cluster mempool?",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2522187404",
      "submitted_at": "2024-12-24T19:33:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "commented",
      "id": 2561368066,
      "node_id": "IC_kwDOABII586Yq2AC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2561368066",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-24T19:41:16Z",
      "updated_at": "2024-12-24T19:41:16Z",
      "author_association": "MEMBER",
      "body": "@ismaelsadeeq TxGraph (and DepGraph, and FeeFrac) just treat \"fee\" and \"size\" as numbers whose ratio is to be maximized. These classes don't care what meaning they correspond to.\n\nIn practice, I expect that the mempool code will provide the modified fee as \"fee\", and vsize or weight as \"size\".",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2561368066",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 15758399642,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAOrRhia",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15758399642",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-24T19:41:17Z"
    },
    {
      "event": "subscribed",
      "id": 15758399645,
      "node_id": "SE_lADOABII586gNt5RzwAAAAOrRhid",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15758399645",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-24T19:41:17Z"
    },
    {
      "event": "commented",
      "id": 2561403310,
      "node_id": "IC_kwDOABII586Yq-mu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2561403310",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-12-24T20:37:46Z",
      "updated_at": "2024-12-24T20:37:46Z",
      "author_association": "MEMBER",
      "body": "Thank you for clarifying. Reading 'lacks knowledge about prioritization' led me to infer that.\r\nBut I see now you are talking about `mapDeltas`",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2561403310",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15861068971,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOxZLSr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15861068971",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "56684bc3f6f1adc5e70042d7792cb5e9d65bace0",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/56684bc3f6f1adc5e70042d7792cb5e9d65bace0",
      "created_at": "2025-01-08T23:26:27Z"
    },
    {
      "event": "reviewed",
      "id": 2529361978,
      "node_id": "PRR_kwDOABII586WwwA6",
      "url": null,
      "actor": null,
      "commit_id": "56684bc3f6f1adc5e70042d7792cb5e9d65bace0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2529361978",
      "submitted_at": "2025-01-09T18:49:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15873834591,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAOyJ35f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873834591",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "dfa4d694052ecd2e2f1b2ac8f55a09682ee531c3",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/dfa4d694052ecd2e2f1b2ac8f55a09682ee531c3",
      "created_at": "2025-01-09T21:33:31Z"
    },
    {
      "event": "commented",
      "id": 2581309699,
      "node_id": "IC_kwDOABII586Z26kD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2581309699",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T21:49:44Z",
      "updated_at": "2025-01-09T21:49:44Z",
      "author_association": "MEMBER",
      "body": "A few changes:\r\n* Added a `TxGraph::DoWork()` functions which performs queued-up computations now, so that future operations are fast.\r\n* Make `Ref&` arguments to `TxGraph::AddDependency`, `TxGraph::RemoveTransaction`, and `TxGraph::SetTransactionFee` const. They do not modify the `Ref` itself; they only modify what the `Ref` points to.\r\n* Address review comments by @ismaelsadeeq here, and @theuni on #31553.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2581309699",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 15873987568,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAOyKdPw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873987568",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T21:49:46Z"
    },
    {
      "event": "subscribed",
      "id": 15873987577,
      "node_id": "SE_lADOABII586gNt5RzwAAAAOyKdP5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873987577",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T21:49:46Z"
    },
    {
      "event": "mentioned",
      "id": 15873987589,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAOyKdQF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873987589",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T21:49:46Z"
    },
    {
      "event": "subscribed",
      "id": 15873987595,
      "node_id": "SE_lADOABII586gNt5RzwAAAAOyKdQL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15873987595",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-09T21:49:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 15967718035,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAO3wAqT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/15967718035",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0da43c221757cf6b4f2d71d1a4c08152808365c2",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/0da43c221757cf6b4f2d71d1a4c08152808365c2",
      "created_at": "2025-01-16T21:11:22Z"
    },
    {
      "event": "commented",
      "id": 2596901446,
      "node_id": "IC_kwDOABII586ayZJG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2596901446",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-16T21:14:50Z",
      "updated_at": "2025-01-16T21:14:50Z",
      "author_association": "MEMBER",
      "body": "Added an additional inspector function:\r\n* `CountDistinctClusters`, which efficiently counts how many distinct clusters a list of specified Refs belong to, for helping with enforcing RBF cluster policy limits.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2596901446",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16034220885,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAO7tstV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16034220885",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "71b5d5325e7688a0d1a6d886a75fd6cba9214fc5",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/71b5d5325e7688a0d1a6d886a75fd6cba9214fc5",
      "created_at": "2025-01-22T19:59:12Z"
    },
    {
      "event": "commented",
      "id": 2608148864,
      "node_id": "IC_kwDOABII586bdTGA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2608148864",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-22T19:59:44Z",
      "updated_at": "2025-01-22T20:05:45Z",
      "author_association": "MEMBER",
      "body": "I split out two optimizations to `TxGraphImpl::GroupClusters()` from the initial commit into their own commits.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2608148864",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "reviewed",
      "id": 2568243605,
      "node_id": "PRR_kwDOABII586ZFEmV",
      "url": null,
      "actor": null,
      "commit_id": "71b5d5325e7688a0d1a6d886a75fd6cba9214fc5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Pumpkin1234567812",
        "id": 190252804,
        "node_id": "U_kgDOC1cHBA",
        "avatar_url": "https://avatars.githubusercontent.com/u/190252804?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Pumpkin1234567812",
        "html_url": "https://github.com/Pumpkin1234567812",
        "followers_url": "https://api.github.com/users/Pumpkin1234567812/followers",
        "following_url": "https://api.github.com/users/Pumpkin1234567812/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Pumpkin1234567812/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Pumpkin1234567812/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Pumpkin1234567812/subscriptions",
        "organizations_url": "https://api.github.com/users/Pumpkin1234567812/orgs",
        "repos_url": "https://api.github.com/users/Pumpkin1234567812/repos",
        "events_url": "https://api.github.com/users/Pumpkin1234567812/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Pumpkin1234567812/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2568243605",
      "submitted_at": "2025-01-22T20:51:13Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "commented",
      "id": 2610513537,
      "node_id": "IC_kwDOABII586bmUaB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2610513537",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T17:28:34Z",
      "updated_at": "2025-01-23T17:28:34Z",
      "author_association": "MEMBER",
      "body": "A suggestion for simplifying the removed/destroyed/unlinked/cleanup interface.\r\n\r\n* Unlinking *only* happens when the calling code destroys a `Ref`. Currently, unlinking can happen either through `Ref` destruction, or through `TxGraph::Cleanup()` (which unlinks anything not appearing in the graph anymore).\r\n* The `TxGraphImpl::m_entries` vector compaction happens transparently, whenever applicable; there is no `TxGraph::Cleanup()` any more. This can only happen after the corresponding `Ref` was destroyed (because that's now the only way to unlink).\r\n* To assist the calling code with cleaning up `Ref`s, a new `TxGraph::GetRemoved()` function is added, which is a pure inspector, and reports which Refs do not appear in either main or staging (if present) anymore.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2610513537",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "commented",
      "id": 2610532310,
      "node_id": "IC_kwDOABII586bmY_W",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2610532310",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T17:35:13Z",
      "updated_at": "2025-01-23T17:35:13Z",
      "author_association": "MEMBER",
      "body": "> Unlinking only happens when the calling code destroys a Ref. Currently, unlinking can happen either through Ref destruction, or through TxGraph::Cleanup() (which unlinks anything not appearing in the graph anymore).\r\n\r\nthis would result in:\r\n1) exists\r\n1) removed\r\n2) unlinked + destroyed\r\n\r\nas the three possible states?",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2610532310",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "commented",
      "id": 2610539292,
      "node_id": "IC_kwDOABII586bmasc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2610539292",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T17:38:31Z",
      "updated_at": "2025-01-23T17:39:05Z",
      "author_association": "MEMBER",
      "body": "@instagibbs Right. Though \"removed/exists\" is really a per-graph (main vs staging) thing, while destroyed+unlinked are TxGraph-wide.\r\n\r\nMaybe it should not be called `GetRemoved()`, as that term is ambiguous. How about `GetUnusedRefs` or so?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2610539292",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 16047595077,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAO8gt5F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16047595077",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T17:38:32Z"
    },
    {
      "event": "subscribed",
      "id": 16047595090,
      "node_id": "SE_lADOABII586gNt5RzwAAAAO8gt5S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16047595090",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T17:38:32Z"
    },
    {
      "event": "commented",
      "id": 2611076895,
      "node_id": "IC_kwDOABII586bod8f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2611076895",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T21:42:42Z",
      "updated_at": "2025-01-23T21:42:42Z",
      "author_association": "MEMBER",
      "body": "Actually, having this `GetUnusedRefs()` is pretty annoying (read: would require extra per-transaction memory) to be efficiently implementable, and talking to @sdaftuar it does not seem important if `Trim()` can report what it is deleting (because that's really the only place where `TxGraphImpl` makes a decision about which transactions belong to the graph).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2611076895",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 16050290986,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAO8rAEq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16050290986",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T21:42:43Z"
    },
    {
      "event": "subscribed",
      "id": 16050291017,
      "node_id": "SE_lADOABII586gNt5RzwAAAAO8rAFJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16050291017",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-23T21:42:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16064770286,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAO9iPDu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16064770286",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "02581df936143cdc6690563cd0bfbf4d4d145a06",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/02581df936143cdc6690563cd0bfbf4d4d145a06",
      "created_at": "2025-01-24T22:10:54Z"
    },
    {
      "event": "commented",
      "id": 2613487643,
      "node_id": "IC_kwDOABII586bxqgb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613487643",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T22:14:00Z",
      "updated_at": "2025-01-24T22:17:26Z",
      "author_association": "MEMBER",
      "body": "Some changes:\r\n* `Cleanup` is gone. Compaction now happens automatically and transparently, but the caller is responsible for destroying `Refs` when they are no longer needed.\r\n* Avoid re-`Group`-ing when trying to determine oversizedness while it is already known.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2613487643",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "commented",
      "id": 2613583764,
      "node_id": "IC_kwDOABII586byB-U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2613583764",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:16Z",
      "updated_at": "2025-01-24T23:23:16Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36148884388</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2613583764",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "labeled",
      "id": 16065343411,
      "node_id": "LE_lADOABII586gNt5RzwAAAAO9ka-z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16065343411",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-24T23:23:16Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16068864633,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAO9x2p5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16068864633",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "aa8abdd0dc594bc27d4b08ce1b9f692504af3062",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/aa8abdd0dc594bc27d4b08ce1b9f692504af3062",
      "created_at": "2025-01-26T04:34:32Z"
    },
    {
      "event": "commented",
      "id": 2614209064,
      "node_id": "IC_kwDOABII586b0aoo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2614209064",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T04:41:05Z",
      "updated_at": "2025-01-26T04:41:05Z",
      "author_association": "MEMBER",
      "body": "* Split out a memory optimization in `GroupClusters` to its own commit.\r\n* Moved caching of oversizedness to its own commit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2614209064",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16070938168,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAO95w44",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16070938168",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "fc3d91aa89a54b7d41a148e49cbd5949087dea13",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/fc3d91aa89a54b7d41a148e49cbd5949087dea13",
      "created_at": "2025-01-26T19:55:48Z"
    },
    {
      "event": "commented",
      "id": 2614570302,
      "node_id": "IC_kwDOABII586b1y0-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2614570302",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T20:00:08Z",
      "updated_at": "2025-01-26T20:09:19Z",
      "author_association": "MEMBER",
      "body": "* Remove the `TxGraph::Ref::operator bool()`; it has little use now that cleanup is implicit.\r\n* Add assertion that cluster count limit is at least 1.\r\n* Modify fuzz test to use `TxGraph::Ref` pointers everywhere rather than references; I realized the existing (test) code was not entirely kosher (could sometimes use a reference to an object that was already destroyed).",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2614570302",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "unlabeled",
      "id": 16071114610,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAO96b9y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16071114610",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-26T21:27:14Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2576309881,
      "node_id": "PRR_kwDOABII586Zj155",
      "url": null,
      "actor": null,
      "commit_id": "fc3d91aa89a54b7d41a148e49cbd5949087dea13",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2576309881",
      "submitted_at": "2025-01-27T21:22:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16131773852,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPBh1Wc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16131773852",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "a4d4c1ca899806aeff14b3644868e185c4010b6f",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/a4d4c1ca899806aeff14b3644868e185c4010b6f",
      "created_at": "2025-01-30T23:45:43Z"
    },
    {
      "event": "commented",
      "id": 2625954984,
      "node_id": "IC_kwDOABII586chOSo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2625954984",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-30T23:47:22Z",
      "updated_at": "2025-01-30T23:47:22Z",
      "author_association": "MEMBER",
      "body": "* Introduce vsize and weight tagged versions of FeeFrac, to avoid accidental type confusion.\r\n* Convert all of txgraph to work using FeePerWeight, rather than bare FeeFrac.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2625954984",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "labeled",
      "id": 16132405655,
      "node_id": "LE_lADOABII586gNt5RzwAAAAPBkPmX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16132405655",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T01:01:23Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16134008435,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPBqW5z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134008435",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "3c7732bbbe735d1883cdd1737ec200cab8caa049",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/3c7732bbbe735d1883cdd1737ec200cab8caa049",
      "created_at": "2025-01-31T04:59:27Z"
    },
    {
      "event": "unlabeled",
      "id": 16134472463,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAPBsIMP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16134472463",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-01-31T06:09:38Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16146250147,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPCZDmj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16146250147",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "164042138be65b8d53eaeb1549c5e09c10b6fb30",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/164042138be65b8d53eaeb1549c5e09c10b6fb30",
      "created_at": "2025-01-31T22:01:59Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16148265930,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPCgvvK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16148265930",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8619c7910100abb335ad05e59f7f89ff230fdd9b",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/8619c7910100abb335ad05e59f7f89ff230fdd9b",
      "created_at": "2025-02-01T03:44:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16181717548,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPEgWos",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16181717548",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "68435c7a4f1e66583cf98bc4cce51325be5cd00d",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/68435c7a4f1e66583cf98bc4cce51325be5cd00d",
      "created_at": "2025-02-04T16:18:38Z"
    },
    {
      "event": "labeled",
      "id": 16184299728,
      "node_id": "LE_lADOABII586gNt5RzwAAAAPEqNDQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16184299728",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T19:44:49Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 16186240244,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAPExmz0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16186240244",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-04T23:01:18Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16204093880,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPF1tm4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16204093880",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "8923131847d682d423094cc1f3f5404125881262",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/8923131847d682d423094cc1f3f5404125881262",
      "created_at": "2025-02-06T04:28:45Z"
    },
    {
      "event": "commented",
      "id": 2638798337,
      "node_id": "IC_kwDOABII586dSN4B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2638798337",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-06T04:30:39Z",
      "updated_at": "2025-02-06T04:30:39Z",
      "author_association": "MEMBER",
      "body": "Changed:\r\n* Added `GetAncestorsUnion` and `GetDescendantsUnion`, which act like their non-union version, but take in a span of multiple `Ref*`, and return the `Ref*` for the union of their ancestors/descendants\r\n\r\n(requested by @sdaftuar while rebasing #28676)",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2638798337",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 16204104235,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAPF1wIr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16204104235",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-06T04:30:40Z"
    },
    {
      "event": "subscribed",
      "id": 16204104244,
      "node_id": "SE_lADOABII586gNt5RzwAAAAPF1wI0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16204104244",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-06T04:30:40Z"
    },
    {
      "event": "reviewed",
      "id": 2593986518,
      "node_id": "PRR_kwDOABII586anRfW",
      "url": null,
      "actor": null,
      "commit_id": "8923131847d682d423094cc1f3f5404125881262",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review to 741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2593986518",
      "submitted_at": "2025-02-10T22:02:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16271011089,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPJ0-0R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16271011089",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "66726102a7f40c608cb24f5d3bc405634f38e028",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/66726102a7f40c608cb24f5d3bc405634f38e028",
      "created_at": "2025-02-11T20:33:42Z"
    },
    {
      "event": "reviewed",
      "id": 2512158583,
      "node_id": "PRR_kwDOABII586VvH93",
      "url": null,
      "actor": null,
      "commit_id": "66726102a7f40c608cb24f5d3bc405634f38e028",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "reviewed up to \"txgraph: (feature) add initial version\" 781c15bfca1ebaffe7b634196e19144f5ab10a50 , basically all nits at this point, logic all makes sense\r\n\r\nOne question I had coming up is use of `Assume()`, there is a number of places that `Assume()` is used, then subsequently may result in UB or weird behavior. In a few spots I gave suggestions but was wondering if there is thinking behind doing more (or Assert'ing) or not to handle that in release builds.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2512158583",
      "submitted_at": "2025-02-12T16:22:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "reviewed",
      "id": 2612555689,
      "node_id": "PRR_kwDOABII586buG-p",
      "url": null,
      "actor": null,
      "commit_id": "66726102a7f40c608cb24f5d3bc405634f38e028",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2612555689",
      "submitted_at": "2025-02-12T21:15:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16287921202,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPK1fQy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16287921202",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1a2ea915399268da196af1cffbc6139778bd91e2",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/1a2ea915399268da196af1cffbc6139778bd91e2",
      "created_at": "2025-02-12T22:31:01Z"
    },
    {
      "event": "labeled",
      "id": 16288585035,
      "node_id": "LE_lADOABII586gNt5RzwAAAAPK4BVL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16288585035",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T00:01:40Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2655117760,
      "node_id": "IC_kwDOABII586eQeHA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2655117760",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T00:01:41Z",
      "updated_at": "2025-02-13T00:01:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/37128519486</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2655117760",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16290338499,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPK-tbD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16290338499",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "0613e8ed3817d7169ac2831680b22d2380bfe78e",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/0613e8ed3817d7169ac2831680b22d2380bfe78e",
      "created_at": "2025-02-13T04:34:46Z"
    },
    {
      "event": "unlabeled",
      "id": 16291108086,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAPLBpT2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16291108086",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-13T06:09:00Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2616111942,
      "node_id": "PRR_kwDOABII586b7rNG",
      "url": null,
      "actor": null,
      "commit_id": "0613e8ed3817d7169ac2831680b22d2380bfe78e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2616111942",
      "submitted_at": "2025-02-13T22:28:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "reviewed",
      "id": 2618143580,
      "node_id": "PRR_kwDOABII586cDbNc",
      "url": null,
      "actor": null,
      "commit_id": "0613e8ed3817d7169ac2831680b22d2380bfe78e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code Review e19bbc328236f64716034277857951184309cd14\r\n\r\nIt seems to me that this is designed with the flexibility to accommodate more levels, which explains the use of `std::vector` for `ClusterSet`\r\n\r\nIf yes then current approach is perfect else would it be better for `TxGraph` to maintain a `std::array` of two `ClusterSet? `main` and `staging and store their indexes in `TxGraph` as enums? This way, `Cluster` would only need to maintain that enum.  \r\n\r\nIn `ClusterSet`, we could introduce a boolean to indicate whether a set is active or not.  \r\n\r\nThe `main` set could always remain active, while `staging` would be flexible and toggleable.  \r\n\r\nThus, when we start staging, we can simply mark the back array as active, and once done, clear the back array and mark it as inactive.  \r\n\r\nI believe this approach would reduce Assumes since we explicitly know we can only have two ClusterSet's.  \r\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2618143580",
      "submitted_at": "2025-02-14T17:36:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16318036608,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPMoXqA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16318036608",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "2258e34641e1df1ad32a7f26bc185ad9b9f7a086",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/2258e34641e1df1ad32a7f26bc185ad9b9f7a086",
      "created_at": "2025-02-14T22:28:12Z"
    },
    {
      "event": "reviewed",
      "id": 2624059438,
      "node_id": "PRR_kwDOABII586cZ_gu",
      "url": null,
      "actor": null,
      "commit_id": "2258e34641e1df1ad32a7f26bc185ad9b9f7a086",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2624059438",
      "submitted_at": "2025-02-18T20:07:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "commented",
      "id": 2666866811,
      "node_id": "IC_kwDOABII586e9Sh7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2666866811",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-18T20:30:02Z",
      "updated_at": "2025-02-18T20:30:02Z",
      "author_association": "MEMBER",
      "body": "@ismaelsadeeq \r\n\r\n> It seems to me that this is designed with the flexibility to accommodate more levels, which explains the use of `std::vector` for `ClusterSet`\r\n\r\nIt's not really written with the intent of accomodating more levels; it's more that I found it more elegant to write it generically, because most operations don't care what level they are operating on. I can see that the increased abstraction may be confusing though; I'd like to hear more reviewer comments on this.\r\n\r\n> If yes then current approach is perfect else would it be better for `TxGraph` to maintain a `std::array` of two `ClusterSet? `main`and`staging and store their indexes in `TxGraph` as enums? This way, `Cluster` would only need to maintain that enum.\r\n> \r\n> In `ClusterSet`, we could introduce a boolean to indicate whether a set is active or not.\r\n\r\nI think it's more natural to use a vector, which implicitly encodes how many there are, and it means one can always use `m_clustersets.back()` to refer to the top set, regardless of whether main/staging exist; the alternative would involve checking whether `m_clustersets[1].m_active` is true or not. Performance isn't a concern here either; they're big data structures that aren't created/destroyed inside tight loops.\r\n\r\n> The `main` set could always remain active, while `staging` would be flexible and toggleable.\r\n> \r\n> Thus, when we start staging, we can simply mark the back array as active, and once done, clear the back array and mark it as inactive.\r\n> \r\n> I believe this approach would reduce Assumes since we explicitly know we can only have two ClusterSet's.\r\n\r\nTrue, but it would also add a consistency requirement that `m_clustersets[0].m_active` is always true, for example. And of course, `Assume`s are never \"necessary\"; they're there to help review (by convincing people that if the condition didn't hold, presumably a test could hit it). If you find an `Assume` that's more cluttering than helpful, it can always just be dropped too.\r\n\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2666866811",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 16355236892,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAPO2Rwc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16355236892",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-18T20:30:04Z"
    },
    {
      "event": "subscribed",
      "id": 16355236904,
      "node_id": "SE_lADOABII586gNt5RzwAAAAPO2Rwo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16355236904",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-18T20:30:04Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16386464388,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPQtZqE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16386464388",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "11135464c5c3aef1ce8d2823120467a522ce2c87",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/11135464c5c3aef1ce8d2823120467a522ce2c87",
      "created_at": "2025-02-20T17:21:02Z"
    },
    {
      "event": "commented",
      "id": 2672180797,
      "node_id": "IC_kwDOABII586fRj49",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2672180797",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-20T17:24:47Z",
      "updated_at": "2025-02-20T17:25:55Z",
      "author_association": "MEMBER",
      "body": "I have modified (in \"add staging support\" and further) the TxGraph functions relating to the normalization steps to all take a level argument as input (`ApplyRemovals`, `SplitAll`, `GroupClusters`, `ApplyDependencies`, and `MakeAllAcceptable`). This meant a number of repeated sequences like:\r\n\r\n```c++\r\n    SplitAll(0);\r\n    if (m_clustersets.size() == 1) ApplyDependencies();\r\n```\r\n\r\ncould be changed into just\r\n\r\n```\r\n    ApplyDependencies(0);\r\n```",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2672180797",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "comment_deleted",
      "id": 16389938408,
      "node_id": "CDE_lADOABII586gNt5RzwAAAAPQ6pzo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16389938408",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-20T22:09:43Z"
    },
    {
      "event": "reviewed",
      "id": 2612580796,
      "node_id": "PRR_kwDOABII586buNG8",
      "url": null,
      "actor": null,
      "commit_id": "11135464c5c3aef1ce8d2823120467a522ce2c87",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Looking good 11135464c5c3aef1ce8d2823120467a522ce2c87\r\n\r\nI just have conceptual issues with what PostLinerize is guaranteeing us beyond what is explicitly stated in the header file. \r\n\r\nPile of nits/questions otherwise",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2612580796",
      "submitted_at": "2025-02-21T17:07:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16407984992,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPR_ftg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16407984992",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "d5abb86439e79d4adfbfbd46f833268bbca0bf6e",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/d5abb86439e79d4adfbfbd46f833268bbca0bf6e",
      "created_at": "2025-02-21T22:10:04Z"
    },
    {
      "event": "reviewed",
      "id": 2634380073,
      "node_id": "PRR_kwDOABII586dBXMp",
      "url": null,
      "actor": null,
      "commit_id": "d5abb86439e79d4adfbfbd46f833268bbca0bf6e",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Addressed most comments. I will address the `PostLinearize` related ones later.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2634380073",
      "submitted_at": "2025-02-21T22:25:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "commented",
      "id": 2675849453,
      "node_id": "IC_kwDOABII586ffjjt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2675849453",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-02-22T00:02:26Z",
      "updated_at": "2025-02-22T00:02:26Z",
      "author_association": "MEMBER",
      "body": "verified changes, just waiting on further PostLinearization commentary\r\n\r\nvia `git range-diff master 11135464c5c3aef1ce8d2823120467a522ce2c87 d5abb86439e79d4adfbfbd46f833268bbca0bf6e`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2675849453",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "commented",
      "id": 2695441852,
      "node_id": "IC_kwDOABII586gqS28",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2695441852",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-03T20:15:26Z",
      "updated_at": "2025-03-03T20:15:26Z",
      "author_association": "MEMBER",
      "body": "@instagibbs So... it seems that the \"optimal linearization, truncate, postlinearize, split\" does not actually result in minimal chunks (but it does result in feerate-diagram-optimal ones, and connected ones):\r\n\r\n```mermaid\r\ngraph BT;T18[\"A: 4\"];T19[\"B: 5\"];T20[\"C: 7\"];T20-->T18;T20-->T13;T9[\"D: 7\"];T9-->T18;T9-->T19;T13[\"E: 6\"];T13-->T19;\r\n```\r\n\r\nThe original (optimal) linearization is [ABEDC]. It's just a single chunk, so really any ordering is equally good.\r\n\r\nTruncation removes C. Postlinearization turns it into [BADE]. However, a 2-chunk alternative exists: [BE,AD].",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2695441852",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 16540328010,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAPZ4WBK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16540328010",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-03T20:15:27Z"
    },
    {
      "event": "subscribed",
      "id": 16540328029,
      "node_id": "SE_lADOABII586gNt5RzwAAAAPZ4WBd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16540328029",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-03T20:15:27Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16541401810,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPZ8cLS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16541401810",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "created_at": "2025-03-03T21:53:13Z"
    },
    {
      "event": "commented",
      "id": 2695648258,
      "node_id": "IC_kwDOABII586grFQC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2695648258",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-03T21:54:10Z",
      "updated_at": "2025-03-03T21:54:10Z",
      "author_association": "MEMBER",
      "body": "I have dropped the `QualityLevel::NEEDS_SPLIT_OPTIMAL` value, and made the \"post-linearize after remove, before split\" apply to `NEEDS_SPLIT_ACCEPTABLE` instead, with updated comments about it.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2695648258",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "commented",
      "id": 2698367852,
      "node_id": "IC_kwDOABII586g1dNs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2698367852",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-04T17:09:36Z",
      "updated_at": "2025-03-04T17:09:36Z",
      "author_association": "MEMBER",
      "body": "ACK 72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92\r\n\r\nWith the weaker claims in the code re:PostLinearization, it works for me, and obviates the need for an additional harness test.\r\n\r\n`git range-diff master d5abb86439e79d4adfbfbd46f833268bbca0bf6e 72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92`",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2698367852",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "review_requested",
      "id": 16567299010,
      "node_id": "RRE_lADOABII586gNt5RzwAAAAPbfOvC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16567299010",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-04T17:09:41Z",
      "requested_reviewer": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 16567299169,
      "node_id": "RRE_lADOABII586gNt5RzwAAAAPbfOxh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16567299169",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-04T17:09:42Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 2665558763,
      "node_id": "PRR_kwDOABII586e4TLr",
      "url": null,
      "actor": null,
      "commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code review ACK 72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92 ðŸ›¸ \r\n\r\nI've reviewed each commit and also looked at how the interface is being used by `CTxMemPool` in the big PR",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2665558763",
      "submitted_at": "2025-03-06T20:29:23Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "reviewed",
      "id": 2684192006,
      "node_id": "PRR_kwDOABII586f_YUG",
      "url": null,
      "actor": null,
      "commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "This seems fairly difficult to review -- there's a lot of mostly implicit background in what TxGraph does and why it does it that way, as evidenced by both the description in this PR and in the [review club](https://bitcoincore.reviews/31363).\r\n\r\nWhen I started typing this comment, I was wondering if maybe it would make sense to make the commits here into more of a gentle introduction to TxGraph, rather than one commit that does everything, then optimisations. But I don't really think that approach would survive subsequent modifications to the code very well. Likewise for just adding more comments to the code.\r\n\r\nAlternatively, I wonder if it would be helpful both for new devs and debugging to expose the TxGraph API as a python module, possibly with additional debugging handles so that you can examine internal state? I could imagine an interactive python notebook that allows you to interact with a real TxGraph being a useful experimental tool for learning/writing mempool code and also being something that could perhaps be reasonably maintained. [Here's](https://github.com/ajtowns/bitcoin/commits/202503-txgraph-python/) a rough take at what that might look like. It's using boost-python, which seems reasonable, but doesn't seem super friendly to pure-virtual classes (hence the tedious wrapper class) ~~or move-only objects (hence AddTransaction being wrapped via a constructor)~~. (EDIT: add link for \"here's\"; EDIT2: converting the `vector<Ref*>` stuff to python made the move-only Ref stuff irrelevant; the wrapper class isn't quite so tedious any more either really)\r\n\r\nComments below are mostly a bunch of nits/observations while familiarising myself with the code, feel free to ignore.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2684192006",
      "submitted_at": "2025-03-17T17:30:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "reviewed",
      "id": 2694691922,
      "node_id": "PRR_kwDOABII586gnbxS",
      "url": null,
      "actor": null,
      "commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Preliminary ACK 72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92\r\n\r\nI think it's okay to merge this code:\r\n * as of this PR, it isn't actually used, so should not introduce bugs immediately\r\n * the fuzz testing is pretty good, so there should not be any catastrophic bugs even if it were used\r\n * while maybe the design could be improved, that can be done incrementally after it's merged\r\n * I'm reasonably confident I understand what's going on and can help find/fix bugs/problems if they occur\r\n * I think the design and implementation are a good step forward for implementing cluster mempool\r\n\r\nOn the other hand, calling this \"preliminary\" as:\r\n * I'm not yet confident that I could maintain this code if its authors all suddenly vanished\r\n * I'm a bit concerned that to contribute to mempool code you might need to be a triple expert -- C++, bitcoin, and industrial optimisation theory; not a show stopper, but as further PRs progress I'd like to gain confidence either that the optimisation parts can be safely treated as a very stable black box, or (ideally and) that we can reasonably onboard people to understand how the internals of the black box work.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2694691922",
      "submitted_at": "2025-03-18T18:03:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "commented",
      "id": 2734449766,
      "node_id": "IC_kwDOABII586i_GRm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2734449766",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T19:12:10Z",
      "updated_at": "2025-03-18T19:12:10Z",
      "author_association": "MEMBER",
      "body": "@ajtowns Responding to some of the more conceptual comments\r\n\r\n* I'm indeed not entirely happy with the cycles between `TxGraphImpl` and `Cluster`, though there is a design concern that isn't really materialized in the current code yet: `Cluster` may become a virtual class with multiple implementations for the purpose of memory usage (e.g., there could be a specialized `SingletonCluster` which just stores a single transaction, and no DepGraph, linearization, ..., avoiding several vectors and their allocation overhead). The current code is designed to accommodate that, by putting code in `Cluster` member functions that need to have access to the internals, while having the generic code in `TxGraphImpl`. It's still not trivial to introduce, because cluster merging/splitting needs to somehow work for all combination of cluster types, but to the extent I can say without actually having implemented it, I think it's fairly close to that. I'm happy to hear about alternative approaches.\r\n\r\n* The above relates somewhat to the `m_setindex`/`m_quality`/`m_level` not feeling like they deserve to be dealt with in `Cluster`: indeed, they're per-Cluster data, but not part of the \"cluster implementation specific\" code, so I was imagining these (the variables, and functions relating to them) to be part of the abstract base class for Cluster, and not in the Cluster derived classes. It would be possible to move the related functions to `TxGraphImpl` instead, but if this virtual Cluster design appears, maybe having it in the Cluster base class is actually more clear anyway?\r\n\r\n* Regarding `Assume` / `Assert` / `assert`. It's true that semantically speaking, `Assume()` is always evaluated (so it's fine to have side effects inside). However, it's also the case that if the compiler can prove a statement is side-effect free, it can optimize the call away in non-debug builds. So I'm using them as a form of cheap assertion that can be used extensively throughout the codebase, most of which without runtime impact in production, compiler-proven to have same side-effects in debug and release builds. Combined with (fuzz) tests with high branch coverage, I believe this gives you the best of both worlds for non-critical assertions that still help reviewers reason about the code (as a \"ah, an Assume(), I can be reasonably assured that in fuzz-test-reachable-scenarios, this condition is actually always true\").\r\n\r\n* Regarding the destruction of `Ref` objects and removing/unlinking. Note that the behavior changes: in the initial commit you can only destroy `Ref` objects whose transactions have already been `RemoveTransaction()`d, so that there is never a need for an inspector function to refer back to it anymore. In a later commit, `Ref` destroying is changed to automatically trigger a removal in the linked TxGraph if any (in both main and staging, which RemoveTransaction can't do, as it only works on the top level).\r\n\r\n  The current design tries very hard to make sure that under all circumstances, `TxGraph` is internally consistent (including when destroying non-removed Ref objects, which necessitates the `m_graph` pointer inside), but the responsibility to make sure the graph is externally consistent with the mempool lies outside. However, it doesn't actually achieve this design entirely when considering locking: one could accidentally destroy a `Ref` without holding whatever lock protects the `TxGraph` object, for example, and if we need to restrict to only supporting \"sane\" behavior, maybe an alternative design is possible, where instead of `TxGraph::Ref::~Ref`, we have a `TxGraph::WipeTransaction(Ref&)` function (which does removing/unlinking/compacting as needed), and the actual `Ref` destructor then just `asserts(false);` if not wiped first? This would also remove the need for having an `m_graph` inside a `Ref` (or making it debug-only).\r\n\r\n* Regarding having a `ClusterSet m_main_clusterset; std::optional<ClusterSet> m_staging_clusterset` instead of a vector of `ClusterSets` (also tagging @instagibbs and @ismaelsadeeq who have commented about this). There is absolutely no intention of trying to accommodate multiple nested (or parallel) levels, and the design isn't aiming for that. I just found it more elegant to largely avoid treating main and staging as separate concepts, and instead see them as two copies of the same thing. I haven't tried the alternative, and there is probably a bunch of \"interact with level below\" that can become a bit more simple/specialized, but maybe also more logic for picking between `m_main_clusterset` and `m_staging_clusterset` (which aren't even the same type). If you all think it's worth trying, I'm happy to look into it.\r\n\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2734449766",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "mentioned",
      "id": 16843556836,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAPr9Efk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16843556836",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T19:12:12Z"
    },
    {
      "event": "subscribed",
      "id": 16843556868,
      "node_id": "SE_lADOABII586gNt5RzwAAAAPr9EgE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16843556868",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T19:12:12Z"
    },
    {
      "event": "mentioned",
      "id": 16843556900,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAPr9Egk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16843556900",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T19:12:12Z"
    },
    {
      "event": "subscribed",
      "id": 16843556923,
      "node_id": "SE_lADOABII586gNt5RzwAAAAPr9Eg7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16843556923",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T19:12:12Z"
    },
    {
      "event": "mentioned",
      "id": 16843556947,
      "node_id": "MEE_lADOABII586gNt5RzwAAAAPr9EhT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16843556947",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T19:12:12Z"
    },
    {
      "event": "subscribed",
      "id": 16843556969,
      "node_id": "SE_lADOABII586gNt5RzwAAAAPr9Ehp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16843556969",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-18T19:12:12Z"
    },
    {
      "event": "commented",
      "id": 2736410023,
      "node_id": "IC_kwDOABII586jGk2n",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2736410023",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T12:10:22Z",
      "updated_at": "2025-03-19T12:10:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "> * However, it's also the case that if the compiler can prove a statement is side-effect free, it can optimize the call away in non-debug builds.\r\n\r\nThat makes sense. Might be a good idea to update doc/developer-notes.md pointing out that use case? It currently says:\r\n\r\n> * `Assume` should be used to document assumptions when program execution can\r\n>   safely continue even if the assumption is violated. ",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2736410023",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16878639296,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPuC5jA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16878639296",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "148f173323e82515c55bd7d164e60b762c7e6a84",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/148f173323e82515c55bd7d164e60b762c7e6a84",
      "created_at": "2025-03-19T20:29:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16879664812,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPuGz6s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16879664812",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "4014860b51927aa3b04b95949a5fbe861aa76f81",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/4014860b51927aa3b04b95949a5fbe861aa76f81",
      "created_at": "2025-03-19T21:08:09Z"
    },
    {
      "event": "labeled",
      "id": 16879666106,
      "node_id": "LE_lADOABII586gNt5RzwAAAAPuG0O6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16879666106",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T21:08:16Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2738116646,
      "node_id": "IC_kwDOABII586jNFgm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2738116646",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-19T21:08:17Z",
      "updated_at": "2025-03-19T21:08:17Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39067477614</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2738116646",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16880119789,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPuIi_t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16880119789",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "created_at": "2025-03-19T21:24:04Z"
    },
    {
      "event": "reviewed",
      "id": 2700118245,
      "node_id": "PRR_kwDOABII586g8Ijl",
      "url": null,
      "actor": null,
      "commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Big change: `std::vector<ClusterSet>` is gone, replaced by `m_main_clusterset` and `m_staging_clusterset`.\r\n* New helper functions `GetTopLevel()`, `GetSpecifiedLevel()`, `GetClusterSet()` made this fairly easy to do.\r\n* Simplifications resulted in `ClearLocator`, `GetConflicts`, `PullIn`, `MakeTransactionsMissing`, `StartStaging`, `CommitStaging`, `ExtractCluster`.\r\n* `CopyTo` was renamed to `CopyToStaging`.\r\n* `LevelDown` was renamed to `MoveToMain`.\r\n* `MakeTransactionsMissing` was renamed to `MakeStagingTransactionsMissing`.\r\n\r\nOther changes:\r\n* Various comments\r\n* `Ref` objects are now allowed to outlive `TxGraph`.\r\n* `GetChunkFeerate` (and its testing, plus `Entry::m_chunk_feerate` maintenance) was moved to a separate commit.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2700118245",
      "submitted_at": "2025-03-19T21:34:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "unlabeled",
      "id": 16885811221,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAPueQgV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16885811221",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T00:40:21Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2701470073,
      "node_id": "PRR_kwDOABII586hBSl5",
      "url": null,
      "actor": null,
      "commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2701470073",
      "submitted_at": "2025-03-20T06:50:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "commented",
      "id": 2739415197,
      "node_id": "IC_kwDOABII586jSCid",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2739415197",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T07:10:46Z",
      "updated_at": "2025-03-20T07:10:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "(conflicts with just merged #31519, Span to std::span)",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2739415197",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "reviewed",
      "id": 2701725334,
      "node_id": "PRR_kwDOABII586hCQ6W",
      "url": null,
      "actor": null,
      "commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ReACK 63b8f96e67f9ad649070a231532d48fb6c3573e4 . Needs a rebase anyway though.\r\n\r\nThe main/staging changes read better to me fwiw. The level stuff in the locators could be ungeneralised as well I suppose, but that doesn't seem likely to be much of an improvement.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2701725334",
      "submitted_at": "2025-03-20T09:01:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "review_requested",
      "id": 16897146592,
      "node_id": "RRE_lADOABII586gNt5RzwAAAAPvJf7g",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16897146592",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T09:01:47Z",
      "requested_reviewer": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 16897146783,
      "node_id": "RRE_lADOABII586gNt5RzwAAAAPvJf-f",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16897146783",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T09:01:48Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "labeled",
      "id": 16899779073,
      "node_id": "LE_lADOABII586gNt5RzwAAAAPvTioB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16899779073",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T10:15:48Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 2702061968,
      "node_id": "PRR_kwDOABII586hDjGQ",
      "url": null,
      "actor": null,
      "commit_id": "101a8ee3280e50c3272a80939b46a67faca838e4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2702061968",
      "submitted_at": "2025-03-20T10:27:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "review_requested",
      "id": 16900035133,
      "node_id": "RRE_lADOABII586gNt5RzwAAAAPvUhI9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16900035133",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T10:28:04Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 2740049673,
      "node_id": "IC_kwDOABII586jUdcJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2740049673",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T11:23:01Z",
      "updated_at": "2025-03-20T11:23:01Z",
      "author_association": "MEMBER",
      "body": "> That makes sense. Might be a good idea to update doc/developer-notes.md pointing out that use case? It currently says:\r\n\r\nDone in #32100",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2740049673",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16909718415,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPv5dOP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16909718415",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "b4801d219da669c307397219f7e27d2694081ec0",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/b4801d219da669c307397219f7e27d2694081ec0",
      "created_at": "2025-03-20T13:38:57Z"
    },
    {
      "event": "commented",
      "id": 2740492781,
      "node_id": "IC_kwDOABII586jWJnt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2740492781",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T13:39:20Z",
      "updated_at": "2025-03-20T13:39:20Z",
      "author_association": "MEMBER",
      "body": "Rebased after the merge of #31519.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2740492781",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "labeled",
      "id": 16909756741,
      "node_id": "LE_lADOABII586gNt5RzwAAAAPv5mlF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16909756741",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T13:41:09Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2740497862,
      "node_id": "IC_kwDOABII586jWK3G",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2740497862",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T13:41:10Z",
      "updated_at": "2025-03-20T13:41:10Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39111521595</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2740497862",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16909816632,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPv51M4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16909816632",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1601906941fa559ebbee7898453fa77f4606ad38",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/1601906941fa559ebbee7898453fa77f4606ad38",
      "created_at": "2025-03-20T13:44:25Z"
    },
    {
      "event": "unlabeled",
      "id": 16912163320,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAPwCyH4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16912163320",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T14:36:46Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2740749545,
      "node_id": "IC_kwDOABII586jXITp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2740749545",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T14:55:55Z",
      "updated_at": "2025-03-20T14:55:55Z",
      "author_association": "MEMBER",
      "body": "reviewed via `git range-diff master 72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92 1601906941fa559ebbee7898453fa77f4606ad38`\r\n\r\n> Ref objects are now allowed to outlive TxGraph\r\n\r\nCan this get surfaced in the fuzz coverage with something that would previously fail? ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2740749545",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "unlabeled",
      "id": 16915235302,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAPwOgHm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16915235302",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-20T17:32:58Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2742606528,
      "node_id": "IC_kwDOABII586jeNrA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2742606528",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T07:56:04Z",
      "updated_at": "2025-03-21T07:56:04Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Can this get surfaced in the fuzz coverage with something that would previously fail?\r\n\r\nAs long as you actually run the fuzz binary with your changes, and not the fuzz binary in the old location that you compiled a few days ago (*cough*), the following should work:\r\n\r\n```diff\r\n--- a/src/test/fuzz/txgraph.cpp\r\n+++ b/src/test/fuzz/txgraph.cpp\r\n@@ -723,4 +723,6 @@ FUZZ_TARGET(txgraph)\r\n\r\n     // Sanity check again (because invoking inspectors may modify internal unobservable state).\r\n     real->SanityCheck();\r\n+    real.reset(); // kill the txgraph\r\n+    sims.clear(); // clear the sim container and any Refs\r\n }\r\n```\r\n\r\nDropping the `TxGraphImpl` destructor body then causes segfaults (rather than a nice assertion failure).",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2742606528",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "commented",
      "id": 2743809558,
      "node_id": "IC_kwDOABII586jizYW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2743809558",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T16:02:28Z",
      "updated_at": "2025-03-21T16:02:28Z",
      "author_association": "CONTRIBUTOR",
      "body": "ReACK 1601906941fa559ebbee7898453fa77f4606ad38",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2743809558",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "commented",
      "id": 2743883179,
      "node_id": "IC_kwDOABII586jjFWr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2743883179",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-21T16:30:41Z",
      "updated_at": "2025-03-21T16:30:41Z",
      "author_association": "MEMBER",
      "body": "reACK 1601906941fa559ebbee7898453fa77f4606ad38\r\n\r\n> Dropping the TxGraphImpl destructor body then causes segfaults (rather than a nice assertion failure).\r\n\r\nRight, I got myself turned around on this thinking it was harder to achieve. I'd suggest adding coverage here or in a quick follow-up.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2743883179",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16937112753,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPxh9Sx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16937112753",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "1e4af15e03e680232624657329d196927a01b308",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/1e4af15e03e680232624657329d196927a01b308",
      "created_at": "2025-03-22T00:06:21Z"
    },
    {
      "event": "reviewed",
      "id": 2707582068,
      "node_id": "PRR_kwDOABII586hYmx0",
      "url": null,
      "actor": null,
      "commit_id": "1601906941fa559ebbee7898453fa77f4606ad38",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Changes:\r\n* Did a big pass through the interface documentation in txgraph.h\r\n* Moved the support for Refs outliving TxGraph to a separate commit, and added the test suggested in https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2742606528.\r\n* Some smaller things listed below:\r\n",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2707582068",
      "submitted_at": "2025-03-22T00:06:52Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
    },
    {
      "event": "labeled",
      "id": 16937714282,
      "node_id": "LE_lADOABII586gNt5RzwAAAAPxkQJq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16937714282",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T01:22:35Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 2744858519,
      "node_id": "IC_kwDOABII586jmzeX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/2744858519",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T01:22:36Z",
      "updated_at": "2025-03-22T01:22:36Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39212798483</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2744858519",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/31363"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16938298913,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPxme4h",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16938298913",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "db2e90cb40b95ef4b26852c92fbf0a25854167ec",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/db2e90cb40b95ef4b26852c92fbf0a25854167ec",
      "created_at": "2025-03-22T03:36:56Z"
    },
    {
      "event": "unlabeled",
      "id": 16938688706,
      "node_id": "UNLE_lADOABII586gNt5RzwAAAAPxn-DC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16938688706",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-03-22T04:58:25Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDcxY2Y2ODVjNTE2ODgyZGY1MGUyMTNhMGY5NmNhYTE3NGYzYjFmNjg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/71cf685c516882df50e213a0f96caa174f3b1f68",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/71cf685c516882df50e213a0f96caa174f3b1f68",
      "tree": {
        "sha": "b4aba832d5493674b6a61e9aa6e78716a5c245d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b4aba832d5493674b6a61e9aa6e78716a5c245d0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a203928693cc838b8a8ec14df7c7dd3575b1a33d",
          "sha": "a203928693cc838b8a8ec14df7c7dd3575b1a33d",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a203928693cc838b8a8ec14df7c7dd3575b1a33d"
        }
      ],
      "message": "clusterlin: Add FixLinearization function + fuzz test\n\nThis function takes an existing ordering for transactions in a DepGraph, and\nmakes it a valid linearization for it (i.e., topological). Any topological\nprefix of the input remains untouched.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:20:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-10-25T18:11:50Z"
      },
      "sha": "71cf685c516882df50e213a0f96caa174f3b1f68"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ5ZDYwZmM2NmFmMjJlOTc0YTA2NTQwNTc2ODgwMTZhNzI2YzQ4MDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/49d60fc66af22e974a0654057688016a726c4800",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/49d60fc66af22e974a0654057688016a726c4800",
      "tree": {
        "sha": "3bccce9381db0571765107136375a0fd239982f5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3bccce9381db0571765107136375a0fd239982f5"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/71cf685c516882df50e213a0f96caa174f3b1f68",
          "sha": "71cf685c516882df50e213a0f96caa174f3b1f68",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/71cf685c516882df50e213a0f96caa174f3b1f68"
        }
      ],
      "message": "clusterlin: Make IsAcyclic() a DepGraph member function\n\n... instead of being a separate test-only function.\n\nAlso add a fuzz test for it returning false.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:20:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-12T20:13:58Z"
      },
      "sha": "49d60fc66af22e974a0654057688016a726c4800"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU2ZTQ2MzQwNTUwNGRjYjc1ODY3YTUyZTg2NTc5N2E1ZTc0OTAwNzM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56e463405504dcb75867a52e865797a5e7490073",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/56e463405504dcb75867a52e865797a5e7490073",
      "tree": {
        "sha": "375640aaf1e7822762c1767cdec3ebbd4c1d23c9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/375640aaf1e7822762c1767cdec3ebbd4c1d23c9"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/49d60fc66af22e974a0654057688016a726c4800",
          "sha": "49d60fc66af22e974a0654057688016a726c4800",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/49d60fc66af22e974a0654057688016a726c4800"
        }
      ],
      "message": "scripted-diff: (refactor) ClusterIndex -> DepGraphIndex\n\nSince cluster_linearize.h does not actually have a Cluster type anymore, it is more\nappropriate to rename the index type to DepGraphIndex.\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/Data type to represent transaction indices in clusters./Data type to represent transaction indices in DepGraphs and the clusters they represent./' $(git grep -l 'using ClusterIndex')\nsed -i 's|\\<ClusterIndex\\>|DepGraphIndex|g' $(git grep -l 'ClusterIndex')\n-END VERIFY SCRIPT-",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:20:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-31T21:26:06Z"
      },
      "sha": "56e463405504dcb75867a52e865797a5e7490073"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGQ1ZmFiMzM3Yjg3NTllZmNlMmJlZjAxNDZiMTc3N2U0YTk3MjFmNTA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5fab337b8759efce2bef0146b1777e4a9721f50",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/d5fab337b8759efce2bef0146b1777e4a9721f50",
      "tree": {
        "sha": "0f03b132b31d8088703da7c254d1f30bba63e55b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f03b132b31d8088703da7c254d1f30bba63e55b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56e463405504dcb75867a52e865797a5e7490073",
          "sha": "56e463405504dcb75867a52e865797a5e7490073",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/56e463405504dcb75867a52e865797a5e7490073"
        }
      ],
      "message": "feefrac: Introduce tagged wrappers to distinguish vsize/WU rates",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:20:37Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-30T22:14:52Z"
      },
      "sha": "d5fab337b8759efce2bef0146b1777e4a9721f50"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJmOGYwNGIxMWQyZDMzYmY1NTMxZGI2NWUyNTkwZmQyYWY1MDMyNTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf8f04b11d2d33bf5531db65e2590fd2af503255",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bf8f04b11d2d33bf5531db65e2590fd2af503255",
      "tree": {
        "sha": "a3a8b32ffb5cbf2e74dce1643c5ee416bb361735",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a3a8b32ffb5cbf2e74dce1643c5ee416bb361735"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5fab337b8759efce2bef0146b1777e4a9721f50",
          "sha": "d5fab337b8759efce2bef0146b1777e4a9721f50",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d5fab337b8759efce2bef0146b1777e4a9721f50"
        }
      ],
      "message": "txgraph: Add initial version (feature)\n\nThis adds an initial version of the txgraph module, with the TxGraph class.\nIt encapsulates knowledge about the fees, sizes, and dependencies between all\nmempool transactions, but nothing else.\n\nIn particular, it lacks knowledge about txids, inputs, outputs, CTransactions,\n... and so forth. Instead, it exposes a generic TxGraph::Ref type to reference\nnodes in the TxGraph, which can be passed around and stored by layers on top.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:44:09Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-08-21T18:37:00Z"
      },
      "sha": "bf8f04b11d2d33bf5531db65e2590fd2af503255"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE4NDgyOTRkZjdkNDNiYTg3OWJhZmM2ZjFiY2I1ZWQ2NDg3YjgwZTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a848294df7d43ba879bafc6f1bcb5ed6487b80e2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a848294df7d43ba879bafc6f1bcb5ed6487b80e2",
      "tree": {
        "sha": "5c32186c56fb43de04886692cf1d2dee003fde41",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5c32186c56fb43de04886692cf1d2dee003fde41"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf8f04b11d2d33bf5531db65e2590fd2af503255",
          "sha": "bf8f04b11d2d33bf5531db65e2590fd2af503255",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bf8f04b11d2d33bf5531db65e2590fd2af503255"
        }
      ],
      "message": "txgraph: Add simulation fuzz test (tests)\n\nThis adds a simulation fuzz test for txgraph, by comparing with a naive\nreimplementation that models the entire graph as a single DepGraph, and\nclusters in TxGraph as connected components within that DepGraph.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:44:13Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T19:15:12Z"
      },
      "sha": "a848294df7d43ba879bafc6f1bcb5ed6487b80e2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA4NjUzMjFjNDE0ZTUxM2FhNzI1ZjZkNWNmOTkxNGViNjNmZTkyYjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0865321c414e513aa725f6d5cf9914eb63fe92b7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0865321c414e513aa725f6d5cf9914eb63fe92b7",
      "tree": {
        "sha": "585975a9b51564dfb1c518ec1434dd7e52e036b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/585975a9b51564dfb1c518ec1434dd7e52e036b2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a848294df7d43ba879bafc6f1bcb5ed6487b80e2",
          "sha": "a848294df7d43ba879bafc6f1bcb5ed6487b80e2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a848294df7d43ba879bafc6f1bcb5ed6487b80e2"
        }
      ],
      "message": "txgraph: Add internal sanity check function (tests)\n\nTo make testing more powerful, expose a function to perform an internal sanity\ncheck on the state of a TxGraph. This is especially important as TxGraphImpl\ncontains many redundantly represented pieces of information:\n\n* graph contains clusters, which refer to entries, but the entries refer back\n* graph maintains pointers to Ref objects, which point back to the graph.\n\nThis lets us make sure they are always in sync.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:50Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T03:45:46Z"
      },
      "sha": "0865321c414e513aa725f6d5cf9914eb63fe92b7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRlOGZmYTk5ZjFkMzJkNWI1NjZhZjA3MTlhNWFmYjVhODlhNDMxYzI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e8ffa99f1d32d5b566af0719a5afb5a89a431c2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4e8ffa99f1d32d5b566af0719a5afb5a89a431c2",
      "tree": {
        "sha": "1d86b4fc3ea643a514dda9f6a484f25c2511c4cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1d86b4fc3ea643a514dda9f6a484f25c2511c4cd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0865321c414e513aa725f6d5cf9914eb63fe92b7",
          "sha": "0865321c414e513aa725f6d5cf9914eb63fe92b7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0865321c414e513aa725f6d5cf9914eb63fe92b7"
        }
      ],
      "message": "txgraph: Avoid per-group vectors for clusters & dependencies (optimization)\n\nInstead construct a single vector with the list of all clusters in all groups,\nand then store per-group offset/range in that list.\n\nFor dependencies, reuse m_deps_to_add, and store offset/range into that.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-26T04:23:28Z"
      },
      "sha": "4e8ffa99f1d32d5b566af0719a5afb5a89a431c2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg3MjBiMWEzODUyOTBmYzFhMjYwZmQxMGQ3NmIzYjYyY2UwMzczMzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8720b1a385290fc1a260fd10d76b3b62ce037339",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8720b1a385290fc1a260fd10d76b3b62ce037339",
      "tree": {
        "sha": "b0456478ba4b5358f389da0dc98faac477f8c6a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b0456478ba4b5358f389da0dc98faac477f8c6a4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e8ffa99f1d32d5b566af0719a5afb5a89a431c2",
          "sha": "4e8ffa99f1d32d5b566af0719a5afb5a89a431c2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4e8ffa99f1d32d5b566af0719a5afb5a89a431c2"
        }
      ],
      "message": "txgraph: Add GetChunkFeerate function (feature)\n\nThis adds a function to query the chunk feerate of a transaction, by caching it\ninside the Entry objects.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-19T20:22:25Z"
      },
      "sha": "8720b1a385290fc1a260fd10d76b3b62ce037339"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDJlNGMxMWZjYjNiNWYwMjFjZmMzNzM4NWRhZWE3NDRkZTBlNGQ4ZDY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2e4c11fcb3b5f021cfc37385daea744de0e4d8d6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2e4c11fcb3b5f021cfc37385daea744de0e4d8d6",
      "tree": {
        "sha": "ff5924e9e2663cff1eab1ec5bdfa134261d36708",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ff5924e9e2663cff1eab1ec5bdfa134261d36708"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8720b1a385290fc1a260fd10d76b3b62ce037339",
          "sha": "8720b1a385290fc1a260fd10d76b3b62ce037339",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8720b1a385290fc1a260fd10d76b3b62ce037339"
        }
      ],
      "message": "txgraph: Make max cluster count configurable and \"oversize\" state (feature)\n\nInstead of leaving the responsibility on higher layers to guarantee that\nno connected component within TxGraph (a barely exposed concept, except through\nGetCluster()) exceeds the cluster count limit, move this responsibility to\nTxGraph itself:\n* TxGraph retains a cluster count limit, but it becomes configurable at construction\n  time (this primarily helps with testing that it is properly enforced).\n* It is always allowed to perform mutators on TxGraph, even if they would cause the\n  cluster count limit to be exceeded. Instead, TxGraph exposes an IsOversized()\n  function, which queries whether it is in a special \"oversize\" state.\n* During oversize state, many inspectors are unavailable, but mutators remain valid,\n  so the higher layer can \"fix\" the oversize state before continuing.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T13:53:50Z"
      },
      "sha": "2e4c11fcb3b5f021cfc37385daea744de0e4d8d6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDFkZTNhNWU1ZWVmNDQ0YmIzNDY1ZWZlYTQyYTIwZDU1OThhYzgzOTg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1de3a5e5eef444bb3465efea42a20d5598ac8398",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1de3a5e5eef444bb3465efea42a20d5598ac8398",
      "tree": {
        "sha": "8da06983eafd1f15d46078ba84017f607275bddc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8da06983eafd1f15d46078ba84017f607275bddc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2e4c11fcb3b5f021cfc37385daea744de0e4d8d6",
          "sha": "2e4c11fcb3b5f021cfc37385daea744de0e4d8d6",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/2e4c11fcb3b5f021cfc37385daea744de0e4d8d6"
        }
      ],
      "message": "txgraph: Avoid representative lookup for each dependency (optimization)\n\nThe m_deps_to_add vector is sorted by child Cluster*, which matches the\norder of an_clusters. This means we can walk through m_deps_to_add while\ndoing the representative lookups for an_clusters, and reuse them.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-22T19:53:32Z"
      },
      "sha": "1de3a5e5eef444bb3465efea42a20d5598ac8398"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM5YzAyNTk5YWI2MGMyYTA3YTczNWQ3YjE0OWVmM2U1ZWM3MWIzMmI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9c02599ab60c2a07a735d7b149ef3e5ec71b32b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c9c02599ab60c2a07a735d7b149ef3e5ec71b32b",
      "tree": {
        "sha": "4cb2d5e127f2dae317d88d351c30a116a71fc498",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4cb2d5e127f2dae317d88d351c30a116a71fc498"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1de3a5e5eef444bb3465efea42a20d5598ac8398",
          "sha": "1de3a5e5eef444bb3465efea42a20d5598ac8398",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1de3a5e5eef444bb3465efea42a20d5598ac8398"
        }
      ],
      "message": "txgraph: Avoid looking up the same child cluster repeatedly (optimization)\n\nSince m_deps_to_add has been sorted by child Cluster* already, all dependencies\nwith the same child will be processed consecutively. Take advantage of this by\nremember the last partition merged with, and reusing that if applicable.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-22T19:36:00Z"
      },
      "sha": "c9c02599ab60c2a07a735d7b149ef3e5ec71b32b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE4MjAyMTc1M2E1NjU1M2ZjNzUxZmRjMDgyNTViNmNlYzNiOWRhNTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/182021753a56553fc751fdc08255b6cec3b9da57",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/182021753a56553fc751fdc08255b6cec3b9da57",
      "tree": {
        "sha": "cd7ed0dc0152be79f08b12b6bc18f44058df78db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cd7ed0dc0152be79f08b12b6bc18f44058df78db"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9c02599ab60c2a07a735d7b149ef3e5ec71b32b",
          "sha": "c9c02599ab60c2a07a735d7b149ef3e5ec71b32b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c9c02599ab60c2a07a735d7b149ef3e5ec71b32b"
        }
      ],
      "message": "txgraph: Delay chunking while sub-acceptable (optimization)\n\nChunk-based information (primarily, chunk feerates) are never accessed without\nfirst bringing the relevant Clusters to an \"acceptable\" quality level. Thus,\nwhile operations are ongoing and Clusters are not acceptable, we can omit\ncomputing the chunkings and chunk feerates for Clusters.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-15T18:31:23Z"
      },
      "sha": "182021753a56553fc751fdc08255b6cec3b9da57"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJhYzM1MDc2MzM3MDg5MWMzYTJiYTZiNTAyMzA0MTBkMThhYmZjMzE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bac350763370891c3a2ba6b50230410d18abfc31",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bac350763370891c3a2ba6b50230410d18abfc31",
      "tree": {
        "sha": "3d11e4c8ffc910c0dcbaf66dc4107876cc1e193e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3d11e4c8ffc910c0dcbaf66dc4107876cc1e193e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/182021753a56553fc751fdc08255b6cec3b9da57",
          "sha": "182021753a56553fc751fdc08255b6cec3b9da57",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/182021753a56553fc751fdc08255b6cec3b9da57"
        }
      ],
      "message": "txgraph: Special-case removal of tail of cluster (Optimization)\n\nWhen transactions are removed from the tail of a cluster, we know the existing\nlinearization remains acceptable (if it already was), but may just need splitting\nand postlinearization, so special case these into separate quality levels.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T23:10:24Z"
      },
      "sha": "bac350763370891c3a2ba6b50230410d18abfc31"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVjNmQ3OTc3N2Q1ZWZhYTM3OTY1ZWViNDExNWU3NDczNjQxMmZmYWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c6d79777d5efaa37965eeb4115e74736412ffae",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5c6d79777d5efaa37965eeb4115e74736412ffae",
      "tree": {
        "sha": "0160d0d17755adda35e00c49c09aaf1841944ae3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0160d0d17755adda35e00c49c09aaf1841944ae3"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bac350763370891c3a2ba6b50230410d18abfc31",
          "sha": "bac350763370891c3a2ba6b50230410d18abfc31",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bac350763370891c3a2ba6b50230410d18abfc31"
        }
      ],
      "message": "txgraph: Group per-graph data in ClusterSet (refactor)\n\nThis is a preparation for a next commit where a TxGraph will start representing\npotentially two distinct graphs (a main one, and a staging one with proposed\nchanges).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T13:37:53Z"
      },
      "sha": "5c6d79777d5efaa37965eeb4115e74736412ffae"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE4ODk0OThmYzJlYzM5ZGIwZDc2ZmUyYTc4MDViYWNiZDdlNGQ0NzY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1889498fc2ec39db0d76fe2a7805bacbd7e4d476",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/1889498fc2ec39db0d76fe2a7805bacbd7e4d476",
      "tree": {
        "sha": "823c0fdc5530f886dcadf747a4c10b66f8c10669",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/823c0fdc5530f886dcadf747a4c10b66f8c10669"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c6d79777d5efaa37965eeb4115e74736412ffae",
          "sha": "5c6d79777d5efaa37965eeb4115e74736412ffae",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5c6d79777d5efaa37965eeb4115e74736412ffae"
        }
      ],
      "message": "txgraph: Abstract out ClearLocator (refactor)\n\nMove a number of related modifications to TxGraphImpl into a separate\nfunction for removal of transactions. This is preparation for a later\ncommit where this will be useful in more than one place.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:45:52Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-24T15:00:59Z"
      },
      "sha": "1889498fc2ec39db0d76fe2a7805bacbd7e4d476"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVmMWI2MTI5NjAzOWQzYWQ5YzI1YWNhNTY5ZTYyNGYyNmM0ZmFlZTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef1b61296039d3ad9c25aca569e624f26c4faee5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ef1b61296039d3ad9c25aca569e624f26c4faee5",
      "tree": {
        "sha": "2bb635f6905f5c0f2b77e4524d844f9aedb59673",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2bb635f6905f5c0f2b77e4524d844f9aedb59673"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1889498fc2ec39db0d76fe2a7805bacbd7e4d476",
          "sha": "1889498fc2ec39db0d76fe2a7805bacbd7e4d476",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/1889498fc2ec39db0d76fe2a7805bacbd7e4d476"
        }
      ],
      "message": "txgraph: Add staging support (feature)\n\nIn order to make it easy to evaluate proposed changes to a TxGraph, introduce a\n\"staging\" mode, where mutators (AddTransaction, AddDependency, RemoveTransaction)\ndo not modify the actual graph, but just a staging version of it. That staging\ngraph can then be commited (replacing the main one with it), or aborted (discarding\nthe staging).",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:49:46Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-04T14:40:53Z"
      },
      "sha": "ef1b61296039d3ad9c25aca569e624f26c4faee5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZjMGJjNTg4ZTFmMDM1OTYzMWU1YjA4ZmQ1NmJiZjBjZjBjNWRhZmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc0bc588e1f0359631e5b08fd56bbf0cf0c5dafa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fc0bc588e1f0359631e5b08fd56bbf0cf0c5dafa",
      "tree": {
        "sha": "2c4919c918345fae500e6052be7d94f56c31440e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2c4919c918345fae500e6052be7d94f56c31440e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef1b61296039d3ad9c25aca569e624f26c4faee5",
          "sha": "ef1b61296039d3ad9c25aca569e624f26c4faee5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ef1b61296039d3ad9c25aca569e624f26c4faee5"
        }
      ],
      "message": "txgraph: Cache oversizedness of graphs (optimization)",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:49:47Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-25T05:27:52Z"
      },
      "sha": "fc0bc588e1f0359631e5b08fd56bbf0cf0c5dafa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNkNjZmMDNmODE5MTMyOTU4NjNlMjk1NTViOTlkZDljYjlmZTM0MTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d66f03f81913295863e29555b99dd9cb9fe3419",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3d66f03f81913295863e29555b99dd9cb9fe3419",
      "tree": {
        "sha": "4748b1aefa0b2bcae301d52c9a31e7a297235083",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4748b1aefa0b2bcae301d52c9a31e7a297235083"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc0bc588e1f0359631e5b08fd56bbf0cf0c5dafa",
          "sha": "fc0bc588e1f0359631e5b08fd56bbf0cf0c5dafa",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fc0bc588e1f0359631e5b08fd56bbf0cf0c5dafa"
        }
      ],
      "message": "txgraph: Destroying Ref means removing transaction (feature)\n\nBefore this commit, if a TxGraph::Ref object is destroyed, it becomes impossible\nto refer to, but the actual corresponding transaction node in the TxGraph remains,\nand remains indefinitely as there is no way to remove it.\n\nFix this by making the destruction of TxGraph::Ref trigger immediate removal of\nthe corresponding transaction in TxGraph, both in main and staging if it exists.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:51:21Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-12-03T16:25:49Z"
      },
      "sha": "3d66f03f81913295863e29555b99dd9cb9fe3419"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDhkNDRhMzEzOTU1N2NiZDcwM2IwYjM3OTVhZGRiNmQzZmZmNmEwNzk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d44a3139557cbd703b0b3795addb6d3fff6a079",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/8d44a3139557cbd703b0b3795addb6d3fff6a079",
      "tree": {
        "sha": "e2aecf257357c510466173a439acd961485b7607",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e2aecf257357c510466173a439acd961485b7607"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3d66f03f81913295863e29555b99dd9cb9fe3419",
          "sha": "3d66f03f81913295863e29555b99dd9cb9fe3419",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3d66f03f81913295863e29555b99dd9cb9fe3419"
        }
      ],
      "message": "txgraph: Allow Refs to outlive the TxGraph (feature)",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:51:22Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-21T19:17:42Z"
      },
      "sha": "8d44a3139557cbd703b0b3795addb6d3fff6a079"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGI3NDhlM2YzZjI2N2YzNjI2ZTNiOWY3NDAzMTVkMzZmYzAxNGQwYmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b748e3f3f267f3626e3b9f740315d36fc014d0bc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b748e3f3f267f3626e3b9f740315d36fc014d0bc",
      "tree": {
        "sha": "633e5461b43a68bc5ec054755b916cb47cb243d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/633e5461b43a68bc5ec054755b916cb47cb243d7"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d44a3139557cbd703b0b3795addb6d3fff6a079",
          "sha": "8d44a3139557cbd703b0b3795addb6d3fff6a079",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/8d44a3139557cbd703b0b3795addb6d3fff6a079"
        }
      ],
      "message": "txgraph: Expose ability to compare transactions (feature)\n\nIn order to make it possible for higher layers to compare transaction quality\n(ordering within the implicit total ordering on the mempool), expose a comparison\nfunction and test it.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:51:22Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2024-11-14T21:16:59Z"
      },
      "sha": "b748e3f3f267f3626e3b9f740315d36fc014d0bc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDRkMWU0OTFjODhhMWY1MzNkNDc0OTRmNmEyMWI3MTMwZDcwZTQxNGU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d1e491c88a1f533d47494f6a21b7130d70e414e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/4d1e491c88a1f533d47494f6a21b7130d70e414e",
      "tree": {
        "sha": "9c3a29f6e15f5d552cb970bbac9e858421cf751e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9c3a29f6e15f5d552cb970bbac9e858421cf751e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b748e3f3f267f3626e3b9f740315d36fc014d0bc",
          "sha": "b748e3f3f267f3626e3b9f740315d36fc014d0bc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b748e3f3f267f3626e3b9f740315d36fc014d0bc"
        }
      ],
      "message": "txgraph: Add DoWork function (feature)\n\nThis can be called when the caller has time to spend now, and wants future operations\nto be fast.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:51:22Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-09T19:22:24Z"
      },
      "sha": "4d1e491c88a1f533d47494f6a21b7130d70e414e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM3MDYzYmI4OTY1ZjEzOWVkNzkzMDI5OTU0NGYwODIxMzQwMjlhMjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7063bb8965f139ed7930299544f082134029a20",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c7063bb8965f139ed7930299544f082134029a20",
      "tree": {
        "sha": "d5f6f0431773ebd22839d052167933fa48884896",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d5f6f0431773ebd22839d052167933fa48884896"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4d1e491c88a1f533d47494f6a21b7130d70e414e",
          "sha": "4d1e491c88a1f533d47494f6a21b7130d70e414e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/4d1e491c88a1f533d47494f6a21b7130d70e414e"
        }
      ],
      "message": "txgraph: Add CountDistinctClusters function (feature)",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:51:22Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-01-16T21:00:10Z"
      },
      "sha": "c7063bb8965f139ed7930299544f082134029a20"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU2ZmFhYjZhMDhiM2Y0NzVlMGUwYjE0OGE4YmMzYjVjYjgzYmNlMzY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56faab6a08b3f475e0e0b148a8bc3b5cb83bce36",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/56faab6a08b3f475e0e0b148a8bc3b5cb83bce36",
      "tree": {
        "sha": "985cbf0e55cc56e3825425bb23548dcc2d19825b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/985cbf0e55cc56e3825425bb23548dcc2d19825b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c7063bb8965f139ed7930299544f082134029a20",
          "sha": "c7063bb8965f139ed7930299544f082134029a20",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c7063bb8965f139ed7930299544f082134029a20"
        }
      ],
      "message": "txgraph: Multiple inputs to Get{Ancestors,Descendant}Refs (preparation)\n\nThis is a preparation for the next commit, which adds a feature to request\nthe Refs to multiple ancestors/descendants at once.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:51:22Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-02-06T03:53:45Z"
      },
      "sha": "56faab6a08b3f475e0e0b148a8bc3b5cb83bce36"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQxYjQ0MzRmZWQxNjk1NzBjZTA5NzZjNmU1OGRiMGQ0YTk2MTRhYWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "tree": {
        "sha": "181323d30826e87bb2a919081d580c7b926face8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/181323d30826e87bb2a919081d580c7b926face8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56faab6a08b3f475e0e0b148a8bc3b5cb83bce36",
          "sha": "56faab6a08b3f475e0e0b148a8bc3b5cb83bce36",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/56faab6a08b3f475e0e0b148a8bc3b5cb83bce36"
        }
      ],
      "message": "txgraph: Add Get{Ancestors,Descendants}Union functions (feature)\n\nLike GetAncestors and GetDescendants, but for the union of multiple inputs.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-23T16:51:22Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2025-03-22T03:21:20Z"
      },
      "sha": "41b4434fed169570ce0976c6e58db0d4a9614aaa"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 16945223020,
      "node_id": "HRFPE_lADOABII586gNt5RzwAAAAPyA5Vs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/16945223020",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "commit_url": "https://api.github.com/repos/sipa/bitcoin/commits/41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "created_at": "2025-03-23T17:54:13Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1890424349",
      "pull_request_review_id": 2512158583,
      "id": 1890424349,
      "node_id": "PRRC_kwDOABII585wrZYd",
      "diff_hunk": "@@ -0,0 +1,1719 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster may have multiple disconnected components, which are all OPTIMAL. */\n+    NEEDS_SPLIT_OPTIMAL,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a ClusterIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(ClusterIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<const std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the feerate of a Cluster element. */\n+    void SetFeerate(TxGraphImpl& graph, ClusterIndex idx, const FeeFrac& feerate) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const ClusterIndex m_max_cluster_count;\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Which clusters are to be merged, if known. Each group is followed by a nullptr. */\n+        std::optional<std::vector<Cluster*>> m_to_merge = std::vector<Cluster*>{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+        GraphIndex m_txcount{0};\n+        /** Whether we know that merging clusters (as determined by m_to_merge) would exceed the max\n+            cluster size. */\n+        bool m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = ClusterIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == ClusterIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, or nullptr if none. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]) */\n+        FeeFrac m_main_chunk_feerate;\n+        /** The position this transaction in the main linearization (if present). /*/",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 230,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "18184f4e73404a7d41579fb408bd21f14c73668d",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n        /** The position this transaction in the main linearization (if present). **/\r\n```",
      "created_at": "2024-12-18T15:25:04Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1890424349",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1890424349"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909270566",
      "pull_request_review_id": 2529361978,
      "id": 1909270566,
      "node_id": "PRRC_kwDOABII585xzSgm",
      "diff_hunk": "@@ -84,44 +86,67 @@ class TxGraph\n      * deletion of B also either A or C is deleted, there is no distinction.\n      */\n     virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n-    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n-     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n-     *  either transaction is already removed, this is a no-op. */\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n     virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n-    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n-     *  removed), this has no effect. */\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n     virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n     /** Return a vector of pointers to Ref objects for transactions which have been removed from\n-     *  the graph, and have not been destroyed yet. This has no effect if the graph is oversized\n-     *  (see below). Each transaction is only reported once by Cleanup(). Afterwards, all Refs will\n-     *  be empty. */\n+     *  the graph, and have not been destroyed yet. This has no effect if a staging graph exists,\n+     *  or if the graph is oversized (see below). Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n     [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n \n-    /** Determine whether arg exists in this graph (i.e., was not removed). */\n-    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n     /** Determine whether the graph is oversized (contains a connected component of more than the\n-     *  configured maximum cluster count). Some of the functions below are not available\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n      *  for oversized graphs. The mutators above are always available. */\n-    virtual bool IsOversized() noexcept = 0;\n-    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n-     *  does not exist. The graph must not be oversized. */\n-    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in in the main graph. Returns the",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 68,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "972df15af28ba6787f096162f776b2973342e674",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit when retouching\r\n\r\nIn \" txgraph: (feature) add staging support\" 972df15af28ba6787f096162f776b2973342e674\r\n```suggestion\r\n    /** Get the feerate of the chunk which transaction arg is in the main graph. Returns the\r\n```",
      "created_at": "2025-01-09T18:28:30Z",
      "updated_at": "2025-01-09T18:49:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1909270566",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909270566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909271584",
      "pull_request_review_id": 2529361978,
      "id": 1909271584,
      "node_id": "PRRC_kwDOABII585xzSwg",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref (not pointing to any Entry). */\n+        Ref() noexcept = default;\n+        /** Test if this Ref is not empty. */\n+        explicit operator bool() const noexcept { return m_graph != nullptr; }\n+        /** Destroy this Ref. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeeFrac& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */\n+    virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n+    /** Return a vector of pointers to Ref objects for transactions which have been removed from\n+     *  the graph, and have not been destroyed yet. Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n+    [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n+\n+    /** Determine whether arg exists in this graph (i.e., was not removed). */\n+    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n+     *  does not exist. */\n+    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    /** Get the individual transaction feerate of transaction arg. Returns the empty FeeFrac if\n+     *  arg does not exist. */\n+    virtual FeeFrac GetIndividualFeerate(const Ref& arg) noexcept = 0;\n+    /** Get pointers to all transactions in the connected component (\"cluster\") which arg is in.\n+     *  The transactions will be returned in a topologically-valid order of acceptable quality.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 109,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "optional nit when their is need to retouch\r\n\r\nIn  \"txgraph: (feature) add initial version\" 0c8dc2323eb1ec34357a807f0860cf0a08a63a75\r\nyou mean `QualityLevel::ACCEPTABLE` right we could just reference the enum like you were doing `txgraph.cpp`?\r\n```suggestion\r\n     *  The transactions will be returned in a topologically-valid order of acceptable quality (QualityLevel::ACCEPTABLE).\r\n```",
      "created_at": "2025-01-09T18:29:33Z",
      "updated_at": "2025-01-09T18:49:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1909271584",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909271584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909277721",
      "pull_request_review_id": 2529361978,
      "id": 1909277721,
      "node_id": "PRRC_kwDOABII585xzUQZ",
      "diff_hunk": "@@ -1336,6 +1336,35 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            auto to_swap = linearization[len - 1 - (j - 1)];",
      "path": "src/cluster_linearize.h",
      "position": 472,
      "original_position": 23,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1c5f1c4601e0a895258cfe073125361f7a6ea012",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"clusterlin: add FixLinearization function + fuzz test\" 1c5f1c4601e0a895258cfe073125361f7a6ea012\r\nIs it safe to get the `ClusterIndex` when j is 0, we will subtract 1 from `uint32_t` which will result to a large positive number?",
      "created_at": "2025-01-09T18:35:26Z",
      "updated_at": "2025-01-09T18:49:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1909277721",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909277721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1372,
      "original_line": 1372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909373642",
      "pull_request_review_id": 2540832787,
      "id": 1909373642,
      "node_id": "PRRC_kwDOABII585xzrrK",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref (not pointing to any Entry). */\n+        Ref() noexcept = default;\n+        /** Test if this Ref is not empty. */\n+        explicit operator bool() const noexcept { return m_graph != nullptr; }\n+        /** Destroy this Ref. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeeFrac& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */\n+    virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n+    /** Return a vector of pointers to Ref objects for transactions which have been removed from\n+     *  the graph, and have not been destroyed yet. Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n+    [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n+\n+    /** Determine whether arg exists in this graph (i.e., was not removed). */\n+    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n+     *  does not exist. */\n+    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    /** Get the individual transaction feerate of transaction arg. Returns the empty FeeFrac if\n+     *  arg does not exist. */\n+    virtual FeeFrac GetIndividualFeerate(const Ref& arg) noexcept = 0;\n+    /** Get pointers to all transactions in the connected component (\"cluster\") which arg is in.\n+     *  The transactions will be returned in a topologically-valid order of acceptable quality.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 109,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909271584,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I consider the `QualityLevel` enum to be an implementation detail of the txgraph module that should not leak into its interface.\r\n\r\nHowever, I guess it would be helpful to specify more clearly what acceptable mean. I'll think about that; it's hard to define.",
      "created_at": "2025-01-09T20:07:21Z",
      "updated_at": "2025-01-09T20:07:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1909373642",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909373642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909379046",
      "pull_request_review_id": 2540841654,
      "id": 1909379046,
      "node_id": "PRRC_kwDOABII585xzs_m",
      "diff_hunk": "@@ -1336,6 +1336,35 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            auto to_swap = linearization[len - 1 - (j - 1)];",
      "path": "src/cluster_linearize.h",
      "position": 472,
      "original_position": 23,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1c5f1c4601e0a895258cfe073125361f7a6ea012",
      "in_reply_to_id": 1909277721,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`j` cannot be 0. If it were, there is necessarily nothing `elem` needs to be moved before anymore, and `place_before` would be empty, and the loop would have terminated.\r\n\r\nWill add an `Assume(j > 0);` on the next push.",
      "created_at": "2025-01-09T20:13:00Z",
      "updated_at": "2025-01-09T20:13:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1909379046",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909379046"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1372,
      "original_line": 1372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909471752",
      "pull_request_review_id": 2540992341,
      "id": 1909471752,
      "node_id": "PRRC_kwDOABII585x0DoI",
      "diff_hunk": "@@ -84,44 +86,67 @@ class TxGraph\n      * deletion of B also either A or C is deleted, there is no distinction.\n      */\n     virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n-    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n-     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n-     *  either transaction is already removed, this is a no-op. */\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n     virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n-    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n-     *  removed), this has no effect. */\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n     virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n     /** Return a vector of pointers to Ref objects for transactions which have been removed from\n-     *  the graph, and have not been destroyed yet. This has no effect if the graph is oversized\n-     *  (see below). Each transaction is only reported once by Cleanup(). Afterwards, all Refs will\n-     *  be empty. */\n+     *  the graph, and have not been destroyed yet. This has no effect if a staging graph exists,\n+     *  or if the graph is oversized (see below). Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n     [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n \n-    /** Determine whether arg exists in this graph (i.e., was not removed). */\n-    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n     /** Determine whether the graph is oversized (contains a connected component of more than the\n-     *  configured maximum cluster count). Some of the functions below are not available\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n      *  for oversized graphs. The mutators above are always available. */\n-    virtual bool IsOversized() noexcept = 0;\n-    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n-     *  does not exist. The graph must not be oversized. */\n-    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in in the main graph. Returns the",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 68,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "972df15af28ba6787f096162f776b2973342e674",
      "in_reply_to_id": 1909270566,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-01-09T21:49:58Z",
      "updated_at": "2025-01-09T21:49:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1909471752",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1909471752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 124,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1927111566",
      "pull_request_review_id": 2570093088,
      "id": 1927111566,
      "node_id": "PRRC_kwDOABII585y3WOO",
      "diff_hunk": "@@ -1336,6 +1336,35 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            auto to_swap = linearization[len - 1 - (j - 1)];",
      "path": "src/cluster_linearize.h",
      "position": 472,
      "original_position": 23,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1c5f1c4601e0a895258cfe073125361f7a6ea012",
      "in_reply_to_id": 1909277721,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-01-23T14:52:23Z",
      "updated_at": "2025-01-23T14:52:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1927111566",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1927111566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1372,
      "original_line": 1372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931045656",
      "pull_request_review_id": 2576309881,
      "id": 1931045656,
      "node_id": "PRRC_kwDOABII585zGWsY",
      "diff_hunk": "@@ -1118,3 +1118,58 @@ FUZZ_TARGET(clusterlin_merge)\n     auto cmp2 = CompareChunks(chunking_merged, chunking2);\n     assert(cmp2 >= 0);\n }\n+\n+FUZZ_TARGET(clusterlin_fix_linearization)\n+{\n+    // Verify expected properties of FixLinearization() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Construct an arbitrary linearization (not necessarily topological for depgraph).\n+    std::vector<ClusterIndex> linearization;\n+    /** Which transactions of depgraph are yet to be included in linearization. */\n+    TestBitSet todo = depgraph.Positions();\n+    /** Whether the linearization constructed so far is topological. */\n+    bool topological{true};\n+    /** How long the prefix of the constructed linearization is which is topological. */\n+    size_t topo_prefix = 0;\n+    while (todo.Any()) {\n+        // Figure out the index in all elements of todo to append to linearization next.\n+        uint64_t val{0};\n+        try {\n+            reader >> VARINT(val);\n+        } catch (const std::ios_base::failure&) {}\n+        val %= todo.Count();\n+        // Find which element in todo that corresponds to.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 31,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "83d61884b41b2a2be620fbe35736b433c93d4c76",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In 83d61884b41b2a2be620fbe35736b433c93d4c76\r\n\r\nI find it a bit difficult to follow this comment\r\n\r\n>     /** How long the prefix of the constructed linearization is which is topological. */\r\n??\r\n\r\n>         // Find which element in todo that corresponds to.\r\n??",
      "created_at": "2025-01-27T18:59:44Z",
      "updated_at": "2025-01-27T21:22:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1931045656",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931045656"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": 1139,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931115360",
      "pull_request_review_id": 2576309881,
      "id": 1931115360,
      "node_id": "PRRC_kwDOABII585zGntg",
      "diff_hunk": "@@ -0,0 +1,1156 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;",
      "path": "src/txgraph.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "6741590e2a4632c4f9b4655679df9694223beac4",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"txgraph: (feature) add initial version\" 6741590e2a4632c4f9b4655679df9694223beac4\r\n\r\nIn `cluster_linearize`, we have `ClusterIndex`, which is defined as the \"Data type to represent transaction indices in clusters.\" (`DepGraph` implicitly is a cluster without the linearization and the `TxGraph` context that `Cluster` class introduced in this commit has.) \r\n\r\nSince we now have a separate `Cluster` class, would it be clearer to rename `ClusterIndex` to `DepGraphIndex`? The type alias names and class names are overlapping\r\n",
      "created_at": "2025-01-27T19:58:51Z",
      "updated_at": "2025-01-27T21:22:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1931115360",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931115360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931122007",
      "pull_request_review_id": 2576309881,
      "id": 1931122007,
      "node_id": "PRRC_kwDOABII585zGpVX",
      "diff_hunk": "@@ -0,0 +1,1156 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "6741590e2a4632c4f9b4655679df9694223beac4",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"txgraph: (feature) add initial version\" 6741590e2a4632c4f9b4655679df9694223beac4\r\n\r\n\r\n```suggestion\r\n/** Quality levels for cached cluster linearizations. */\r\n```",
      "created_at": "2025-01-27T20:04:54Z",
      "updated_at": "2025-01-27T21:22:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1931122007",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931122007"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931203539",
      "pull_request_review_id": 2576309881,
      "id": 1931203539,
      "node_id": "PRRC_kwDOABII585zG9PT",
      "diff_hunk": "@@ -12,8 +12,7 @@\n #ifndef BITCOIN_TXGRAPH_H\n #define BITCOIN_TXGRAPH_H\n \n-/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n-static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};",
      "path": "src/txgraph.h",
      "position": 15,
      "original_position": 6,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "15da6fdd19813a08bf9571147f97e22b5390ecf9",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  \"txgraph: (feature) make max cluster count configurable and \"oversize\" state\" 15da6fdd19813a08bf9571147f97e22b5390ecf9\r\n\r\nMaybe comment why 64 selected and how having limit above this will hurt the node/miner? fwiw we have seen clusters with size more than 64 in the past https://bitcoincore.reviews/25038, but I think it's not a regular occurrence.",
      "created_at": "2025-01-27T21:21:42Z",
      "updated_at": "2025-01-27T21:22:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1931203539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1931203539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938029625",
      "pull_request_review_id": 2587955734,
      "id": 1938029625,
      "node_id": "PRRC_kwDOABII585zg_w5",
      "diff_hunk": "@@ -0,0 +1,1156 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 30,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "6741590e2a4632c4f9b4655679df9694223beac4",
      "in_reply_to_id": 1931122007,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-01-31T22:02:09Z",
      "updated_at": "2025-01-31T22:02:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1938029625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938029625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938031202",
      "pull_request_review_id": 2587958331,
      "id": 1938031202,
      "node_id": "PRRC_kwDOABII585zhAJi",
      "diff_hunk": "@@ -12,8 +12,7 @@\n #ifndef BITCOIN_TXGRAPH_H\n #define BITCOIN_TXGRAPH_H\n \n-/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n-static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};",
      "path": "src/txgraph.h",
      "position": 15,
      "original_position": 6,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "15da6fdd19813a08bf9571147f97e22b5390ecf9",
      "in_reply_to_id": 1931203539,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This code is unused, the current value just affects testing, but it can literally be set to any positive integer, and the code will work (though at degraded performance for higher values). The real question is what to set the `max_cluster_count` value to in `MakeTxGraph()`, but I think that discussion belongs in #28676.",
      "created_at": "2025-01-31T22:04:15Z",
      "updated_at": "2025-01-31T22:04:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1938031202",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938031202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 15,
      "original_line": 15,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938031622",
      "pull_request_review_id": 2587959004,
      "id": 1938031622,
      "node_id": "PRRC_kwDOABII585zhAQG",
      "diff_hunk": "@@ -1118,3 +1118,58 @@ FUZZ_TARGET(clusterlin_merge)\n     auto cmp2 = CompareChunks(chunking_merged, chunking2);\n     assert(cmp2 >= 0);\n }\n+\n+FUZZ_TARGET(clusterlin_fix_linearization)\n+{\n+    // Verify expected properties of FixLinearization() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Construct an arbitrary linearization (not necessarily topological for depgraph).\n+    std::vector<ClusterIndex> linearization;\n+    /** Which transactions of depgraph are yet to be included in linearization. */\n+    TestBitSet todo = depgraph.Positions();\n+    /** Whether the linearization constructed so far is topological. */\n+    bool topological{true};\n+    /** How long the prefix of the constructed linearization is which is topological. */\n+    size_t topo_prefix = 0;\n+    while (todo.Any()) {\n+        // Figure out the index in all elements of todo to append to linearization next.\n+        uint64_t val{0};\n+        try {\n+            reader >> VARINT(val);\n+        } catch (const std::ios_base::failure&) {}\n+        val %= todo.Count();\n+        // Find which element in todo that corresponds to.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 31,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "83d61884b41b2a2be620fbe35736b433c93d4c76",
      "in_reply_to_id": 1931045656,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have largely rewritten this, and expanded comments. Please have a look and let me know if it is clearer now.",
      "created_at": "2025-01-31T22:04:51Z",
      "updated_at": "2025-01-31T22:04:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1938031622",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938031622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": 1139,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938031732",
      "pull_request_review_id": 2587959172,
      "id": 1938031732,
      "node_id": "PRRC_kwDOABII585zhAR0",
      "diff_hunk": "@@ -0,0 +1,1156 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;",
      "path": "src/txgraph.cpp",
      "position": 32,
      "original_position": 28,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "6741590e2a4632c4f9b4655679df9694223beac4",
      "in_reply_to_id": 1931115360,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-01-31T22:04:57Z",
      "updated_at": "2025-01-31T22:04:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1938031732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1938031732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 32,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1941918671",
      "pull_request_review_id": 2593986518,
      "id": 1941918671,
      "node_id": "PRRC_kwDOABII585zv1PP",
      "diff_hunk": "@@ -0,0 +1,1928 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster may have multiple disconnected components, which are all OPTIMAL. */\n+    NEEDS_SPLIT_OPTIMAL,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]) */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction in the main linearization (if present). /*/\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified maximum cluster count. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count) noexcept :\n+        m_max_cluster_count(max_cluster_count)\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+        m_clustersets.reserve(MAX_LEVELS);\n+        m_clustersets.emplace_back();\n+    }\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly or implicitly), return the\n+     *  Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist at a specified level. */\n+    void ClearLocator(int level, GraphIndex index) noexcept;\n+    /** Find which Clusters conflict with the top level. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 313,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "68435c7a4f1e66583cf98bc4cce51325be5cd00d",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"txgraph: (feature) add initial version\" c89d147209c91bb0464321f5bc733a4eeab0dea0\r\n\r\nIt is also called by the move assignment operator of `Ref`",
      "created_at": "2025-02-04T21:27:01Z",
      "updated_at": "2025-02-10T22:02:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1941918671",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1941918671"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 315,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943139699",
      "pull_request_review_id": 2593986518,
      "id": 1943139699,
      "node_id": "PRRC_kwDOABII585z0fVz",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 547,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"txgraph: (feature) add initial version\" c89d147209c91bb0464321f5bc733a4eeab0dea0\r\n\r\nWe can check whether `m_to_remove` is empty first so we don't have to copy the reference when it is, the copied reference is also only used in this if statement, so we can just use the `m_to_remove` value",
      "created_at": "2025-02-05T15:12:24Z",
      "updated_at": "2025-02-10T22:02:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943139699",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943139699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 547,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943163414",
      "pull_request_review_id": 2512158583,
      "id": 1943163414,
      "node_id": "PRRC_kwDOABII585z0lIW",
      "diff_hunk": "@@ -1336,6 +1336,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 9,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1fb067066eb37452442535d4a75fe2ce9fc05b21",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    // until it is placed after all its ancestors.\r\n```",
      "created_at": "2025-02-05T15:20:11Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943163414",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943163414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1355,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943179984",
      "pull_request_review_id": 2512158583,
      "id": 1943179984,
      "node_id": "PRRC_kwDOABII585z0pLQ",
      "diff_hunk": "@@ -1336,6 +1336,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 18,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1fb067066eb37452442535d4a75fe2ce9fc05b21",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        // Figure out which elements elem needs to be placed after.\r\n```\r\nwe are putting the *other* elements \"before\"",
      "created_at": "2025-02-05T15:29:09Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943179984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943179984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1364,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943200510",
      "pull_request_review_id": 2512158583,
      "id": 1943200510,
      "node_id": "PRRC_kwDOABII585z0uL-",
      "diff_hunk": "@@ -1336,6 +1336,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            // j cannot be 0 here; if it was, then there was necessarily nothing earlier which\n+            // elem needs to be place before anymore, and place_before would be empty.\n+            Assume(j > 0);",
      "path": "src/cluster_linearize.h",
      "position": 471,
      "original_position": 25,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1fb067066eb37452442535d4a75fe2ce9fc05b21",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "in release builds this will result in `j--` wrapping around to max value of uint32_t, causing an OOB access? We should probably just stop trying to fix things if it happens?",
      "created_at": "2025-02-05T15:40:33Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943200510",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943200510"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1371,
      "original_line": 1371,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943228435",
      "pull_request_review_id": 2512158583,
      "id": 1943228435,
      "node_id": "PRRC_kwDOABII585z01AT",
      "diff_hunk": "@@ -407,7 +407,7 @@ FUZZ_TARGET(clusterlin_depgraph_serialization)\n     SanityCheck(depgraph);\n \n     // Verify the graph is a DAG.\n-    assert(IsAcyclic(depgraph));",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 131,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "a921ae75c2f7162b3b617ddeccb84e3e60728cf8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "a921ae75c2f7162b3b617ddeccb84e3e60728cf8\r\n\r\nShould we add a test that completes a cycle then asserts it's not acyclic to add coverage that way?",
      "created_at": "2025-02-05T15:56:04Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943228435",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943228435"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 410,
      "original_line": 410,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943239737",
      "pull_request_review_id": 2512158583,
      "id": 1943239737,
      "node_id": "PRRC_kwDOABII585z03w5",
      "diff_hunk": "@@ -280,6 +280,7 @@ add_library(bitcoin_node STATIC EXCLUDE_FROM_ALL\n   signet.cpp\n   torcontrol.cpp\n   txdb.cpp\n+  txgraph.cpp",
      "path": "src/CMakeLists.txt",
      "position": 4,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c89d147209c91bb0464321f5bc733a4eeab0dea0 in commit message:\r\n\"... and so for.\" and so on?",
      "created_at": "2025-02-05T16:02:27Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943239737",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943239737"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 304,
      "original_line": 304,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943247961",
      "pull_request_review_id": 2512158583,
      "id": 1943247961,
      "node_id": "PRRC_kwDOABII585z05xZ",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 45,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> This is only allowed when it is empty \r\n\r\nQuestion: how is this enforced?",
      "created_at": "2025-02-05T16:07:25Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943247961",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943247961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943260292",
      "pull_request_review_id": 2512158583,
      "id": 1943260292,
      "node_id": "PRRC_kwDOABII585z08yE",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 84,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "comment clarity: \"it has no effect\" meaning the dependency addition?",
      "created_at": "2025-02-05T16:14:41Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943260292",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943260292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943275366",
      "pull_request_review_id": 2512158583,
      "id": 1943275366,
      "node_id": "PRRC_kwDOABII585z1Adm",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref (not pointing to any Entry). */\n+        Ref() noexcept = default;\n+        /** Test if this Ref is not empty. */\n+        explicit operator bool() const noexcept { return m_graph != nullptr; }\n+        /** Destroy this Ref. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeeFrac& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */\n+    virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n+    /** Return a vector of pointers to Ref objects for transactions which have been removed from\n+     *  the graph, and have not been destroyed yet. Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n+    [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n+\n+    /** Determine whether arg exists in this graph (i.e., was not removed). */\n+    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n+     *  does not exist. */\n+    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    /** Get the individual transaction feerate of transaction arg. Returns the empty FeeFrac if\n+     *  arg does not exist. */\n+    virtual FeeFrac GetIndividualFeerate(const Ref& arg) noexcept = 0;\n+    /** Get pointers to all transactions in the connected component (\"cluster\") which arg is in.\n+     *  The transactions will be returned in a topologically-valid order of acceptable quality.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 109,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909271584,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm unsure the \"Acceptable\" word helps much here. It's just whatever quality it is, at least topologically valid. ",
      "created_at": "2025-02-05T16:23:42Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943275366",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943275366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943333169",
      "pull_request_review_id": 2512158583,
      "id": 1943333169,
      "node_id": "PRRC_kwDOABII585z1Okx",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c89d147209c91bb0464321f5bc733a4eeab0dea0\r\n\r\nwhat does implicit mean here?",
      "created_at": "2025-02-05T16:59:38Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943333169",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943333169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943352763",
      "pull_request_review_id": 2512158583,
      "id": 1943352763,
      "node_id": "PRRC_kwDOABII585z1TW7",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 182,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c89d147209c91bb0464321f5bc733a4eeab0dea0\r\n\r\ncould mention nullptr -> \"unlinked\"",
      "created_at": "2025-02-05T17:12:51Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1943352763",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1943352763"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945144668",
      "pull_request_review_id": 2512158583,
      "id": 1945144668,
      "node_id": "PRRC_kwDOABII585z8I1c",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "781c15bfca1ebaffe7b634196e19144f5ab10a50\r\n\r\nWasn't immediately clear what the expected behavior is based on the comment. It will apply and pop off the entries where the prefix of `to_remove` is all owned by the cluster itself?\r\n\r\n",
      "created_at": "2025-02-06T17:25:19Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945144668",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945144668"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945148422",
      "pull_request_review_id": 2512158583,
      "id": 1945148422,
      "node_id": "PRRC_kwDOABII585z8JwG",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());",
      "path": "src/txgraph.cpp",
      "position": 596,
      "original_position": 306,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "UB if this `Assume()` is wrong, should we `Assert()` or more gracefully handle it?",
      "created_at": "2025-02-06T17:27:57Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945148422",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945148422"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 596,
      "original_line": 596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945149772",
      "pull_request_review_id": 2512158583,
      "id": 1945149772,
      "node_id": "PRRC_kwDOABII585z8KFM",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();",
      "path": "src/txgraph.cpp",
      "position": 599,
      "original_position": 309,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        GraphIndex idx = to_remove.front();\r\n        if (!Assume(graph.m_entries.size() > idx)) break;\r\n```",
      "created_at": "2025-02-06T17:28:53Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945149772",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945149772"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 599,
      "original_line": 599,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945156500",
      "pull_request_review_id": 2512158583,
      "id": 1945156500,
      "node_id": "PRRC_kwDOABII585z8LuU",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should probably say what value `-1` means",
      "created_at": "2025-02-06T17:33:58Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945156500",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945156500"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945163261",
      "pull_request_review_id": 2512158583,
      "id": 1945163261,
      "node_id": "PRRC_kwDOABII585z8NX9",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`m_mapping` is a vector, I presume this is `m_depgraph` instead?",
      "created_at": "2025-02-06T17:39:18Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945163261",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945163261"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945374176",
      "pull_request_review_id": 2512158583,
      "id": 1945374176,
      "node_id": "PRRC_kwDOABII585z9A3g",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {",
      "path": "src/txgraph.cpp",
      "position": 702,
      "original_position": 354,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "might help reader instantly recognize what `todo` means in this case\r\n```Suggestion\r\n        if (first && component == todo) {\r\n            Assume(todo == m_depgraph.Positions());\r\n```",
      "created_at": "2025-02-06T20:23:49Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945374176",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945374176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 702,
      "original_line": 702,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945422363",
      "pull_request_review_id": 2512158583,
      "id": 1945422363,
      "node_id": "PRRC_kwDOABII585z9Mob",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 365,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        // Remember that all the component's transactions go to this new Cluster. The positions\r\n```",
      "created_at": "2025-02-06T20:54:22Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945422363",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945422363"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 637,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945470973",
      "pull_request_review_id": 2512158583,
      "id": 1945470973,
      "node_id": "PRRC_kwDOABII585z9Yf9",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);",
      "path": "src/txgraph.cpp",
      "position": 776,
      "original_position": 424,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "note: `remap` here is already filled out from a topological pov since we're iterating over `other.m_linearization` which is assumed to be topologically valid",
      "created_at": "2025-02-06T21:19:37Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945470973",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945470973"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 776,
      "original_line": 776,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945495189",
      "pull_request_review_id": 2512158583,
      "id": 1945495189,
      "node_id": "PRRC_kwDOABII585z9eaV",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);",
      "path": "src/txgraph.cpp",
      "position": 798,
      "original_position": 446,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "781c15bfca1ebaffe7b634196e19144f5ab10a50\r\n\r\nnote: I'm not sure this obvious that PostLinearize obtains this property.",
      "created_at": "2025-02-06T21:33:07Z",
      "updated_at": "2025-02-12T16:22:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945495189",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945495189"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 798,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945502896",
      "pull_request_review_id": 2512158583,
      "id": 1945502896,
      "node_id": "PRRC_kwDOABII585z9gSw",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 95,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Cluster (or be removed)\r\n\r\nnot sure I get this comment, be removed what?",
      "created_at": "2025-02-06T21:40:33Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945502896",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945502896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945504644",
      "pull_request_review_id": 2512158583,
      "id": 1945504644,
      "node_id": "PRRC_kwDOABII585z9guE",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 454,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "const this?",
      "created_at": "2025-02-06T21:42:13Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945504644",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945504644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 726,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945525747",
      "pull_request_review_id": 2512158583,
      "id": 1945525747,
      "node_id": "PRRC_kwDOABII585z9l3z",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 497,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "781c15bfca1ebaffe7b634196e19144f5ab10a50\r\n\r\nthe cluster is from the same quality level, so this is kind of a no-op?",
      "created_at": "2025-02-06T21:50:55Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945525747",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945525747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 772,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945553960",
      "pull_request_review_id": 2512158583,
      "id": 1945553960,
      "node_id": "PRRC_kwDOABII585z9swo",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 561,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "when does this happen?",
      "created_at": "2025-02-06T22:18:57Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1945553960",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1945553960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 561,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949828517",
      "pull_request_review_id": 2593986518,
      "id": 1949828517,
      "node_id": "PRRC_kwDOABII5850OAWl",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);",
      "path": "src/txgraph.cpp",
      "position": 708,
      "original_position": 358,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IIUC we call `ApplyRemoval` on each cluster before splitting, which calls `updated` with the graph at the end. so it seems to me that this call to `updated` before returning here is redundant and repeats work that has already been done?\r\n\r\nI also think even if the above assumption is incorrect and an update is necessary, then since the cluster quality is now `NEEDS_RELINEARIZE`, we only need to update the locator. ",
      "created_at": "2025-02-10T20:23:48Z",
      "updated_at": "2025-02-10T22:07:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1949828517",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949828517"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 708,
      "original_line": 708,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949870180",
      "pull_request_review_id": 2593986518,
      "id": 1949870180,
      "node_id": "PRRC_kwDOABII5850OKhk",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 83,
      "original_position": 87,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IIUC you are recommending that callers should remove transactions topologically starting from bottom descendant to the top ancestor.",
      "created_at": "2025-02-10T20:50:49Z",
      "updated_at": "2025-02-10T22:02:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1949870180",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949870180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 83,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949874121",
      "pull_request_review_id": 2593986518,
      "id": 1949874121,
      "node_id": "PRRC_kwDOABII5850OLfJ",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);",
      "path": "src/txgraph.cpp",
      "position": 746,
      "original_position": 396,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Don't we just need to update the locator here, because all `NEEDS_RELINEARIZE` clusters has to be made acceptable before we can get their chunk feerate?",
      "created_at": "2025-02-10T20:54:06Z",
      "updated_at": "2025-02-10T22:02:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1949874121",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949874121"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 746,
      "original_line": 746,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949967974",
      "pull_request_review_id": 2607290939,
      "id": 1949967974,
      "node_id": "PRRC_kwDOABII5850OiZm",
      "diff_hunk": "@@ -1118,3 +1118,58 @@ FUZZ_TARGET(clusterlin_merge)\n     auto cmp2 = CompareChunks(chunking_merged, chunking2);\n     assert(cmp2 >= 0);\n }\n+\n+FUZZ_TARGET(clusterlin_fix_linearization)\n+{\n+    // Verify expected properties of FixLinearization() on arbitrary linearizations.\n+\n+    // Retrieve a depgraph from the fuzz input.\n+    SpanReader reader(buffer);\n+    DepGraph<TestBitSet> depgraph;\n+    try {\n+        reader >> Using<DepGraphFormatter>(depgraph);\n+    } catch (const std::ios_base::failure&) {}\n+\n+    // Construct an arbitrary linearization (not necessarily topological for depgraph).\n+    std::vector<ClusterIndex> linearization;\n+    /** Which transactions of depgraph are yet to be included in linearization. */\n+    TestBitSet todo = depgraph.Positions();\n+    /** Whether the linearization constructed so far is topological. */\n+    bool topological{true};\n+    /** How long the prefix of the constructed linearization is which is topological. */\n+    size_t topo_prefix = 0;\n+    while (todo.Any()) {\n+        // Figure out the index in all elements of todo to append to linearization next.\n+        uint64_t val{0};\n+        try {\n+            reader >> VARINT(val);\n+        } catch (const std::ios_base::failure&) {}\n+        val %= todo.Count();\n+        // Find which element in todo that corresponds to.",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": null,
      "original_position": 31,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "83d61884b41b2a2be620fbe35736b433c93d4c76",
      "in_reply_to_id": 1931045656,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes this is much better now!\r\nThanks",
      "created_at": "2025-02-10T22:08:10Z",
      "updated_at": "2025-02-10T22:08:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1949967974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1949967974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": 1139,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951014516",
      "pull_request_review_id": 2512158583,
      "id": 1951014516,
      "node_id": "PRRC_kwDOABII5850Sh50",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 599,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "781c15bfca1ebaffe7b634196e19144f5ab10a50\r\n\r\n```Suggestion\r\n    // later-processed ones during the \"swap with end of m_entries\" step below (which might invalidate\r\n```\r\n\r\n",
      "created_at": "2025-02-11T14:59:10Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951014516",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951014516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 928,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951083840",
      "pull_request_review_id": 2512158583,
      "id": 1951083840,
      "node_id": "PRRC_kwDOABII5850Sy1A",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 659,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`m_deps_to_add`?",
      "created_at": "2025-02-11T15:37:10Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951083840",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951083840"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 998,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951108357",
      "pull_request_review_id": 2512158583,
      "id": 1951108357,
      "node_id": "PRRC_kwDOABII5850S40F",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        const auto& loc = m_entries[group_data.m_deps[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, group_data.m_deps);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data = std::vector<GroupEntry>{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Ancestors(idx).Count());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Descendants(idx).Count());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1010,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Probably worth noting in these comment and elsewhere that it also applies removals if queued.",
      "created_at": "2025-02-11T15:50:31Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951108357",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951108357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1451,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951123494",
      "pull_request_review_id": 2512158583,
      "id": 1951123494,
      "node_id": "PRRC_kwDOABII5850S8gm",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 93,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should say the Ref if non-null should be connected to this TxGraph object",
      "created_at": "2025-02-11T15:58:34Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951123494",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951123494"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951125073",
      "pull_request_review_id": 2512158583,
      "id": 1951125073,
      "node_id": "PRRC_kwDOABII5850S85R",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        const auto& loc = m_entries[group_data.m_deps[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, group_data.m_deps);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data = std::vector<GroupEntry>{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Ancestors(idx).Count());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Descendants(idx).Count());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified DepGraphIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n+{\n+    // Don't do anything if the passed Ref is empty.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);",
      "path": "src/txgraph.cpp",
      "position": 1835,
      "original_position": 1104,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    if (!Assume(GetRefGraph(ref) == this)) return;\r\n```",
      "created_at": "2025-02-11T15:59:29Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951125073",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951125073"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1835,
      "original_line": 1835,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951134887",
      "pull_request_review_id": 2512158583,
      "id": 1951134887,
      "node_id": "PRRC_kwDOABII5850S_Sn",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        const auto& loc = m_entries[group_data.m_deps[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, group_data.m_deps);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data = std::vector<GroupEntry>{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Ancestors(idx).Count());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Descendants(idx).Count());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);",
      "path": "src/txgraph.cpp",
      "position": 1702,
      "original_position": 1072,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    if (!Assume(GetRefGraph(arg) == this)) return {};\r\n```\r\nand so on for the public functions?",
      "created_at": "2025-02-11T16:04:40Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951134887",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951134887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1702,
      "original_line": 1702,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951175625",
      "pull_request_review_id": 2512158583,
      "id": 1951175625,
      "node_id": "PRRC_kwDOABII5850TJPJ",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */",
      "path": "src/txgraph.h",
      "position": 47,
      "original_position": 22,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    /** Internal identifier for a transaction within a TxGraph corresponding to m_entries order. */\r\n```",
      "created_at": "2025-02-11T16:26:38Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951175625",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951175625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951190764",
      "pull_request_review_id": 2512158583,
      "id": 1951190764,
      "node_id": "PRRC_kwDOABII5850TM7s",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 846,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this was just assumed a few lines above\r\n\r\nedit: in ee4d16ff3a32a0b12a7c1b7837ef5195d9deedf0 the other one is gone, but we're accessing it two lines above ",
      "created_at": "2025-02-11T16:35:59Z",
      "updated_at": "2025-02-12T21:01:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951190764",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951190764"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 846,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951202254",
      "pull_request_review_id": 2512158583,
      "id": 1951202254,
      "node_id": "PRRC_kwDOABII5850TPvO",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        /** Which dependencies are to be applied to those merged clusters from parent to child. */\r\n```",
      "created_at": "2025-02-11T16:40:56Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951202254",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951202254"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951205931",
      "pull_request_review_id": 2512158583,
      "id": 1951205931,
      "node_id": "PRRC_kwDOABII5850TQor",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 850,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        // Actually apply all to-be-added dependencies (all parents and children from this grouping belong to the\r\n```\r\n",
      "created_at": "2025-02-11T16:42:40Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951205931",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951205931"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951249320",
      "pull_request_review_id": 2512158583,
      "id": 1951249320,
      "node_id": "PRRC_kwDOABII5850TbOo",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.",
      "path": "src/txgraph.cpp",
      "position": 1097,
      "original_position": 668,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "this would be the case where a removal and a dependency addition was queued for the same ref?",
      "created_at": "2025-02-11T17:07:42Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951249320",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951249320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1097,
      "original_line": 1097,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951563218",
      "pull_request_review_id": 2609979537,
      "id": 1951563218,
      "node_id": "PRRC_kwDOABII5850Un3S",
      "diff_hunk": "@@ -0,0 +1,1928 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster may have multiple disconnected components, which are all OPTIMAL. */\n+    NEEDS_SPLIT_OPTIMAL,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]) */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction in the main linearization (if present). /*/\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified maximum cluster count. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count) noexcept :\n+        m_max_cluster_count(max_cluster_count)\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+        m_clustersets.reserve(MAX_LEVELS);\n+        m_clustersets.emplace_back();\n+    }\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly or implicitly), return the\n+     *  Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist at a specified level. */\n+    void ClearLocator(int level, GraphIndex index) noexcept;\n+    /** Find which Clusters conflict with the top level. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 313,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "68435c7a4f1e66583cf98bc4cce51325be5cd00d",
      "in_reply_to_id": 1941918671,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-02-11T20:33:46Z",
      "updated_at": "2025-02-11T20:33:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951563218",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951563218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 315,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951565256",
      "pull_request_review_id": 2609982754,
      "id": 1951565256,
      "node_id": "PRRC_kwDOABII5850UoXI",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 547,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943139699,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Creating a reference doesn't cost anything (in simple cases); it's just introducing a new name for an existing object. It's true that it's kind of pointless at this stage, but it'll be used in \"group per-graph data in ClusterSet\", and in \"add staging support\".",
      "created_at": "2025-02-11T20:35:13Z",
      "updated_at": "2025-02-11T20:35:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951565256",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951565256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 547,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951571563",
      "pull_request_review_id": 2609993163,
      "id": 1951571563,
      "node_id": "PRRC_kwDOABII5850Up5r",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);",
      "path": "src/txgraph.cpp",
      "position": 708,
      "original_position": 358,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1949828517,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You're right, but that's exactly what the \"delay chunking while sub-acceptable\" commit is about. In the initial commit, the invariant is that the chunk feerates are maintained at all times (and the sanity check will fail if not). In this \"delay chunking while sub-acceptable\" commit, some updates are avoided while they are unnecessary. The commit after it (\"special-case removal of tail of cluster\") reintroduces some, because with that, performing a Split() can in fact immediately introduce optimal clusters directly.",
      "created_at": "2025-02-11T20:40:35Z",
      "updated_at": "2025-02-11T20:40:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951571563",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951571563"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 708,
      "original_line": 708,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951573976",
      "pull_request_review_id": 2609997047,
      "id": 1951573976,
      "node_id": "PRRC_kwDOABII5850UqfY",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 83,
      "original_position": 87,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1949870180,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No, the order of removals is irrelevant. The comment is just about pointing out that while TxGraph is allowed to reorder dependency additions and transaction removals w.r.t. each other, this doesn't matter in practice. As long as every transaction removal is combined (doesn't matter when) with also removal of all its ancestors, or with all its descendants, this reordering does not affect its observable behavior.",
      "created_at": "2025-02-11T20:42:24Z",
      "updated_at": "2025-02-11T20:42:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951573976",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951573976"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 83,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951574878",
      "pull_request_review_id": 2609998560,
      "id": 1951574878,
      "node_id": "PRRC_kwDOABII5850Uqte",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);",
      "path": "src/txgraph.cpp",
      "position": 746,
      "original_position": 396,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1949874121,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Same comment as before: in the initial commit, the invariant is that the chunk feerates are maintained at all times. It is relaxed later on.",
      "created_at": "2025-02-11T20:43:08Z",
      "updated_at": "2025-02-11T20:43:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951574878",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951574878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 746,
      "original_line": 746,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951627940",
      "pull_request_review_id": 2512158583,
      "id": 1951627940,
      "node_id": "PRRC_kwDOABII5850U3qk",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;",
      "path": "src/txgraph.cpp",
      "position": 1133,
      "original_position": 695,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0eacbd61cb8d00163bc00b9fe3d94899e283c065",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "we doing just `unsigned` for a reason? I don't see this in the codebase often ",
      "created_at": "2025-02-11T21:24:04Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951627940",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951627940"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1133,
      "original_line": 1133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951633305",
      "pull_request_review_id": 2512158583,
      "id": 1951633305,
      "node_id": "PRRC_kwDOABII5850U4-Z",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 710,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0eacbd61cb8d00163bc00b9fe3d94899e283c065",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "s/find_uf/find_root_uf/ ?\r\n\r\n`find_uf` and `locate_uf` read identical",
      "created_at": "2025-02-11T21:28:17Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951633305",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951633305"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951651150",
      "pull_request_review_id": 2512158583,
      "id": 1951651150,
      "node_id": "PRRC_kwDOABII5850U9VO",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;",
      "path": "src/txgraph.cpp",
      "position": 1217,
      "original_position": 764,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0eacbd61cb8d00163bc00b9fe3d94899e283c065",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n            Assume(an_clusters[i].second == nullptr);\r\n            an_clusters[i].second = rep;\r\n```\r\n",
      "created_at": "2025-02-11T21:43:12Z",
      "updated_at": "2025-02-12T16:22:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1951651150",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1951651150"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1217,
      "original_line": 1217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953022822",
      "pull_request_review_id": 2612555689,
      "id": 1953022822,
      "node_id": "PRRC_kwDOABII5850aMNm",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  \"txgraph: (tests) add simulation fuzz test\" 1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b\r\n\r\nusing real in the comments here is a bit confusing as you represent the actual tx graph as real",
      "created_at": "2025-02-12T16:34:09Z",
      "updated_at": "2025-02-12T21:15:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953022822",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953022822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953038482",
      "pull_request_review_id": 2612580796,
      "id": 1953038482,
      "node_id": "PRRC_kwDOABII5850aQCS",
      "diff_hunk": "@@ -311,7 +311,7 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         auto& locator = entry.m_locator;\n         // Stop once we hit an entry that applies to another Cluster.\n         if (locator.cluster != this) break;\n-        // - Remember it in a set of to-remove ClusterIndexes.\n+        // - Remember it in a set of to-remove DepGraphIndexes.",
      "path": "src/txgraph.cpp",
      "position": 605,
      "original_position": 5,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "micro-nit: seems this should have been renamed in a different commit 1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "created_at": "2025-02-12T16:43:57Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953038482",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953038482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 605,
      "original_line": 605,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953051233",
      "pull_request_review_id": 2612580796,
      "id": 1953051233,
      "node_id": "PRRC_kwDOABII5850aTJh",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> sim real\r\n\r\nfeel like we're missing a punctuation or I'm unclear what it's saying",
      "created_at": "2025-02-12T16:51:54Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953051233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953051233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953086802",
      "pull_request_review_id": 2612580796,
      "id": 1953086802,
      "node_id": "PRRC_kwDOABII5850ab1S",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b\r\n\r\n> Cleanup\r\n\r\nprobably an old reference?",
      "created_at": "2025-02-12T17:14:23Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953086802",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953086802"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953094059",
      "pull_request_review_id": 2612580796,
      "id": 1953094059,
      "node_id": "PRRC_kwDOABII5850admr",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 306,
      "original_position": 215,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "to be clear this is to allow the search space to be split in a bimodal way?",
      "created_at": "2025-02-12T17:19:01Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953094059",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953094059"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 306,
      "original_line": 306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953110215",
      "pull_request_review_id": 2612580796,
      "id": 1953110215,
      "node_id": "PRRC_kwDOABII5850ahjH",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {\n+                    fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                } else {\n+                    fee = provider.ConsumeIntegral<uint8_t>();\n+                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                }\n+                FeePerWeight feerate{fee, size};\n+                // Create a real TxGraph::Ref.\n+                auto ref = real->AddTransaction(feerate);\n+                // Create a unique_ptr place in the simulation to put the Ref in.\n+                auto ref_loc = sim.AddTransaction(feerate);\n+                // Move it in place.\n+                *ref_loc = std::move(ref);\n+                break;\n+            } else if (sim.GetTransactionCount() + sim.removed.size() > 1 && command-- == 0) {\n+                // AddDependency.\n+                auto par = pick_fn();\n+                auto chl = pick_fn();\n+                auto pos_par = sim.Find(par);\n+                auto pos_chl = sim.Find(chl);\n+                if (pos_par != SimTxGraph::MISSING && pos_chl != SimTxGraph::MISSING) {\n+                    // Determine if adding this would introduce a cycle (not allowed by TxGraph),\n+                    // and if so, skip.\n+                    if (sim.graph.Ancestors(pos_par)[pos_chl]) break;\n+                    // Determine if adding this would violate CLUSTER_COUNT_LIMIT, and if so, skip.\n+                    auto temp_depgraph = sim.graph;\n+                    temp_depgraph.AddDependencies(SimTxGraph::SetType::Singleton(pos_par), pos_chl);\n+                    auto todo = temp_depgraph.Positions();\n+                    bool oversize{false};\n+                    while (todo.Any()) {\n+                        auto component = temp_depgraph.FindConnectedComponent(todo);\n+                        if (component.Count() > CLUSTER_COUNT_LIMIT) oversize = true;\n+                        todo -= component;\n+                    }\n+                    if (oversize) break;\n+                }\n+                sim.AddDependency(par, chl);\n+                real->AddDependency(*par, *chl);\n+                break;\n+            } else if (sim.removed.size() < 100 && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 255,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> sim.removed.size() < 100\r\n\r\nIs this because the loop does 200 commands, and we logically speaking cannot remove more than 100 after 100 additions?",
      "created_at": "2025-02-12T17:29:48Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953110215",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953110215"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 255,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953122407",
      "pull_request_review_id": 2612580796,
      "id": 1953122407,
      "node_id": "PRRC_kwDOABII5850akhn",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {\n+                    fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                } else {\n+                    fee = provider.ConsumeIntegral<uint8_t>();\n+                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                }\n+                FeePerWeight feerate{fee, size};\n+                // Create a real TxGraph::Ref.\n+                auto ref = real->AddTransaction(feerate);\n+                // Create a unique_ptr place in the simulation to put the Ref in.\n+                auto ref_loc = sim.AddTransaction(feerate);\n+                // Move it in place.\n+                *ref_loc = std::move(ref);\n+                break;\n+            } else if (sim.GetTransactionCount() + sim.removed.size() > 1 && command-- == 0) {\n+                // AddDependency.\n+                auto par = pick_fn();\n+                auto chl = pick_fn();\n+                auto pos_par = sim.Find(par);\n+                auto pos_chl = sim.Find(chl);\n+                if (pos_par != SimTxGraph::MISSING && pos_chl != SimTxGraph::MISSING) {\n+                    // Determine if adding this would introduce a cycle (not allowed by TxGraph),\n+                    // and if so, skip.\n+                    if (sim.graph.Ancestors(pos_par)[pos_chl]) break;\n+                    // Determine if adding this would violate CLUSTER_COUNT_LIMIT, and if so, skip.\n+                    auto temp_depgraph = sim.graph;\n+                    temp_depgraph.AddDependencies(SimTxGraph::SetType::Singleton(pos_par), pos_chl);\n+                    auto todo = temp_depgraph.Positions();\n+                    bool oversize{false};\n+                    while (todo.Any()) {\n+                        auto component = temp_depgraph.FindConnectedComponent(todo);\n+                        if (component.Count() > CLUSTER_COUNT_LIMIT) oversize = true;\n+                        todo -= component;\n+                    }\n+                    if (oversize) break;\n+                }\n+                sim.AddDependency(par, chl);\n+                real->AddDependency(*par, *chl);\n+                break;\n+            } else if (sim.removed.size() < 100 && command-- == 0) {\n+                // RemoveTransaction. Either all its ancestors or all its descendants are also\n+                // removed (if any), to make sure TxGraph's reordering of removals and dependencies\n+                // has no effect.\n+                std::vector<TxGraph::Ref*> to_remove;\n+                to_remove.push_back(pick_fn());\n+                sim.IncludeAncDesc(to_remove, alt);\n+                // The order in which these ancestors/descendants are removed should not matter;\n+                // randomly shuffle them.\n+                std::shuffle(to_remove.begin(), to_remove.end(), rng);\n+                for (TxGraph::Ref* ptr : to_remove) {\n+                    real->RemoveTransaction(*ptr);\n+                    sim.RemoveTransaction(ptr);\n+                }\n+                break;\n+            } else if (sim.removed.size() > 0 && command-- == 0) {\n+                // ~Ref",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b\r\n\r\nthis is the odd command out; what precisely is this simulating, or is this just making sure destruction of the Ref is being exercised in general?",
      "created_at": "2025-02-12T17:35:37Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953122407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953122407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953123706",
      "pull_request_review_id": 2612580796,
      "id": 1953123706,
      "node_id": "PRRC_kwDOABII5850ak16",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {\n+                    fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                } else {\n+                    fee = provider.ConsumeIntegral<uint8_t>();\n+                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                }\n+                FeePerWeight feerate{fee, size};\n+                // Create a real TxGraph::Ref.\n+                auto ref = real->AddTransaction(feerate);\n+                // Create a unique_ptr place in the simulation to put the Ref in.\n+                auto ref_loc = sim.AddTransaction(feerate);\n+                // Move it in place.\n+                *ref_loc = std::move(ref);\n+                break;\n+            } else if (sim.GetTransactionCount() + sim.removed.size() > 1 && command-- == 0) {\n+                // AddDependency.\n+                auto par = pick_fn();\n+                auto chl = pick_fn();\n+                auto pos_par = sim.Find(par);\n+                auto pos_chl = sim.Find(chl);\n+                if (pos_par != SimTxGraph::MISSING && pos_chl != SimTxGraph::MISSING) {\n+                    // Determine if adding this would introduce a cycle (not allowed by TxGraph),\n+                    // and if so, skip.\n+                    if (sim.graph.Ancestors(pos_par)[pos_chl]) break;\n+                    // Determine if adding this would violate CLUSTER_COUNT_LIMIT, and if so, skip.\n+                    auto temp_depgraph = sim.graph;\n+                    temp_depgraph.AddDependencies(SimTxGraph::SetType::Singleton(pos_par), pos_chl);\n+                    auto todo = temp_depgraph.Positions();\n+                    bool oversize{false};\n+                    while (todo.Any()) {\n+                        auto component = temp_depgraph.FindConnectedComponent(todo);\n+                        if (component.Count() > CLUSTER_COUNT_LIMIT) oversize = true;\n+                        todo -= component;\n+                    }\n+                    if (oversize) break;\n+                }\n+                sim.AddDependency(par, chl);\n+                real->AddDependency(*par, *chl);\n+                break;\n+            } else if (sim.removed.size() < 100 && command-- == 0) {\n+                // RemoveTransaction. Either all its ancestors or all its descendants are also\n+                // removed (if any), to make sure TxGraph's reordering of removals and dependencies\n+                // has no effect.\n+                std::vector<TxGraph::Ref*> to_remove;\n+                to_remove.push_back(pick_fn());\n+                sim.IncludeAncDesc(to_remove, alt);\n+                // The order in which these ancestors/descendants are removed should not matter;\n+                // randomly shuffle them.\n+                std::shuffle(to_remove.begin(), to_remove.end(), rng);\n+                for (TxGraph::Ref* ptr : to_remove) {\n+                    real->RemoveTransaction(*ptr);\n+                    sim.RemoveTransaction(ptr);\n+                }\n+                break;\n+            } else if (sim.removed.size() > 0 && command-- == 0) {\n+                // ~Ref\n+                // Pick a Ref of sim.removed to destroy.\n+                auto removed_pos = provider.ConsumeIntegralInRange<size_t>(0, sim.removed.size() - 1);\n+                if (removed_pos != sim.removed.size() - 1) {\n+                    std::swap(sim.removed[removed_pos], sim.removed.back());\n+                }\n+                sim.removed.pop_back();\n+                break;\n+            } else if (sim.GetTransactionCount() > 0 && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 279,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "do we really not want coverage when the graph is empty?",
      "created_at": "2025-02-12T17:36:30Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953123706",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953123706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953239521",
      "pull_request_review_id": 2612926517,
      "id": 1953239521,
      "node_id": "PRRC_kwDOABII5850bBHh",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 45,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943247961,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You are eaten by a grue (specifically, by His Unpredictableness, the Grue of Undefined Behavior).",
      "created_at": "2025-02-12T18:59:11Z",
      "updated_at": "2025-02-12T19:02:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953239521",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953239521"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953242843",
      "pull_request_review_id": 2612555689,
      "id": 1953242843,
      "node_id": "PRRC_kwDOABII5850bB7b",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 178,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  \"txgraph: (tests) add simulation fuzz test\" 1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b\r\n\r\nwhy add 1 and then subtract again when using the choices value?",
      "created_at": "2025-02-12T19:01:43Z",
      "updated_at": "2025-02-12T21:15:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953242843",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953242843"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953254091",
      "pull_request_review_id": 2612953927,
      "id": 1953254091,
      "node_id": "PRRC_kwDOABII5850bErL",
      "diff_hunk": "@@ -1336,6 +1336,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            // j cannot be 0 here; if it was, then there was necessarily nothing earlier which\n+            // elem needs to be place before anymore, and place_before would be empty.\n+            Assume(j > 0);",
      "path": "src/cluster_linearize.h",
      "position": 471,
      "original_position": 25,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1fb067066eb37452442535d4a75fe2ce9fc05b21",
      "in_reply_to_id": 1943200510,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": ":man_shrugging: I hope the code is clear enough that reviewers are convinced this is impossible. The `Assume` hopefully helps with that convincing. I hope an assertion isn't needed to convince you even more.",
      "created_at": "2025-02-12T19:09:32Z",
      "updated_at": "2025-02-12T19:09:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953254091",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953254091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1371,
      "original_line": 1371,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953271770",
      "pull_request_review_id": 2612555689,
      "id": 1953271770,
      "node_id": "PRRC_kwDOABII5850bI_a",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 117,
      "original_position": 82,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  \"txgraph: (tests) add simulation fuzz test\" 1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b\r\n\r\nShould we return early when parent ref is the same as ref child? This will prevent a possibility of having a cycle.\r\nAs such, we donâ€™t have to check before adding dependency in the fuzz test.",
      "created_at": "2025-02-12T19:23:14Z",
      "updated_at": "2025-02-12T21:15:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953271770",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953271770"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953307646",
      "pull_request_review_id": 2612555689,
      "id": 1953307646,
      "node_id": "PRRC_kwDOABII5850bRv-",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 282,
      "original_position": 200,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  \"txgraph: (tests) add simulation fuzz test\" 1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b\r\n\r\nThis loop is quite big, has series of steps that are depending if behavior of the if else branches.\r\n\r\nWill be nice to add an overview of how the test works, just like it was done in `cluster_linearize` fuzz test",
      "created_at": "2025-02-12T19:51:18Z",
      "updated_at": "2025-02-12T21:16:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953307646",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953307646"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 282,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953324216",
      "pull_request_review_id": 2612580796,
      "id": 1953324216,
      "node_id": "PRRC_kwDOABII5850bVy4",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+        }\n+        assert(entry.m_chunk_feerate == linchunking.GetChunk(0).feerate);\n+        // If this Cluster has an acceptable quality level, its chunks must be connected.\n+        if (m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL) {\n+            assert(m_depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        }\n+    }\n+    // Verify that each element of m_depgraph occured in m_linearization.\n+    assert(m_done == m_depgraph.Positions());\n+}\n+\n+void TxGraphImpl::SanityCheck() const\n+{\n+    /** Which GraphIndexes ought to occur in m_wiped, based on m_entries. */\n+    std::set<GraphIndex> expected_unlinked;\n+    /** Which Clusters ought to occur in m_clusters, based on m_entries. */\n+    std::set<const Cluster*> expected_clusters;\n+\n+    // Go over all Entry objects in m_entries.\n+    for (GraphIndex idx = 0; idx < m_entries.size(); ++idx) {\n+        const auto& entry = m_entries[idx];\n+        if (entry.m_ref == nullptr) {\n+            // Unlinked Entry must have indexes appear in m_unlinked.\n+            expected_unlinked.insert(idx);\n+        } else {\n+            // Every non-unlinked Entry must have a Ref that points back to it.\n+            assert(GetRefGraph(*entry.m_ref) == this);\n+            assert(GetRefIndex(*entry.m_ref) == idx);\n+        }\n+        const auto& locator = entry.m_locator;\n+        // Every Locator must be in exactly one of these 2 states.\n+        assert(locator.IsMissing() + locator.IsPresent() == 1);\n+        if (locator.IsPresent()) {\n+            // Verify that the Cluster agrees with where the Locator claims the transaction is.\n+            assert(locator.cluster->GetClusterEntry(locator.index) == idx);\n+            // Remember that we expect said Cluster to appear in the m_clusters.\n+            expected_clusters.insert(locator.cluster);\n+        }\n+\n+    }\n+\n+    std::set<const Cluster*> actual_clusters;\n+    // For all quality levels...\n+    for (int qual = 0; qual < int(QualityLevel::NONE); ++qual) {\n+        QualityLevel quality{qual};\n+        const auto& quality_clusters = m_clusters[qual];\n+        // ... for all clusters in them ...\n+        for (ClusterSetIndex setindex = 0; setindex < quality_clusters.size(); ++setindex) {\n+            const auto& cluster = *quality_clusters[setindex];\n+            // Remember we saw this Cluster (only if it is non-empty; empty Clusters aren't\n+            // expected to be referenced by the Entry vector).\n+            if (cluster.GetTxCount() != 0) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 127,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Empty clusters can happen anytime `ApplyRemovals()` is invoked, but not `ApplyDependencies` since that invokes `SplitAll()`, correct?",
      "created_at": "2025-02-12T20:05:22Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953324216",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953324216"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953374431",
      "pull_request_review_id": 2613162649,
      "id": 1953374431,
      "node_id": "PRRC_kwDOABII5850biDf",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());",
      "path": "src/txgraph.cpp",
      "position": 596,
      "original_position": 306,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945148422,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't feel that's necessary. The calling code is wrong if it's called with an empty `to_remove`. It's hopefully sufficient to document this, so reviewers can be convinced this isn't being violated.",
      "created_at": "2025-02-12T20:47:36Z",
      "updated_at": "2025-02-12T20:47:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953374431",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953374431"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 596,
      "original_line": 596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953384628",
      "pull_request_review_id": 2612555689,
      "id": 1953384628,
      "node_id": "PRRC_kwDOABII5850bki0",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+        }\n+        assert(entry.m_chunk_feerate == linchunking.GetChunk(0).feerate);\n+        // If this Cluster has an acceptable quality level, its chunks must be connected.\n+        if (m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL) {\n+            assert(m_depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        }\n+    }\n+    // Verify that each element of m_depgraph occured in m_linearization.\n+    assert(m_done == m_depgraph.Positions());\n+}\n+\n+void TxGraphImpl::SanityCheck() const\n+{\n+    /** Which GraphIndexes ought to occur in m_wiped, based on m_entries. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"txgraph: (tests) add internal sanity check function\" 741a6a8c4d851cb10ecee810a09187bcbfa5af4c\r\n\r\nWhat is `m_wiped`",
      "created_at": "2025-02-12T20:53:37Z",
      "updated_at": "2025-02-12T21:15:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953384628",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953384628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1895,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953392682",
      "pull_request_review_id": 2612555689,
      "id": 1953392682,
      "node_id": "PRRC_kwDOABII5850bmgq",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  \"txgraph: (tests) add internal sanity check function\" 741a6a8c4d851cb10ecee810a09187bcbfa5af4c\r\n\r\nShould we also compare that the list of transactions in chunk 0 matches `m_linearization` subset from from previous hit of the conditional statement to `lin_pos`?",
      "created_at": "2025-02-12T21:01:01Z",
      "updated_at": "2025-02-12T21:15:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953392682",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953392682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953411421",
      "pull_request_review_id": 2613227332,
      "id": 1953411421,
      "node_id": "PRRC_kwDOABII5850brFd",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);",
      "path": "src/txgraph.cpp",
      "position": 798,
      "original_position": 446,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945495189,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It follows from the property that PostLinearize results in chunks that do not consist of multiple disconnected components: if a higher-feerate chunk is appended to a lower-feerate one, it must mean they get separated.\r\n\r\nI'm happy to elaborate briefly in this comment, but perhaps this is also not the place to provide deeper more theoretical reasons why the properties hold.",
      "created_at": "2025-02-12T21:16:39Z",
      "updated_at": "2025-02-12T21:16:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953411421",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953411421"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 798,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953444815",
      "pull_request_review_id": 2612580796,
      "id": 1953444815,
      "node_id": "PRRC_kwDOABII5850bzPP",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);",
      "path": "src/txgraph.cpp",
      "position": 798,
      "original_position": 446,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945495189,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I am perhaps taking the comment too literally? I just don't see how it's a merge-sort of chunks when a PostLinearize may very well end up changing chunk boundaries. Or maybe it doesn't? I buy that the documented properties otherwise hold.\r\n\r\nEither way, is there a presumed standout benefit to calling this once here, then after dependencies have been applied and linearization fixed?",
      "created_at": "2025-02-12T21:45:20Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953444815",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953444815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 798,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953458099",
      "pull_request_review_id": 2613300761,
      "id": 1953458099,
      "node_id": "PRRC_kwDOABII5850b2ez",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        const auto& loc = m_entries[group_data.m_deps[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, group_data.m_deps);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data = std::vector<GroupEntry>{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Ancestors(idx).Count());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Descendants(idx).Count());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified DepGraphIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (m_quality != QualityLevel::NEEDS_SPLIT) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n+{\n+    // Don't do anything if the passed Ref is empty.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);",
      "path": "src/txgraph.cpp",
      "position": 1835,
      "original_position": 1104,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951125073,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If we're going to expend run-time cost to perform the check, we might as well drop the requirement that Ref refers to this graph entirely. Given that we're not expecting to ever have multiple TxGraph objects in production, this feels like overkill.",
      "created_at": "2025-02-12T21:57:23Z",
      "updated_at": "2025-02-12T21:57:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953458099",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953458099"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1835,
      "original_line": 1835,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953460271",
      "pull_request_review_id": 2613304675,
      "id": 1953460271,
      "node_id": "PRRC_kwDOABII5850b3Av",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */",
      "path": "src/txgraph.h",
      "position": 47,
      "original_position": 22,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951175625,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'd rather not refer to implementation details in the public interface.",
      "created_at": "2025-02-12T21:59:28Z",
      "updated_at": "2025-02-12T21:59:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953460271",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953460271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953481542",
      "pull_request_review_id": 2613343325,
      "id": 1953481542,
      "node_id": "PRRC_kwDOABII5850b8NG",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.",
      "path": "src/txgraph.cpp",
      "position": 1097,
      "original_position": 668,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951249320,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed.",
      "created_at": "2025-02-12T22:18:43Z",
      "updated_at": "2025-02-12T22:18:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953481542",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953481542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1097,
      "original_line": 1097,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953484318",
      "pull_request_review_id": 2613348274,
      "id": 1953484318,
      "node_id": "PRRC_kwDOABII5850b84e",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;",
      "path": "src/txgraph.cpp",
      "position": 1133,
      "original_position": 695,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0eacbd61cb8d00163bc00b9fe3d94899e283c065",
      "in_reply_to_id": 1951627940,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's a tiny number, as it's bounded by $\\mathcal{O}(\\log n)$, so it didn't feel right to use the same `DepGraphIndex` or `GraphIndex` type.",
      "created_at": "2025-02-12T22:21:36Z",
      "updated_at": "2025-02-12T22:21:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953484318",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953484318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1133,
      "original_line": 1133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953494478",
      "pull_request_review_id": 2613365802,
      "id": 1953494478,
      "node_id": "PRRC_kwDOABII5850b_XO",
      "diff_hunk": "@@ -0,0 +1,1719 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a ClusterIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster may have multiple disconnected components, which are all OPTIMAL. */\n+    NEEDS_SPLIT_OPTIMAL,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<ClusterIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeeFrac& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a ClusterIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(ClusterIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(ClusterIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<const std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, ClusterIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeeFrac GetIndividualFeerate(ClusterIndex idx) noexcept;\n+    /** Modify the feerate of a Cluster element. */\n+    void SetFeerate(TxGraphImpl& graph, ClusterIndex idx, const FeeFrac& feerate) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Cleanup).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const ClusterIndex m_max_cluster_count;\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Which clusters are to be merged, if known. Each group is followed by a nullptr. */\n+        std::optional<std::vector<Cluster*>> m_to_merge = std::vector<Cluster*>{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+        GraphIndex m_txcount{0};\n+        /** Whether we know that merging clusters (as determined by m_to_merge) would exceed the max\n+            cluster size. */\n+        bool m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        ClusterIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = ClusterIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, ClusterIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == ClusterIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, or nullptr if none. */\n+        Ref* m_ref;\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]) */\n+        FeeFrac m_main_chunk_feerate;\n+        /** The position this transaction in the main linearization (if present). /*/",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 230,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "18184f4e73404a7d41579fb408bd21f14c73668d",
      "in_reply_to_id": 1890424349,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:31:34Z",
      "updated_at": "2025-02-12T22:31:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953494478",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953494478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 258,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953494661",
      "pull_request_review_id": 2613366195,
      "id": 1953494661,
      "node_id": "PRRC_kwDOABII5850b_aF",
      "diff_hunk": "@@ -1336,6 +1336,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 9,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1fb067066eb37452442535d4a75fe2ce9fc05b21",
      "in_reply_to_id": 1943163414,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:31:40Z",
      "updated_at": "2025-02-12T22:31:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953494661",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953494661"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1355,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953495202",
      "pull_request_review_id": 2613367185,
      "id": 1953495202,
      "node_id": "PRRC_kwDOABII5850b_ii",
      "diff_hunk": "@@ -1336,6 +1336,38 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.",
      "path": "src/cluster_linearize.h",
      "position": null,
      "original_position": 18,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1fb067066eb37452442535d4a75fe2ce9fc05b21",
      "in_reply_to_id": 1943179984,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:31:58Z",
      "updated_at": "2025-02-12T22:31:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953495202",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953495202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1364,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953495306",
      "pull_request_review_id": 2613367378,
      "id": 1953495306,
      "node_id": "PRRC_kwDOABII5850b_kK",
      "diff_hunk": "@@ -407,7 +407,7 @@ FUZZ_TARGET(clusterlin_depgraph_serialization)\n     SanityCheck(depgraph);\n \n     // Verify the graph is a DAG.\n-    assert(IsAcyclic(depgraph));",
      "path": "src/test/fuzz/cluster_linearize.cpp",
      "position": 131,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "a921ae75c2f7162b3b617ddeccb84e3e60728cf8",
      "in_reply_to_id": 1943228435,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:32:05Z",
      "updated_at": "2025-02-12T22:32:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953495306",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953495306"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 410,
      "original_line": 410,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953495533",
      "pull_request_review_id": 2613368336,
      "id": 1953495533,
      "node_id": "PRRC_kwDOABII5850b_nt",
      "diff_hunk": "@@ -280,6 +280,7 @@ add_library(bitcoin_node STATIC EXCLUDE_FROM_ALL\n   signet.cpp\n   torcontrol.cpp\n   txdb.cpp\n+  txgraph.cpp",
      "path": "src/CMakeLists.txt",
      "position": 4,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943239737,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:32:15Z",
      "updated_at": "2025-02-12T22:32:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953495533",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953495533"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 304,
      "original_line": 304,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953496332",
      "pull_request_review_id": 2613369531,
      "id": 1953496332,
      "node_id": "PRRC_kwDOABII5850b_0M",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 84,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943260292,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've reworded this a bit.",
      "created_at": "2025-02-12T22:32:26Z",
      "updated_at": "2025-02-12T22:32:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953496332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953496332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953498553",
      "pull_request_review_id": 2613373974,
      "id": 1953498553,
      "node_id": "PRRC_kwDOABII5850cAW5",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 159,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943333169,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's something that really only has meaning after staging support is added. I have dropped it here, expanded the comment a bit, and expanded on it a lot more in the staging commit.",
      "created_at": "2025-02-12T22:33:24Z",
      "updated_at": "2025-02-12T22:33:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953498553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953498553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 159,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953498653",
      "pull_request_review_id": 2613374149,
      "id": 1953498653,
      "node_id": "PRRC_kwDOABII5850cAYd",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 182,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943352763,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:33:29Z",
      "updated_at": "2025-02-12T22:33:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953498653",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953498653"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953499000",
      "pull_request_review_id": 2613375164,
      "id": 1953499000,
      "node_id": "PRRC_kwDOABII5850cAd4",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 87,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945144668,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have rewritten this.",
      "created_at": "2025-02-12T22:33:40Z",
      "updated_at": "2025-02-12T22:33:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953499000",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953499000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 110,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953499878",
      "pull_request_review_id": 2613377055,
      "id": 1953499878,
      "node_id": "PRRC_kwDOABII5850cArm",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();",
      "path": "src/txgraph.cpp",
      "position": 599,
      "original_position": 309,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945149772,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have added an Assume, but not the break. It just shouldn't happen, and this is tested extensively in fuzzing (where the Assumes actually have teeth).",
      "created_at": "2025-02-12T22:34:21Z",
      "updated_at": "2025-02-12T22:34:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953499878",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953499878"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 599,
      "original_line": 599,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500039",
      "pull_request_review_id": 2613377715,
      "id": 1953500039,
      "node_id": "PRRC_kwDOABII5850cAuH",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945156500,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:34:29Z",
      "updated_at": "2025-02-12T22:34:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953500039",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500039"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500309",
      "pull_request_review_id": 2613378088,
      "id": 1953500309,
      "node_id": "PRRC_kwDOABII5850cAyV",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945163261,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed. Expanded/corrected the comment.",
      "created_at": "2025-02-12T22:34:41Z",
      "updated_at": "2025-02-12T22:34:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953500309",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500309"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500407",
      "pull_request_review_id": 2613378208,
      "id": 1953500407,
      "node_id": "PRRC_kwDOABII5850cAz3",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {",
      "path": "src/txgraph.cpp",
      "position": 702,
      "original_position": 354,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945374176,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:34:47Z",
      "updated_at": "2025-02-12T22:34:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953500407",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500407"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 702,
      "original_line": 702,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500490",
      "pull_request_review_id": 2613378336,
      "id": 1953500490,
      "node_id": "PRRC_kwDOABII5850cA1K",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 365,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945422363,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:34:53Z",
      "updated_at": "2025-02-12T22:34:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953500490",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500490"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 637,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500634",
      "pull_request_review_id": 2613378555,
      "id": 1953500634,
      "node_id": "PRRC_kwDOABII5850cA3a",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);",
      "path": "src/txgraph.cpp",
      "position": 776,
      "original_position": 424,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945470973,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a comment to this effect.",
      "created_at": "2025-02-12T22:35:03Z",
      "updated_at": "2025-02-12T22:35:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953500634",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 776,
      "original_line": 776,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500945",
      "pull_request_review_id": 2613379049,
      "id": 1953500945,
      "node_id": "PRRC_kwDOABII5850cA8R",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 95,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945502896,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This comment was no longer relevant, it dates from an earlier iteration. Gone.",
      "created_at": "2025-02-12T22:35:24Z",
      "updated_at": "2025-02-12T22:35:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953500945",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953500945"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 118,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501047",
      "pull_request_review_id": 2613379176,
      "id": 1953501047,
      "node_id": "PRRC_kwDOABII5850cA93",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 454,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945504644,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:35:30Z",
      "updated_at": "2025-02-12T22:35:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953501047",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 726,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501119",
      "pull_request_review_id": 2613379301,
      "id": 1953501119,
      "node_id": "PRRC_kwDOABII5850cA-_",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 497,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945525747,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Gone.",
      "created_at": "2025-02-12T22:35:36Z",
      "updated_at": "2025-02-12T22:35:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953501119",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 772,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501453",
      "pull_request_review_id": 2613379857,
      "id": 1953501453,
      "node_id": "PRRC_kwDOABII5850cBEN",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 561,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945553960,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "When the same Ref is `RemoveTransaction()`ed twice. Added a comment to clarify.",
      "created_at": "2025-02-12T22:35:58Z",
      "updated_at": "2025-02-12T22:35:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953501453",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 561,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501564",
      "pull_request_review_id": 2613380004,
      "id": 1953501564,
      "node_id": "PRRC_kwDOABII5850cBF8",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 599,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951014516,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:36:05Z",
      "updated_at": "2025-02-12T22:36:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953501564",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 928,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501757",
      "pull_request_review_id": 2613380240,
      "id": 1953501757,
      "node_id": "PRRC_kwDOABII5850cBI9",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 659,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951083840,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-02-12T22:36:14Z",
      "updated_at": "2025-02-12T22:36:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953501757",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 998,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501842",
      "pull_request_review_id": 2613380384,
      "id": 1953501842,
      "node_id": "PRRC_kwDOABII5850cBKS",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the\n+        // same Cluster because of the merging above).\n+        const auto& loc = m_entries[group_data.m_deps[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, group_data.m_deps);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data = std::vector<GroupEntry>{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE ||\n+           m_quality == QualityLevel::NEEDS_RELINEARIZE);\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (m_quality == QualityLevel::OPTIMAL) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (cluster.m_quality == QualityLevel::NEEDS_RELINEARIZE) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Ancestors(idx).Count());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Descendants(idx).Count());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all dependencies, as the result might be incorrect otherwise.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1010,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951108357,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:36:21Z",
      "updated_at": "2025-02-12T22:36:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953501842",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953501842"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1451,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953502322",
      "pull_request_review_id": 2613381388,
      "id": 1953502322,
      "node_id": "PRRC_kwDOABII5850cBRy",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 93,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951123494,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added a comment to `AddTransaction` to clarify one can only pass Refs from a given txgraph object to functions of the same object.",
      "created_at": "2025-02-12T22:36:52Z",
      "updated_at": "2025-02-12T22:36:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953502322",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953502322"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953502492",
      "pull_request_review_id": 2613381653,
      "id": 1953502492,
      "node_id": "PRRC_kwDOABII5850cBUc",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 846,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951190764,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-02-12T22:37:04Z",
      "updated_at": "2025-02-12T22:37:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953502492",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953502492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 846,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953502916",
      "pull_request_review_id": 2613382197,
      "id": 1953502916,
      "node_id": "PRRC_kwDOABII5850cBbE",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951202254,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Added a comment to this effect (the variable is gone in a future commit, though).",
      "created_at": "2025-02-12T22:37:31Z",
      "updated_at": "2025-02-12T22:37:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953502916",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953502916"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953503038",
      "pull_request_review_id": 2613382332,
      "id": 1953503038,
      "node_id": "PRRC_kwDOABII5850cBc-",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_uf(locate_uf(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    Assume(m_group_data.has_value());\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (for each, parent and child belong to the",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 850,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1951205931,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:37:37Z",
      "updated_at": "2025-02-12T22:37:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953503038",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953503038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953503351",
      "pull_request_review_id": 2613382832,
      "id": 1953503351,
      "node_id": "PRRC_kwDOABII5850cBh3",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 710,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0eacbd61cb8d00163bc00b9fe3d94899e283c065",
      "in_reply_to_id": 1951633305,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Renamed to `find_root_fn`, `locate_fn`, `union_fn`.",
      "created_at": "2025-02-12T22:37:59Z",
      "updated_at": "2025-02-12T22:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953503351",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953503351"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 710,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953503471",
      "pull_request_review_id": 2613382985,
      "id": 1953503471,
      "node_id": "PRRC_kwDOABII5850cBjv",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        DepGraphIndex child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_quality = quality;\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step (which might invalidate\n+    // them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_apply entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_uf = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_uf = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_uf = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_uf(arg1);\n+            auto rep2 = find_uf(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_uf(locate_uf(par_cluster), locate_uf(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_uf(&data)->cluster;\n+            an_clusters[i].second = rep;",
      "path": "src/txgraph.cpp",
      "position": 1217,
      "original_position": 764,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0eacbd61cb8d00163bc00b9fe3d94899e283c065",
      "in_reply_to_id": 1951651150,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-12T22:38:06Z",
      "updated_at": "2025-02-12T22:38:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953503471",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953503471"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1217,
      "original_line": 1217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953783352",
      "pull_request_review_id": 2613805844,
      "id": 1953783352,
      "node_id": "PRRC_kwDOABII5850dF44",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 178,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953242843,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Well `choices` counts the actual number of choices, consisting of:\r\n* All transactions in sim.simmap (`tx_count`)\r\n* All transactions in sim.removed (`sim.removed.size()`)\r\n* The empty Ref (`1`).\r\n\r\nWhen picking one of them, we want one in the range from 0 up to and including `choices - 1`.",
      "created_at": "2025-02-13T04:26:05Z",
      "updated_at": "2025-02-13T04:26:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953783352",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953783352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953785604",
      "pull_request_review_id": 2613809005,
      "id": 1953785604,
      "node_id": "PRRC_kwDOABII5850dGcE",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 117,
      "original_position": 82,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953271770,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It doesn't matter; `TxGraph` ignores self-dependencies anyway (because `DepGraph` does), so having it doesn't hurt, and adds testing for that case.",
      "created_at": "2025-02-13T04:27:20Z",
      "updated_at": "2025-02-13T04:27:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953785604",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953785604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953788209",
      "pull_request_review_id": 2613813227,
      "id": 1953788209,
      "node_id": "PRRC_kwDOABII5850dHEx",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 282,
      "original_position": 200,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953307646,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's not clear to me what you're asking for. I would describe the test as \"big simulation test, which performs a number of operations on a real TxGraph, and on a simpler reimplementation, and in the end compares the two\". Something like that? Which `cluster_linearize` fuzz test are you referring to?",
      "created_at": "2025-02-13T04:29:58Z",
      "updated_at": "2025-02-13T04:29:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953788209",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953788209"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 282,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953790028",
      "pull_request_review_id": 2613815974,
      "id": 1953790028,
      "node_id": "PRRC_kwDOABII5850dHhM",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": 1953392682,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm not sure what you mean here.",
      "created_at": "2025-02-13T04:32:54Z",
      "updated_at": "2025-02-13T04:32:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953790028",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953790028"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953791082",
      "pull_request_review_id": 2613817796,
      "id": 1953791082,
      "node_id": "PRRC_kwDOABII5850dHxq",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953022822,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed, fixed.",
      "created_at": "2025-02-13T04:35:01Z",
      "updated_at": "2025-02-13T04:35:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953791082",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953791082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953791264",
      "pull_request_review_id": 2613817976,
      "id": 1953791264,
      "node_id": "PRRC_kwDOABII5850dH0g",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+        }\n+        assert(entry.m_chunk_feerate == linchunking.GetChunk(0).feerate);\n+        // If this Cluster has an acceptable quality level, its chunks must be connected.\n+        if (m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL) {\n+            assert(m_depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        }\n+    }\n+    // Verify that each element of m_depgraph occured in m_linearization.\n+    assert(m_done == m_depgraph.Positions());\n+}\n+\n+void TxGraphImpl::SanityCheck() const\n+{\n+    /** Which GraphIndexes ought to occur in m_wiped, based on m_entries. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": 1953384628,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That was outdated. Fixed.",
      "created_at": "2025-02-13T04:35:14Z",
      "updated_at": "2025-02-13T04:35:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1953791264",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1953791264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1895,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1954986316",
      "pull_request_review_id": 2612580796,
      "id": 1954986316,
      "node_id": "PRRC_kwDOABII5850hrlM",
      "diff_hunk": "@@ -799,25 +808,29 @@ void TxGraphImpl::GroupClusters() noexcept\n         // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n         // and the input dependencies, annotated with the representative of the Cluster partition\n         // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n         for (size_t i = 0; i < partition_data.size(); ++i) {\n             auto& data = partition_data[i];\n             // Find the representative of the partition Cluster i is in, and store it with the\n             // Cluster.\n             auto rep = find_root_fn(&data)->cluster;\n             Assume(an_clusters[i].second == nullptr);\n             an_clusters[i].second = rep;\n-        }\n-        an_deps.reserve(m_deps_to_add.size());\n-        for (auto [par, chl] : m_deps_to_add) {\n-            auto chl_cluster = m_entries[chl].m_locator.cluster;\n-            auto par_cluster = m_entries[par].m_locator.cluster;\n-            // Nothing to do if either parent or child transaction is removed already.\n-            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n-            // Find the representative of the partition which this dependency's child is in (which\n-            // should be the same as the one for the parent).\n-            auto rep = find_root_fn(locate_fn(chl_cluster))->cluster;\n-            // Create an_deps entry.\n-            an_deps.emplace_back(std::pair{par, chl}, rep);\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 47,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "56cbdd7889e957c29d76681c46c4a7a6983c9be6",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "56cbdd7889e957c29d76681c46c4a7a6983c9be6\r\n\r\nI rewrote it so my smooth brain could better decipher it (I believe it's the same) :\r\n```\r\ndiff --git a/src/txgraph.cpp b/src/txgraph.cpp\r\nindex b2cecffebb..df93eb2a13 100644\r\n--- a/src/txgraph.cpp\r\n+++ b/src/txgraph.cpp\r\n@@ -821,12 +821,13 @@ void TxGraphImpl::GroupClusters() noexcept\r\n             while (deps_it != m_deps_to_add.end()) {\r\n                 auto [par, chl] = *deps_it;\r\n                 auto chl_cluster = m_entries[chl].m_locator.cluster;\r\n                 // Skip dependencies that apply to earlier Clusters (those necessary are for\r\n                 // deleted transactions, as otherwise we'd have processed them already).\r\n-                if (!std::less{}(chl_cluster, data.cluster)) {\r\n-                    if (chl_cluster != data.cluster) break;\r\n+                if (std::greater{}(chl_cluster, data.cluster)) {\r\n+                    break;\r\n+                } else if (chl_cluster == data.cluster) {\r\n                     auto par_cluster = m_entries[par].m_locator.cluster;\r\n                     // Also filter out dependencies applying to a removed parent.\r\n                     if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\r\n                 }\r\n                 ++deps_it;\r\n```",
      "created_at": "2025-02-13T18:02:01Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1954986316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1954986316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955027230",
      "pull_request_review_id": 2612580796,
      "id": 1955027230,
      "node_id": "PRRC_kwDOABII5850h1ke",
      "diff_hunk": "@@ -365,26 +369,56 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         --graph.m_txcount;\n     } while(!to_remove.empty());\n \n+    auto quality = m_quality;\n     Assume(todo.Any());\n     // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n     // removed, so we benefit from batching all the removals).\n     m_depgraph.RemoveTransactions(todo);\n     m_mapping.resize(m_depgraph.PositionRange());\n \n-    // Filter removals out of m_linearization.\n-    m_linearization.erase(std::remove_if(\n-        m_linearization.begin(),\n-        m_linearization.end(),\n-        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n-\n-    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (quality == QualityLevel::OPTIMAL || quality == QualityLevel::NEEDS_SPLIT_OPTIMAL) {\n+            quality = QualityLevel::NEEDS_SPLIT_OPTIMAL;\n+        } else if (quality == QualityLevel::ACCEPTABLE || quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else if (quality == QualityLevel::NEEDS_RELINEARIZE) {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_quality, m_setindex, quality);\n     Updated(graph);\n }\n \n bool Cluster::Split(TxGraphImpl& graph) noexcept\n {\n     // This function can only be called when the Cluster needs splitting.\n-    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT || m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ||\n+           m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = m_quality == QualityLevel::NEEDS_SPLIT ? QualityLevel::NEEDS_RELINEARIZE :\n+                               m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ? QualityLevel::OPTIMAL :\n+                               QualityLevel::ACCEPTABLE;\n+    // If the cluster was NEEDS_SPLIT_OPTIMAL, and we're thus going to produce OPTIMAL clusters, we",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "693c3df67dc972dd2fcfbeb8179bcd7833c77bd1",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "693c3df67dc972dd2fcfbeb8179bcd7833c77bd1\r\n\r\nWorking on convincing myself that PostLinearization is suffcient to result in optimal clusters. I think it's straight forward that the chunk prefixes before any removed tail transactions are untouched, and once we remove tail transactions, the last touched-but-not-fully-removed chunk may be in a substandard ordering. \r\n\r\nSo PostLinearization guarantees that the final sub-chunk is reordered to being connected, and that means that sub-chunk is now optimal? I'm going to need help here.\r\n\r\nSomething I was too lazy to do: A fuzz harness could be constructed via taking verified-optimal depgraphs (from exhaustive solver), chopping the tail off, and verifying all connected components `PostLinearize`-ation are just as good as whatever the exhaustive linearizer gives for each component-now-cluster?",
      "created_at": "2025-02-13T18:29:10Z",
      "updated_at": "2025-02-21T17:11:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955027230",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955027230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955088750",
      "pull_request_review_id": 2616010357,
      "id": 1955088750,
      "node_id": "PRRC_kwDOABII5850iElu",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 178,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953242843,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Makes sense thanks.",
      "created_at": "2025-02-13T19:19:49Z",
      "updated_at": "2025-02-13T19:19:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955088750",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955088750"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": 176,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955089683",
      "pull_request_review_id": 2616011805,
      "id": 1955089683,
      "node_id": "PRRC_kwDOABII5850iE0T",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953022822,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: There is still one remaining in line 180.",
      "created_at": "2025-02-13T19:20:36Z",
      "updated_at": "2025-02-13T19:20:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955089683",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955089683"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955090027",
      "pull_request_review_id": 2616012422,
      "id": 1955090027,
      "node_id": "PRRC_kwDOABII5850iE5r",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 282,
      "original_position": 200,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953307646,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah something like that that \r\n\r\nIn most of the fuzz test in `src/test/fuzz/cluster_linearize.cpp` you provided a really nice description , which is just an overview of what the test is going to do before jumping to the instructions.\r\n\r\nHere we just jump into the instructions without that context.\r\n\r\nBut this is nitty, you can ignore this comment and resolve.",
      "created_at": "2025-02-13T19:20:55Z",
      "updated_at": "2025-02-13T19:20:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955090027",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955090027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 282,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955090136",
      "pull_request_review_id": 2616012630,
      "id": 1955090136,
      "node_id": "PRRC_kwDOABII5850iE7Y",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": 1953392682,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah I was thinking something like\r\n\r\n<details>\r\n<summary>diff</summary>\r\n\r\n```diff\r\ndiff --git a/src/txgraph.cpp b/src/txgraph.cpp\r\nindex afaa46e6326..a9b3e446d26 100644\r\n--- a/src/txgraph.cpp\r\n+++ b/src/txgraph.cpp\r\n@@ -1143,6 +1143,7 @@ void Cluster::SanityCheck(const TxGraphImpl& graph) const\r\n \r\n     // Verify m_linearization.\r\n     SetType m_done;\r\n+    SetType last_chunk;\r\n     assert(m_depgraph.IsAcyclic());\r\n     for (auto lin_pos : m_linearization) {\r\n         assert(lin_pos < m_mapping.size());\r\n@@ -1155,9 +1156,12 @@ void Cluster::SanityCheck(const TxGraphImpl& graph) const\r\n         assert(entry.m_locator.index == lin_pos);\r\n         // Check linearization position and chunk feerate.\r\n         if (!linchunking.GetChunk(0).transactions[lin_pos]) {\r\n+            assert(linchunking.GetChunk(0).transactions == last_chunk);\r\n+            last_chunk = SetType();\r\n             linchunking.MarkDone(linchunking.GetChunk(0).transactions);\r\n         }\r\n         assert(entry.m_chunk_feerate == linchunking.GetChunk(0).feerate);\r\n+        last_chunk.Set(lin_pos);\r\n         // If this Cluster has an acceptable quality level, its chunks must be connected.\r\n         if (m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL) {\r\n             assert(m_depgraph.IsConnected(linchunking.GetChunk(0).transactions));\r\n```\r\n</details>",
      "created_at": "2025-02-13T19:21:01Z",
      "updated_at": "2025-02-13T19:21:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955090136",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955090136"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955149722",
      "pull_request_review_id": 2616111942,
      "id": 1955149722,
      "node_id": "PRRC_kwDOABII5850iTea",
      "diff_hunk": "@@ -997,6 +1018,7 @@ void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n     m_group_data.reset();\n     // Remember that this dependency is to be applied.\n     m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+    m_group_data.reset();",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 113,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "370c419c330ca73d9ea44a7d48506a5c203e9c17",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"txgraph: (feature) make max cluster count configurable and oversize state\" 370c419c330ca73d9ea44a7d48506a5c203e9c17\r\n\r\nThis is a duplicate I think",
      "created_at": "2025-02-13T20:09:04Z",
      "updated_at": "2025-02-13T22:28:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955149722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955149722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1021,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955238525",
      "pull_request_review_id": 2616263133,
      "id": 1955238525,
      "node_id": "PRRC_kwDOABII5850ipJ9",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 75,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": 1953392682,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I don't think this is the place for it, as it amounts to testing of `LinearizationChunking`, not `TxGraph`. The point of the code here is just to get the chunks defined by `m_linearization` out, so we can test them. If `LinearizationChunking` works correctly (see `clusterlin_linearization_chunking` for that), then the chunks that come out will correspond to consecutive transactions from the linearization.",
      "created_at": "2025-02-13T21:29:46Z",
      "updated_at": "2025-02-13T21:29:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955238525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955238525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955241097",
      "pull_request_review_id": 2616266133,
      "id": 1955241097,
      "node_id": "PRRC_kwDOABII5850ipyJ",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 282,
      "original_position": 200,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953307646,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Will address on the next push.",
      "created_at": "2025-02-13T21:30:38Z",
      "updated_at": "2025-02-13T21:30:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955241097",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955241097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 282,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955245898",
      "pull_request_review_id": 2616111942,
      "id": 1955245898,
      "node_id": "PRRC_kwDOABII5850iq9K",
      "diff_hunk": "@@ -317,23 +317,27 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n         auto& entry = graph.m_entries[m_mapping[idx]];\n         entry.m_locator.SetPresent(this, idx);\n     }\n-\n-    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n-    LinearizationChunking chunking(m_depgraph, m_linearization);\n-    LinearizationIndex lin_idx{0};\n-    // Iterate over the chunks.\n-    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n-        auto chunk = chunking.GetChunk(chunk_idx);\n-        Assume(chunk.transactions.Any());\n-        // Iterate over the transactions in the linearization, which must match those in chunk.\n-        do {\n-            DepGraphIndex idx = m_linearization[lin_idx++];\n-            GraphIndex graph_idx = m_mapping[idx];\n-            auto& entry = graph.m_entries[graph_idx];\n-            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n-            Assume(chunk.transactions[idx]);\n-            chunk.transactions.Reset(idx);\n-        } while(chunk.transactions.Any());\n+    // If the Cluster's quality is ACCEPTABLE or OPTIMAL, compute its chunking and store its\n+    // information in the Entry's m_chunk_feerate. These fields are only accessed after making\n+    // the entire graph ACCEPTABLE, so it is pointless to compute these if we haven't reached that\n+    // quality level yet.\n+    if (m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "30d7c8ce7f34e977238d1454dd032196cbfd936b",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In \"txgraph: (optimization) delay chunking while sub-acceptable\" 30d7c8ce7f34e977238d1454dd032196cbfd936b \r\n\r\nnit: we can have truthy/false method for this so that we can just call it.\r\nwe have this conditional statement in quite a few places",
      "created_at": "2025-02-13T21:35:17Z",
      "updated_at": "2025-02-13T22:28:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955245898",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955245898"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955280251",
      "pull_request_review_id": 2616111942,
      "id": 1955280251,
      "node_id": "PRRC_kwDOABII5850izV7",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);",
      "path": "src/txgraph.cpp",
      "position": 708,
      "original_position": 358,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1949828517,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see this now ðŸ‘ðŸ¾ ",
      "created_at": "2025-02-13T22:07:55Z",
      "updated_at": "2025-02-13T22:28:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1955280251",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1955280251"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 708,
      "original_line": 708,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956309054",
      "pull_request_review_id": 2612580796,
      "id": 1956309054,
      "node_id": "PRRC_kwDOABII5850mug-",
      "diff_hunk": "@@ -260,6 +260,8 @@ class TxGraphImpl final : public TxGraph\n     ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n     /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n     void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1b207547a99afccd52e3ecfb801af1d9bab7f2b8",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit\r\n```Suggestion\r\n    /** Make a transaction not exist. Transaction must currently exist. */\r\n```",
      "created_at": "2025-02-14T15:16:15Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956309054",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956309054"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956343988",
      "pull_request_review_id": 2618143580,
      "id": 1956343988,
      "node_id": "PRRC_kwDOABII5850m3C0",
      "diff_hunk": "@@ -252,16 +305,21 @@ class TxGraphImpl final : public TxGraph\n \n     /** Swap the Entrys referred to by a and b. */\n     void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n-    /** Extract a Cluster. */\n-    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly or implicitly), return the",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 171,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What do you mean by implicitly",
      "created_at": "2025-02-14T15:40:04Z",
      "updated_at": "2025-02-14T17:36:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956343988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956343988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956354845",
      "pull_request_review_id": 2612580796,
      "id": 1956354845,
      "node_id": "PRRC_kwDOABII5850m5sd",
      "diff_hunk": "@@ -90,6 +95,17 @@ class Cluster\n     void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n     /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n     void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: \"level-1\" is a bit vague, but understandable once you dive into the code itself. \"top level - 1\"?",
      "created_at": "2025-02-14T15:47:12Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956354845",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956354845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956359627",
      "pull_request_review_id": 2612580796,
      "id": 1956359627,
      "node_id": "PRRC_kwDOABII5850m63L",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "IIUC this field should become a subset of `m_to_remove`'s value which ended up being `IsPresent`? Is there any better way to explain the relationship of these two variables?",
      "created_at": "2025-02-14T15:49:33Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956359627",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956359627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956359892",
      "pull_request_review_id": 2618143580,
      "id": 1956359892,
      "node_id": "PRRC_kwDOABII5850m67U",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n         /** Total number of transactions in this graph (sum of all transaction counts in all\n-         *  Clusters). */\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n         GraphIndex m_txcount{0};\n     };\n \n-    /** The ClusterSet for this TxGraphImpl. */\n-    ClusterSet m_clusterset;\n-\n-    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing: not present in a Cluster at that level. For main, this means the transaction\n+     *               does not exist. For staging this means it its existence is inherited from\n+     *               main. If it doesn't exist in main, it doesn't exist in staging either. If it\n+     *               does existing in main, the cluster it is in is unmodified in staging.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 99,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```suggestion\r\n     *               does exist in main, the cluster it is in is unmodified in staging.\r\n```",
      "created_at": "2025-02-14T15:49:40Z",
      "updated_at": "2025-02-14T17:36:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956359892",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956359892"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956385389",
      "pull_request_review_id": 2618143580,
      "id": 1956385389,
      "node_id": "PRRC_kwDOABII5850nBJt",
      "diff_hunk": "@@ -90,6 +95,17 @@ class Cluster\n     void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n     /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n     void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should just refer to main and staging only instead of level-1, main, staging and top level?\r\nIt will be consistent this way.\r\n",
      "created_at": "2025-02-14T16:05:27Z",
      "updated_at": "2025-02-14T17:36:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956385389",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956385389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956400806",
      "pull_request_review_id": 2618143580,
      "id": 1956400806,
      "node_id": "PRRC_kwDOABII5850nE6m",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n         /** Total number of transactions in this graph (sum of all transaction counts in all\n-         *  Clusters). */\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n         GraphIndex m_txcount{0};\n     };\n \n-    /** The ClusterSet for this TxGraphImpl. */\n-    ClusterSet m_clusterset;\n-\n-    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing: not present in a Cluster at that level. For main, this means the transaction\n+     *               does not exist. For staging this means it its existence is inherited from\n+     *               main. If it doesn't exist in main, it doesn't exist in staging either. If it\n+     *               does existing in main, the cluster it is in is unmodified in staging.\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.",
      "path": "src/txgraph.cpp",
      "position": 273,
      "original_position": 110,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "hmm, above you mentioned \"If it doesn't exist in main, it doesn't exist in staging either.\".\r\n\r\nAnd now there is a state where the transaction exits in staging but not in main",
      "created_at": "2025-02-14T16:15:18Z",
      "updated_at": "2025-02-14T17:36:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956400806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956400806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 273,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956442485",
      "pull_request_review_id": 2618143580,
      "id": 1956442485,
      "node_id": "PRRC_kwDOABII5850nPF1",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 312,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should we just do this here and other places?\r\n```suggestion\r\n    int level = MAX_LEVELS - 1;\r\n\r\n```",
      "created_at": "2025-02-14T16:46:28Z",
      "updated_at": "2025-02-14T17:37:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956442485",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956442485"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956478391",
      "pull_request_review_id": 2618143580,
      "id": 1956478391,
      "node_id": "PRRC_kwDOABII5850nX23",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Should be set to avoid duplicates, will prevent de duplicating later on?",
      "created_at": "2025-02-14T17:11:11Z",
      "updated_at": "2025-02-14T17:36:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956478391",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956478391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 518,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956616116",
      "pull_request_review_id": 2612580796,
      "id": 1956616116,
      "node_id": "PRRC_kwDOABII5850n5e0",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed are conflicts.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 314,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i.e., any `(P, R)`? If so, putting in comment would be nice",
      "created_at": "2025-02-14T19:18:32Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956616116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956616116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 532,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956616502",
      "pull_request_review_id": 2612580796,
      "id": 1956616502,
      "node_id": "PRRC_kwDOABII5850n5k2",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed are conflicts.\n+    for (auto i : m_clustersets[level].m_removed) {\n+        auto& entry = m_entries[i];\n+        Assume(entry.m_locator[level - 1].IsPresent());\n+        ret.push_back(entry.m_locator[level - 1].cluster);\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 320,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "i.e., any `(P, P)`? If so, putting in comment would be nice",
      "created_at": "2025-02-14T19:19:00Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956616502",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956616502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956629703",
      "pull_request_review_id": 2612580796,
      "id": 1956629703,
      "node_id": "PRRC_kwDOABII5850n8zH",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed are conflicts.\n+    for (auto i : m_clustersets[level].m_removed) {\n+        auto& entry = m_entries[i];\n+        Assume(entry.m_locator[level - 1].IsPresent());\n+        ret.push_back(entry.m_locator[level - 1].cluster);\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts.\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& clusters = m_clustersets[level].m_clusters[quality];\n+        for (const auto& cluster : clusters) {\n+            cluster->GetConflicts(*this, ret);\n+        }\n+    }\n+    // Deduplicate the result (the same Cluster may appear multiple times).\n+    std::sort(ret.begin(), ret.end());\n+    ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+    return ret;\n+}\n+\n+Cluster* Cluster::CopyTo(TxGraphImpl& graph, int to_level) const noexcept\n+{\n+    // Construct an empty Cluster.\n+    auto ret = std::make_unique<Cluster>();\n+    auto ptr = ret.get();\n+    // Copy depgraph, mapping, and linearization/\n+    ptr->m_depgraph = m_depgraph;\n+    ptr->m_mapping = m_mapping;\n+    ptr->m_linearization = m_linearization;\n+    // Insert the new Cluster into the graph.\n+    graph.InsertCluster(to_level, std::move(ret), m_quality);\n+    // Update its Locators (and possibly linearization data in its Entrys).",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 344,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> and possibly linearization data\r\n\r\ne.g. when `to_level` is 0 and is otherwise acceptable?",
      "created_at": "2025-02-14T19:31:51Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956629703",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956629703"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 563,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956634721",
      "pull_request_review_id": 2612580796,
      "id": 1956634721,
      "node_id": "PRRC_kwDOABII5850n-Bh",
      "diff_hunk": "@@ -90,6 +95,17 @@ class Cluster\n     void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n     /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n     void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 39,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I find this slightly clearer since txns can still exist somewhere\r\n```Suggestion\r\n    /** Remove all transactions from a Cluster. */\r\n```",
      "created_at": "2025-02-14T19:36:59Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956634721",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956634721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956656638",
      "pull_request_review_id": 2612580796,
      "id": 1956656638,
      "node_id": "PRRC_kwDOABII5850oDX-",
      "diff_hunk": "@@ -603,56 +755,102 @@ std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, Clust\n     return ret;\n }\n \n-ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n {\n     // Cannot insert with quality level NONE (as that would mean not inserted).\n     Assume(quality != QualityLevel::NONE);\n     // The passed-in Cluster must not currently be in the TxGraphImpl.\n     Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Append it at the end of the relevant TxGraphImpl::m_cluster.\n-    auto& quality_clusters = m_clusterset.m_clusters[int(quality)];\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n     ClusterSetIndex ret = quality_clusters.size();\n     cluster->m_quality = quality;\n     cluster->m_setindex = ret;\n+    cluster->m_level = level;\n     quality_clusters.push_back(std::move(cluster));\n     return ret;\n }\n \n-void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n {\n     Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Don't do anything if the quality did not change.\n     if (old_quality == new_quality) return;\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n     // And re-insert it where it belongs.\n-    InsertCluster(std::move(cluster_ptr), new_quality);\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n }\n \n void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n {\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n     // And throw it away.\n     cluster_ptr.reset();\n }\n \n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster) noexcept\n+{\n+    int to_level = m_clustersets.size() - 1;\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from the level it was found at to higher levels, if any.\n+    while (level < to_level) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing doable work later.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 558,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "micro-nit: `immediately doable`",
      "created_at": "2025-02-14T19:59:29Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956656638",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956656638"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 905,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956664367",
      "pull_request_review_id": 2612580796,
      "id": 1956664367,
      "node_id": "PRRC_kwDOABII5850oFQv",
      "diff_hunk": "@@ -603,56 +755,102 @@ std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, Clust\n     return ret;\n }\n \n-ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n {\n     // Cannot insert with quality level NONE (as that would mean not inserted).\n     Assume(quality != QualityLevel::NONE);\n     // The passed-in Cluster must not currently be in the TxGraphImpl.\n     Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Append it at the end of the relevant TxGraphImpl::m_cluster.\n-    auto& quality_clusters = m_clusterset.m_clusters[int(quality)];\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n     ClusterSetIndex ret = quality_clusters.size();\n     cluster->m_quality = quality;\n     cluster->m_setindex = ret;\n+    cluster->m_level = level;\n     quality_clusters.push_back(std::move(cluster));\n     return ret;\n }\n \n-void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n {\n     Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Don't do anything if the quality did not change.\n     if (old_quality == new_quality) return;\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n     // And re-insert it where it belongs.\n-    InsertCluster(std::move(cluster_ptr), new_quality);\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n }\n \n void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n {\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n     // And throw it away.\n     cluster_ptr.reset();\n }\n \n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster) noexcept\n+{\n+    int to_level = m_clustersets.size() - 1;\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from the level it was found at to higher levels, if any.\n+    while (level < to_level) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing doable work later.\n+        MakeAcceptable(*cluster);\n+        ++level;\n+        auto new_cluster = cluster->CopyTo(*this, level);\n+        cluster = new_cluster;\n+    }\n+    return cluster;\n+}\n+\n void TxGraphImpl::ApplyRemovals() noexcept\n {\n-    auto& clusterset = m_clusterset;\n+    int level = m_clustersets.size() - 1;\n+    auto& clusterset = m_clustersets[level];\n     auto& to_remove = clusterset.m_to_remove;\n     // Skip if there is nothing to remove.\n     if (to_remove.empty()) return;\n+    // Pull in all Clusters that are not in the top ClusterSet.\n+    for (GraphIndex index : clusterset.m_to_remove) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 576,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n    for (GraphIndex index : to_remove) {\r\n```\r\nand elsewhere so we're only looking at two different `to_remove*` things vs three?",
      "created_at": "2025-02-14T20:06:57Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956664367",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956664367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 842,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785027",
      "pull_request_review_id": 2618915291,
      "id": 1956785027,
      "node_id": "PRRC_kwDOABII5850oiuD",
      "diff_hunk": "@@ -997,6 +1018,7 @@ void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n     m_group_data.reset();\n     // Remember that this dependency is to be applied.\n     m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+    m_group_data.reset();",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 113,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "370c419c330ca73d9ea44a7d48506a5c203e9c17",
      "in_reply_to_id": 1955149722,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed, fixed.",
      "created_at": "2025-02-14T22:28:19Z",
      "updated_at": "2025-02-14T22:28:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956785027",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785027"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1021,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785498",
      "pull_request_review_id": 2618916123,
      "id": 1956785498,
      "node_id": "PRRC_kwDOABII5850oi1a",
      "diff_hunk": "@@ -317,23 +317,27 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n         auto& entry = graph.m_entries[m_mapping[idx]];\n         entry.m_locator.SetPresent(this, idx);\n     }\n-\n-    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n-    LinearizationChunking chunking(m_depgraph, m_linearization);\n-    LinearizationIndex lin_idx{0};\n-    // Iterate over the chunks.\n-    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n-        auto chunk = chunking.GetChunk(chunk_idx);\n-        Assume(chunk.transactions.Any());\n-        // Iterate over the transactions in the linearization, which must match those in chunk.\n-        do {\n-            DepGraphIndex idx = m_linearization[lin_idx++];\n-            GraphIndex graph_idx = m_mapping[idx];\n-            auto& entry = graph.m_entries[graph_idx];\n-            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n-            Assume(chunk.transactions[idx]);\n-            chunk.transactions.Reset(idx);\n-        } while(chunk.transactions.Any());\n+    // If the Cluster's quality is ACCEPTABLE or OPTIMAL, compute its chunking and store its\n+    // information in the Entry's m_chunk_feerate. These fields are only accessed after making\n+    // the entire graph ACCEPTABLE, so it is pointless to compute these if we haven't reached that\n+    // quality level yet.\n+    if (m_quality == QualityLevel::OPTIMAL || m_quality == QualityLevel::ACCEPTABLE) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "30d7c8ce7f34e977238d1454dd032196cbfd936b",
      "in_reply_to_id": 1955245898,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I have actually added a bunch of functions (`IsAcceptable()`, `IsOptimal()`, `NeedsSplitting()`, and further on also `IsOversized()`) and mostly rewritten the long conditions involving `m_quality` to use these functions instead.",
      "created_at": "2025-02-14T22:29:08Z",
      "updated_at": "2025-02-14T22:29:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956785498",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785498"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 324,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785650",
      "pull_request_review_id": 2618916357,
      "id": 1956785650,
      "node_id": "PRRC_kwDOABII5850oi3y",
      "diff_hunk": "@@ -252,16 +305,21 @@ class TxGraphImpl final : public TxGraph\n \n     /** Swap the Entrys referred to by a and b. */\n     void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n-    /** Extract a Cluster. */\n-    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly or implicitly), return the",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 171,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956343988,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I have expanded on this. LMK if it's clearer now.",
      "created_at": "2025-02-14T22:29:24Z",
      "updated_at": "2025-02-14T22:29:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956785650",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785706",
      "pull_request_review_id": 2618916446,
      "id": 1956785706,
      "node_id": "PRRC_kwDOABII5850oi4q",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n         /** Total number of transactions in this graph (sum of all transaction counts in all\n-         *  Clusters). */\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n         GraphIndex m_txcount{0};\n     };\n \n-    /** The ClusterSet for this TxGraphImpl. */\n-    ClusterSet m_clusterset;\n-\n-    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing: not present in a Cluster at that level. For main, this means the transaction\n+     *               does not exist. For staging this means it its existence is inherited from\n+     *               main. If it doesn't exist in main, it doesn't exist in staging either. If it\n+     *               does existing in main, the cluster it is in is unmodified in staging.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 99,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956359892,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-14T22:29:30Z",
      "updated_at": "2025-02-14T22:29:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956785706",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956785706"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956786541",
      "pull_request_review_id": 2618917844,
      "id": 1956786541,
      "node_id": "PRRC_kwDOABII5850ojFt",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n         /** Total number of transactions in this graph (sum of all transaction counts in all\n-         *  Clusters). */\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n         GraphIndex m_txcount{0};\n     };\n \n-    /** The ClusterSet for this TxGraphImpl. */\n-    ClusterSet m_clusterset;\n-\n-    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing: not present in a Cluster at that level. For main, this means the transaction\n+     *               does not exist. For staging this means it its existence is inherited from\n+     *               main. If it doesn't exist in main, it doesn't exist in staging either. If it\n+     *               does existing in main, the cluster it is in is unmodified in staging.\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.",
      "path": "src/txgraph.cpp",
      "position": 273,
      "original_position": 110,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956400806,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see this was a bit confusing, I have expanded the explanation.\r\n\r\nBut what I meant to convey was that (M) **in staging** means that if the transaction does not exist in main, it doesn't exist in staging either. A (P) in staging just means it exists there. LMK if the new explanation is clearer.",
      "created_at": "2025-02-14T22:30:51Z",
      "updated_at": "2025-02-14T22:30:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1956786541",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1956786541"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 273,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960020302",
      "pull_request_review_id": 2624059438,
      "id": 1960020302,
      "node_id": "PRRC_kwDOABII585004lO",
      "diff_hunk": "@@ -99,6 +99,11 @@ class TxGraph\n      *  effect. */\n     virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n \n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */",
      "path": "src/txgraph.h",
      "position": 96,
      "original_position": 6,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "88454752cdf17336573111f9a8ed0758a555fdd8",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It can be called when oversized but for staging `DoWork` it will be no-op when it is oversized.",
      "created_at": "2025-02-18T15:46:53Z",
      "updated_at": "2025-02-18T20:07:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1960020302",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960020302"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 96,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960516927",
      "pull_request_review_id": 2624909452,
      "id": 1960516927,
      "node_id": "PRRC_kwDOABII58502x0_",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956478391,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Both options are *O(n log n)*, but a vector + sorting + deduplication has much better constant factors. An `std::set` requires a separate allocation for each element, while a vector uses a single allocator for everything. Having everything in continuous memory also exploits the CPU cache better.\r\n\r\nIn theory, using an `std::unordered_map` could asymptotically faster for large numbers as it's just *O(n)*, but I suspect not for the numbers we care about. I haven't tried or benchmarked it, though.",
      "created_at": "2025-02-18T20:03:42Z",
      "updated_at": "2025-02-18T20:07:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1960516927",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960516927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 518,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960520612",
      "pull_request_review_id": 2624059438,
      "id": 1960520612,
      "node_id": "PRRC_kwDOABII58502yuk",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956478391,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Agreed, I calculated recently.\r\nThis is better.\r\n\r\nThe constant factors for GetDistinctClusters implementation using vector and then sorting is also better ðŸ‘ðŸ¾\r\nPlease resolve.",
      "created_at": "2025-02-18T20:06:37Z",
      "updated_at": "2025-02-18T20:07:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1960520612",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960520612"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 518,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960567077",
      "pull_request_review_id": 2624992130,
      "id": 1960567077,
      "node_id": "PRRC_kwDOABII58502-El",
      "diff_hunk": "@@ -99,6 +99,11 @@ class TxGraph\n      *  effect. */\n     virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n \n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */",
      "path": "src/txgraph.h",
      "position": 96,
      "original_position": 6,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "88454752cdf17336573111f9a8ed0758a555fdd8",
      "in_reply_to_id": 1960020302,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It might still do something; for example removals may be applied still, and grouping may be calculated. I feel it's unnecessary to elaborate that much about implementation details in the interface, though.",
      "created_at": "2025-02-18T20:45:09Z",
      "updated_at": "2025-02-18T20:45:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1960567077",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1960567077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 96,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964207103",
      "pull_request_review_id": 2612580796,
      "id": 1964207103,
      "node_id": "PRRC_kwDOABII5851E2v_",
      "diff_hunk": "@@ -622,56 +778,104 @@ std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, Clust\n     return ret;\n }\n \n-ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n {\n     // Cannot insert with quality level NONE (as that would mean not inserted).\n     Assume(quality != QualityLevel::NONE);\n     // The passed-in Cluster must not currently be in the TxGraphImpl.\n     Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Append it at the end of the relevant TxGraphImpl::m_cluster.\n-    auto& quality_clusters = m_clusterset.m_clusters[int(quality)];\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n     ClusterSetIndex ret = quality_clusters.size();\n     cluster->m_quality = quality;\n     cluster->m_setindex = ret;\n+    cluster->m_level = level;\n     quality_clusters.push_back(std::move(cluster));\n     return ret;\n }\n \n-void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n {\n     Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Don't do anything if the quality did not change.\n     if (old_quality == new_quality) return;\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n     // And re-insert it where it belongs.\n-    InsertCluster(std::move(cluster_ptr), new_quality);\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n }\n \n void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n {\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n     // And throw it away.\n     cluster_ptr.reset();\n }\n \n-void TxGraphImpl::ApplyRemovals() noexcept\n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 557,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "micro-nit: documentation was pretty clear in declaration, but just in case...\r\n\r\n```Suggestion\r\n        // If the locator is missing, dig deeper; it may exist at a lower level and therefore be implicitly available at this level.\r\n```",
      "created_at": "2025-02-20T19:20:04Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1964207103",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964207103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964241681",
      "pull_request_review_id": 2612580796,
      "id": 1964241681,
      "node_id": "PRRC_kwDOABII5851E_MR",
      "diff_hunk": "@@ -1176,101 +1400,201 @@ FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n     return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n {\n-    // Return the empty vector if the Ref is empty.\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Cluster linearization cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n     MakeAcceptable(*cluster);\n     return cluster->GetClusterRefs(*this);\n }\n \n-TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n {\n-    ApplyRemovals();\n-    return m_clusterset.m_txcount;\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n }\n \n FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n-    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n-    ApplyRemovals();\n-    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n-    ApplyDependencies();\n+    ApplyDependencies(/*level=*/0);\n     // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n     // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n     // chunk feerate.\n     MakeAcceptable(*cluster);\n     const auto& entry = m_entries[GetRefIndex(arg)];\n-    return entry.m_chunk_feerate;\n+    return entry.m_main_chunk_feerate;\n }\n \n-bool TxGraphImpl::IsOversized() noexcept\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n {\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n     // Find which Clusters will need to be merged together, as that is where the oversize\n     // property is assessed.\n-    GroupClusters();\n-    Assume(m_clusterset.m_group_data.has_value());\n-    return m_clusterset.m_group_data->m_group_oversized;\n+    GroupClusters(level);\n+    Assume(m_clustersets[level].m_group_data.has_value());\n+    return m_clustersets[level].m_group_data->m_group_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized),\n+    // do all merging work now. This also involves applying all removals.\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark are removed transactions as Missing (so the stage_level locator for these transactions",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1058,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "s/Mark are/Mark all/",
      "created_at": "2025-02-20T19:48:09Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1964241681",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964241681"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964244998",
      "pull_request_review_id": 2612580796,
      "id": 1964244998,
      "node_id": "PRRC_kwDOABII5851FAAG",
      "diff_hunk": "@@ -1176,101 +1400,201 @@ FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n     return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n {\n-    // Return the empty vector if the Ref is empty.\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Cluster linearization cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n     MakeAcceptable(*cluster);\n     return cluster->GetClusterRefs(*this);\n }\n \n-TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n {\n-    ApplyRemovals();\n-    return m_clusterset.m_txcount;\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n }\n \n FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n-    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n-    ApplyRemovals();\n-    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n-    ApplyDependencies();\n+    ApplyDependencies(/*level=*/0);\n     // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n     // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n     // chunk feerate.\n     MakeAcceptable(*cluster);\n     const auto& entry = m_entries[GetRefIndex(arg)];\n-    return entry.m_chunk_feerate;\n+    return entry.m_main_chunk_feerate;\n }\n \n-bool TxGraphImpl::IsOversized() noexcept\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n {\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n     // Find which Clusters will need to be merged together, as that is where the oversize\n     // property is assessed.\n-    GroupClusters();\n-    Assume(m_clusterset.m_group_data.has_value());\n-    return m_clusterset.m_group_data->m_group_oversized;\n+    GroupClusters(level);\n+    Assume(m_clustersets[level].m_group_data.has_value());\n+    return m_clustersets[level].m_group_data->m_group_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized),\n+    // do all merging work now. This also involves applying all removals.\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark are removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created).\n+    for (auto idx : stage.m_removed) {\n+        m_entries[idx].m_locator[stage_level].SetMissing();",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1061,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "```Suggestion\r\n        Assume(m_entries[idx].m_locator[stage_level].IsRemoved());\r\n        m_entries[idx].m_locator[stage_level].SetMissing();\r\n```",
      "created_at": "2025-02-20T19:50:44Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1964244998",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964244998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1717,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964248901",
      "pull_request_review_id": 2612580796,
      "id": 1964248901,
      "node_id": "PRRC_kwDOABII5851FA9F",
      "diff_hunk": "@@ -1176,101 +1400,201 @@ FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n     return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n {\n-    // Return the empty vector if the Ref is empty.\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Cluster linearization cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n     MakeAcceptable(*cluster);\n     return cluster->GetClusterRefs(*this);\n }\n \n-TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n {\n-    ApplyRemovals();\n-    return m_clusterset.m_txcount;\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n }\n \n FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n-    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n-    ApplyRemovals();\n-    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n-    ApplyDependencies();\n+    ApplyDependencies(/*level=*/0);\n     // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n     // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n     // chunk feerate.\n     MakeAcceptable(*cluster);\n     const auto& entry = m_entries[GetRefIndex(arg)];\n-    return entry.m_chunk_feerate;\n+    return entry.m_main_chunk_feerate;\n }\n \n-bool TxGraphImpl::IsOversized() noexcept\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n {\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n     // Find which Clusters will need to be merged together, as that is where the oversize\n     // property is assessed.\n-    GroupClusters();\n-    Assume(m_clusterset.m_group_data.has_value());\n-    return m_clusterset.m_group_data->m_group_oversized;\n+    GroupClusters(level);\n+    Assume(m_clustersets[level].m_group_data.has_value());\n+    return m_clustersets[level].m_group_data->m_group_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized),\n+    // do all merging work now. This also involves applying all removals.\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark are removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created).",
      "path": "src/txgraph.cpp",
      "position": 1760,
      "original_position": 1059,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "it's an array of `Locator`s, so what else could have been done here? Might be reading too much into this comment.",
      "created_at": "2025-02-20T19:54:06Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1964248901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964248901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1760,
      "original_line": 1760,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964276025",
      "pull_request_review_id": 2612580796,
      "id": 1964276025,
      "node_id": "PRRC_kwDOABII5851FHk5",
      "diff_hunk": "@@ -1755,6 +1774,11 @@ void TxGraphImpl::SanityCheck() const\n         if (!clusterset.m_deps_to_add.empty()) compact_possible = false;\n         if (!clusterset.m_to_remove.empty()) compact_possible = false;\n         if (!clusterset.m_removed.empty()) compact_possible = false;\n+\n+        // If m_group_data exists, its m_group_oversized must match m_oversized.\n+        if (clusterset.m_group_data.has_value()) {\n+            assert(clusterset.m_oversized == clusterset.m_group_data->m_group_oversized);",
      "path": "src/txgraph.cpp",
      "position": 2057,
      "original_position": 100,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "07632d6ce09eb3293a255d34703638af69c5dd7c",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "should check that `clusterset.m_oversized.has_value()`?",
      "created_at": "2025-02-20T20:12:44Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1964276025",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964276025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2057,
      "original_line": 2057,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964316237",
      "pull_request_review_id": 2612580796,
      "id": 1964316237,
      "node_id": "PRRC_kwDOABII5851FRZN",
      "diff_hunk": "@@ -303,6 +303,8 @@ class TxGraphImpl final : public TxGraph\n         Locator m_locator[MAX_LEVELS];\n         /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n         FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */",
      "path": "src/txgraph.cpp",
      "position": 308,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "fdd68be0ac6c7fa1c253e750df56853e1f97ca98",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This value is set to -1, sometimes, but never acted on with that value. Noting in case you have thoughts on that.",
      "created_at": "2025-02-20T20:48:08Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1964316237",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1964316237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 308,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1965825553",
      "pull_request_review_id": 2612580796,
      "id": 1965825553,
      "node_id": "PRRC_kwDOABII5851LB4R",
      "diff_hunk": "@@ -143,10 +143,16 @@ class TxGraph\n      *  staging graph exists, it is queried; otherwise the main graph is queried. The queried\n      *  graph must not be oversized. Returns {} if arg does not exist in the queried graph. */\n     virtual std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Like GetAncestors, but return the Refs for all transactions in the union of the provided\n+     *  arguments' ancestors (each transaction is only reported once). */\n+    virtual std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept = 0;\n     /** Get pointers to all descendants of the specified transaction. If main_only is false and a\n      *  staging graph exists, it is queried; otherwise the main graph is queried. The queried\n      *  graph must not be oversized. Returns {} if arg does not exist in the queried graph. */\n     virtual std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Like GetDescendants, but return the Refs for all transactions in the union of the provided",
      "path": "src/txgraph.h",
      "position": 149,
      "original_position": 11,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "11135464c5c3aef1ce8d2823120467a522ce2c87",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "nit: might be worthwhile to mention in this and elsewhere that results will be unique",
      "created_at": "2025-02-21T16:32:46Z",
      "updated_at": "2025-02-21T17:07:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1965825553",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1965825553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966157404",
      "pull_request_review_id": 2634198161,
      "id": 1966157404,
      "node_id": "PRRC_kwDOABII5851MS5c",
      "diff_hunk": "@@ -1110,6 +1121,106 @@ void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n     }\n }\n \n+void Cluster::SanityCheck(const TxGraphImpl& graph) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator.cluster == this);\n+        assert(entry.m_locator.index == lin_pos);\n+        // Check linearization position and chunk feerate.\n+        if (!linchunking.GetChunk(0).transactions[lin_pos]) {\n+            linchunking.MarkDone(linchunking.GetChunk(0).transactions);\n+        }\n+        assert(entry.m_chunk_feerate == linchunking.GetChunk(0).feerate);\n+        // If this Cluster has an acceptable quality level, its chunks must be connected.\n+        if (m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL) {\n+            assert(m_depgraph.IsConnected(linchunking.GetChunk(0).transactions));\n+        }\n+    }\n+    // Verify that each element of m_depgraph occured in m_linearization.\n+    assert(m_done == m_depgraph.Positions());\n+}\n+\n+void TxGraphImpl::SanityCheck() const\n+{\n+    /** Which GraphIndexes ought to occur in m_wiped, based on m_entries. */\n+    std::set<GraphIndex> expected_unlinked;\n+    /** Which Clusters ought to occur in m_clusters, based on m_entries. */\n+    std::set<const Cluster*> expected_clusters;\n+\n+    // Go over all Entry objects in m_entries.\n+    for (GraphIndex idx = 0; idx < m_entries.size(); ++idx) {\n+        const auto& entry = m_entries[idx];\n+        if (entry.m_ref == nullptr) {\n+            // Unlinked Entry must have indexes appear in m_unlinked.\n+            expected_unlinked.insert(idx);\n+        } else {\n+            // Every non-unlinked Entry must have a Ref that points back to it.\n+            assert(GetRefGraph(*entry.m_ref) == this);\n+            assert(GetRefIndex(*entry.m_ref) == idx);\n+        }\n+        const auto& locator = entry.m_locator;\n+        // Every Locator must be in exactly one of these 2 states.\n+        assert(locator.IsMissing() + locator.IsPresent() == 1);\n+        if (locator.IsPresent()) {\n+            // Verify that the Cluster agrees with where the Locator claims the transaction is.\n+            assert(locator.cluster->GetClusterEntry(locator.index) == idx);\n+            // Remember that we expect said Cluster to appear in the m_clusters.\n+            expected_clusters.insert(locator.cluster);\n+        }\n+\n+    }\n+\n+    std::set<const Cluster*> actual_clusters;\n+    // For all quality levels...\n+    for (int qual = 0; qual < int(QualityLevel::NONE); ++qual) {\n+        QualityLevel quality{qual};\n+        const auto& quality_clusters = m_clusters[qual];\n+        // ... for all clusters in them ...\n+        for (ClusterSetIndex setindex = 0; setindex < quality_clusters.size(); ++setindex) {\n+            const auto& cluster = *quality_clusters[setindex];\n+            // Remember we saw this Cluster (only if it is non-empty; empty Clusters aren't\n+            // expected to be referenced by the Entry vector).\n+            if (cluster.GetTxCount() != 0) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 127,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "741a6a8c4d851cb10ecee810a09187bcbfa5af4c",
      "in_reply_to_id": 1953324216,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed. Empty clusters can only exist in after an `ApplyRemovals` but before a `SplitAll()`. After oversizedness caching, `ApplyDependencies` may end up not calling `SplitAll()`, though, if the result is known to be oversized already.",
      "created_at": "2025-02-21T20:55:04Z",
      "updated_at": "2025-02-21T20:55:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966157404",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966157404"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966186414",
      "pull_request_review_id": 2634249768,
      "id": 1966186414,
      "node_id": "PRRC_kwDOABII5851MZ-u",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956359627,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think the most accurate description is \"All entries which have an (R) removed locator at this level, plus any transactions in m_unlinked\". Would that help?",
      "created_at": "2025-02-21T21:20:27Z",
      "updated_at": "2025-02-21T21:20:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966186414",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966186414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264189",
      "pull_request_review_id": 2634380073,
      "id": 1966264189,
      "node_id": "PRRC_kwDOABII5851Ms99",
      "diff_hunk": "@@ -143,10 +143,16 @@ class TxGraph\n      *  staging graph exists, it is queried; otherwise the main graph is queried. The queried\n      *  graph must not be oversized. Returns {} if arg does not exist in the queried graph. */\n     virtual std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Like GetAncestors, but return the Refs for all transactions in the union of the provided\n+     *  arguments' ancestors (each transaction is only reported once). */\n+    virtual std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept = 0;\n     /** Get pointers to all descendants of the specified transaction. If main_only is false and a\n      *  staging graph exists, it is queried; otherwise the main graph is queried. The queried\n      *  graph must not be oversized. Returns {} if arg does not exist in the queried graph. */\n     virtual std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Like GetDescendants, but return the Refs for all transactions in the union of the provided",
      "path": "src/txgraph.h",
      "position": 149,
      "original_position": 11,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "11135464c5c3aef1ce8d2823120467a522ce2c87",
      "in_reply_to_id": 1965825553,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It says \"(each transaction is only reported once)\", is that not what you mean?",
      "created_at": "2025-02-21T22:10:46Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966264189",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264189"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264402",
      "pull_request_review_id": 2634380073,
      "id": 1966264402,
      "node_id": "PRRC_kwDOABII5851MtBS",
      "diff_hunk": "@@ -311,7 +311,7 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         auto& locator = entry.m_locator;\n         // Stop once we hit an entry that applies to another Cluster.\n         if (locator.cluster != this) break;\n-        // - Remember it in a set of to-remove ClusterIndexes.\n+        // - Remember it in a set of to-remove DepGraphIndexes.",
      "path": "src/txgraph.cpp",
      "position": 605,
      "original_position": 5,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953038482,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-21T22:11:02Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966264402",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264402"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 605,
      "original_line": 605,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264497",
      "pull_request_review_id": 2634380073,
      "id": 1966264497,
      "node_id": "PRRC_kwDOABII5851MtCx",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 172,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953051233,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This has been rewritten already.",
      "created_at": "2025-02-21T22:11:12Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966264497",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264497"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 172,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264642",
      "pull_request_review_id": 2634380073,
      "id": 1966264642,
      "node_id": "PRRC_kwDOABII5851MtFC",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953086802,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Removed it.",
      "created_at": "2025-02-21T22:11:24Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966264642",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264642"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264980",
      "pull_request_review_id": 2634380073,
      "id": 1966264980,
      "node_id": "PRRC_kwDOABII5851MtKU",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 306,
      "original_position": 215,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953094059,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "It's mostly to avoid consuming 12 bytes from the fuzz data for every transaction; added a comment.",
      "created_at": "2025-02-21T22:11:51Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966264980",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966264980"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 306,
      "original_line": 306,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966265505",
      "pull_request_review_id": 2634380073,
      "id": 1966265505,
      "node_id": "PRRC_kwDOABII5851MtSh",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {\n+                    fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                } else {\n+                    fee = provider.ConsumeIntegral<uint8_t>();\n+                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                }\n+                FeePerWeight feerate{fee, size};\n+                // Create a real TxGraph::Ref.\n+                auto ref = real->AddTransaction(feerate);\n+                // Create a unique_ptr place in the simulation to put the Ref in.\n+                auto ref_loc = sim.AddTransaction(feerate);\n+                // Move it in place.\n+                *ref_loc = std::move(ref);\n+                break;\n+            } else if (sim.GetTransactionCount() + sim.removed.size() > 1 && command-- == 0) {\n+                // AddDependency.\n+                auto par = pick_fn();\n+                auto chl = pick_fn();\n+                auto pos_par = sim.Find(par);\n+                auto pos_chl = sim.Find(chl);\n+                if (pos_par != SimTxGraph::MISSING && pos_chl != SimTxGraph::MISSING) {\n+                    // Determine if adding this would introduce a cycle (not allowed by TxGraph),\n+                    // and if so, skip.\n+                    if (sim.graph.Ancestors(pos_par)[pos_chl]) break;\n+                    // Determine if adding this would violate CLUSTER_COUNT_LIMIT, and if so, skip.\n+                    auto temp_depgraph = sim.graph;\n+                    temp_depgraph.AddDependencies(SimTxGraph::SetType::Singleton(pos_par), pos_chl);\n+                    auto todo = temp_depgraph.Positions();\n+                    bool oversize{false};\n+                    while (todo.Any()) {\n+                        auto component = temp_depgraph.FindConnectedComponent(todo);\n+                        if (component.Count() > CLUSTER_COUNT_LIMIT) oversize = true;\n+                        todo -= component;\n+                    }\n+                    if (oversize) break;\n+                }\n+                sim.AddDependency(par, chl);\n+                real->AddDependency(*par, *chl);\n+                break;\n+            } else if (sim.removed.size() < 100 && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 255,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953110215,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This dates from a time when the fuzz test allowed up to 1000 steps, and it felt unnecessary to support cases with unboundedly growing numbers of removed transactions. I've just dropped it.",
      "created_at": "2025-02-21T22:12:34Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966265505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966265505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 255,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966266151",
      "pull_request_review_id": 2634380073,
      "id": 1966266151,
      "node_id": "PRRC_kwDOABII5851Mtcn",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {\n+                    fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                } else {\n+                    fee = provider.ConsumeIntegral<uint8_t>();\n+                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                }\n+                FeePerWeight feerate{fee, size};\n+                // Create a real TxGraph::Ref.\n+                auto ref = real->AddTransaction(feerate);\n+                // Create a unique_ptr place in the simulation to put the Ref in.\n+                auto ref_loc = sim.AddTransaction(feerate);\n+                // Move it in place.\n+                *ref_loc = std::move(ref);\n+                break;\n+            } else if (sim.GetTransactionCount() + sim.removed.size() > 1 && command-- == 0) {\n+                // AddDependency.\n+                auto par = pick_fn();\n+                auto chl = pick_fn();\n+                auto pos_par = sim.Find(par);\n+                auto pos_chl = sim.Find(chl);\n+                if (pos_par != SimTxGraph::MISSING && pos_chl != SimTxGraph::MISSING) {\n+                    // Determine if adding this would introduce a cycle (not allowed by TxGraph),\n+                    // and if so, skip.\n+                    if (sim.graph.Ancestors(pos_par)[pos_chl]) break;\n+                    // Determine if adding this would violate CLUSTER_COUNT_LIMIT, and if so, skip.\n+                    auto temp_depgraph = sim.graph;\n+                    temp_depgraph.AddDependencies(SimTxGraph::SetType::Singleton(pos_par), pos_chl);\n+                    auto todo = temp_depgraph.Positions();\n+                    bool oversize{false};\n+                    while (todo.Any()) {\n+                        auto component = temp_depgraph.FindConnectedComponent(todo);\n+                        if (component.Count() > CLUSTER_COUNT_LIMIT) oversize = true;\n+                        todo -= component;\n+                    }\n+                    if (oversize) break;\n+                }\n+                sim.AddDependency(par, chl);\n+                real->AddDependency(*par, *chl);\n+                break;\n+            } else if (sim.removed.size() < 100 && command-- == 0) {\n+                // RemoveTransaction. Either all its ancestors or all its descendants are also\n+                // removed (if any), to make sure TxGraph's reordering of removals and dependencies\n+                // has no effect.\n+                std::vector<TxGraph::Ref*> to_remove;\n+                to_remove.push_back(pick_fn());\n+                sim.IncludeAncDesc(to_remove, alt);\n+                // The order in which these ancestors/descendants are removed should not matter;\n+                // randomly shuffle them.\n+                std::shuffle(to_remove.begin(), to_remove.end(), rng);\n+                for (TxGraph::Ref* ptr : to_remove) {\n+                    real->RemoveTransaction(*ptr);\n+                    sim.RemoveTransaction(ptr);\n+                }\n+                break;\n+            } else if (sim.removed.size() > 0 && command-- == 0) {\n+                // ~Ref",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 271,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953122407,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've added a comment. `~Ref` triggers observable behavior in TxGraph, so the simulation controls when it gets called (and its ordering w.r.t. other operations).",
      "created_at": "2025-02-21T22:13:15Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966266151",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966266151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966266270",
      "pull_request_review_id": 2634380073,
      "id": 1966266270,
      "node_id": "PRRC_kwDOABII5851Mtee",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {\n+        // Read a one-byte command.\n+        int command = provider.ConsumeIntegral<uint8_t>();\n+        // Treat it lowest bit as a flag (which selects a variant of some of the operations), and\n+        // leave the rest of the bits in command.\n+        bool alt = command & 1;\n+        command >>= 1;\n+\n+        // Keep decrementing command for each applicable operation, until one is hit. Multiple\n+        // iterations may be necessary.\n+        while (true) {\n+            if (sim.GetTransactionCount() < SimTxGraph::MAX_TRANSACTIONS && command-- == 0) {\n+                // AddTransaction.\n+                int64_t fee;\n+                int32_t size;\n+                if (alt) {\n+                    fee = provider.ConsumeIntegralInRange<int64_t>(-0x8000000000000, 0x7ffffffffffff);\n+                    size = provider.ConsumeIntegralInRange<int32_t>(1, 0x3fffff);\n+                } else {\n+                    fee = provider.ConsumeIntegral<uint8_t>();\n+                    size = provider.ConsumeIntegral<uint8_t>() + 1;\n+                }\n+                FeePerWeight feerate{fee, size};\n+                // Create a real TxGraph::Ref.\n+                auto ref = real->AddTransaction(feerate);\n+                // Create a unique_ptr place in the simulation to put the Ref in.\n+                auto ref_loc = sim.AddTransaction(feerate);\n+                // Move it in place.\n+                *ref_loc = std::move(ref);\n+                break;\n+            } else if (sim.GetTransactionCount() + sim.removed.size() > 1 && command-- == 0) {\n+                // AddDependency.\n+                auto par = pick_fn();\n+                auto chl = pick_fn();\n+                auto pos_par = sim.Find(par);\n+                auto pos_chl = sim.Find(chl);\n+                if (pos_par != SimTxGraph::MISSING && pos_chl != SimTxGraph::MISSING) {\n+                    // Determine if adding this would introduce a cycle (not allowed by TxGraph),\n+                    // and if so, skip.\n+                    if (sim.graph.Ancestors(pos_par)[pos_chl]) break;\n+                    // Determine if adding this would violate CLUSTER_COUNT_LIMIT, and if so, skip.\n+                    auto temp_depgraph = sim.graph;\n+                    temp_depgraph.AddDependencies(SimTxGraph::SetType::Singleton(pos_par), pos_chl);\n+                    auto todo = temp_depgraph.Positions();\n+                    bool oversize{false};\n+                    while (todo.Any()) {\n+                        auto component = temp_depgraph.FindConnectedComponent(todo);\n+                        if (component.Count() > CLUSTER_COUNT_LIMIT) oversize = true;\n+                        todo -= component;\n+                    }\n+                    if (oversize) break;\n+                }\n+                sim.AddDependency(par, chl);\n+                real->AddDependency(*par, *chl);\n+                break;\n+            } else if (sim.removed.size() < 100 && command-- == 0) {\n+                // RemoveTransaction. Either all its ancestors or all its descendants are also\n+                // removed (if any), to make sure TxGraph's reordering of removals and dependencies\n+                // has no effect.\n+                std::vector<TxGraph::Ref*> to_remove;\n+                to_remove.push_back(pick_fn());\n+                sim.IncludeAncDesc(to_remove, alt);\n+                // The order in which these ancestors/descendants are removed should not matter;\n+                // randomly shuffle them.\n+                std::shuffle(to_remove.begin(), to_remove.end(), rng);\n+                for (TxGraph::Ref* ptr : to_remove) {\n+                    real->RemoveTransaction(*ptr);\n+                    sim.RemoveTransaction(ptr);\n+                }\n+                break;\n+            } else if (sim.removed.size() > 0 && command-- == 0) {\n+                // ~Ref\n+                // Pick a Ref of sim.removed to destroy.\n+                auto removed_pos = provider.ConsumeIntegralInRange<size_t>(0, sim.removed.size() - 1);\n+                if (removed_pos != sim.removed.size() - 1) {\n+                    std::swap(sim.removed[removed_pos], sim.removed.back());\n+                }\n+                sim.removed.pop_back();\n+                break;\n+            } else if (sim.GetTransactionCount() > 0 && command-- == 0) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": null,
      "original_position": 279,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953123706,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Fixed.",
      "created_at": "2025-02-21T22:13:22Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966266270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966266270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966267798",
      "pull_request_review_id": 2634380073,
      "id": 1966267798,
      "node_id": "PRRC_kwDOABII5851Mt2W",
      "diff_hunk": "@@ -799,25 +808,29 @@ void TxGraphImpl::GroupClusters() noexcept\n         // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n         // and the input dependencies, annotated with the representative of the Cluster partition\n         // it applies to.\n+        an_deps.reserve(m_deps_to_add.size());\n+        auto deps_it = m_deps_to_add.begin();\n         for (size_t i = 0; i < partition_data.size(); ++i) {\n             auto& data = partition_data[i];\n             // Find the representative of the partition Cluster i is in, and store it with the\n             // Cluster.\n             auto rep = find_root_fn(&data)->cluster;\n             Assume(an_clusters[i].second == nullptr);\n             an_clusters[i].second = rep;\n-        }\n-        an_deps.reserve(m_deps_to_add.size());\n-        for (auto [par, chl] : m_deps_to_add) {\n-            auto chl_cluster = m_entries[chl].m_locator.cluster;\n-            auto par_cluster = m_entries[par].m_locator.cluster;\n-            // Nothing to do if either parent or child transaction is removed already.\n-            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n-            // Find the representative of the partition which this dependency's child is in (which\n-            // should be the same as the one for the parent).\n-            auto rep = find_root_fn(locate_fn(chl_cluster))->cluster;\n-            // Create an_deps entry.\n-            an_deps.emplace_back(std::pair{par, chl}, rep);\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = m_entries[chl].m_locator.cluster;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (!std::less{}(chl_cluster, data.cluster)) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 47,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "56cbdd7889e957c29d76681c46c4a7a6983c9be6",
      "in_reply_to_id": 1954986316,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done, largely.",
      "created_at": "2025-02-21T22:15:08Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966267798",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966267798"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966267984",
      "pull_request_review_id": 2634380073,
      "id": 1966267984,
      "node_id": "PRRC_kwDOABII5851Mt5Q",
      "diff_hunk": "@@ -260,6 +260,8 @@ class TxGraphImpl final : public TxGraph\n     ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n     /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n     void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1b207547a99afccd52e3ecfb801af1d9bab7f2b8",
      "in_reply_to_id": 1956309054,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-21T22:15:23Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966267984",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966267984"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966270532",
      "pull_request_review_id": 2634380073,
      "id": 1966270532,
      "node_id": "PRRC_kwDOABII5851MuhE",
      "diff_hunk": "@@ -90,6 +95,17 @@ class Cluster\n     void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n     /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n     void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956354845,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That's not quite what this does. It looks for conflicts one level below the one where the `*this` Cluster exists (in practice, that'll always be top_level-1, though). Improved the comment.",
      "created_at": "2025-02-21T22:18:35Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966270532",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966270532"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966270811",
      "pull_request_review_id": 2634380073,
      "id": 1966270811,
      "node_id": "PRRC_kwDOABII5851Mulb",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed are conflicts.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 314,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956616116,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed, done.",
      "created_at": "2025-02-21T22:18:59Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966270811",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966270811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 532,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966270890",
      "pull_request_review_id": 2634380073,
      "id": 1966270890,
      "node_id": "PRRC_kwDOABII5851Mumq",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed are conflicts.\n+    for (auto i : m_clustersets[level].m_removed) {\n+        auto& entry = m_entries[i];\n+        Assume(entry.m_locator[level - 1].IsPresent());\n+        ret.push_back(entry.m_locator[level - 1].cluster);\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 320,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956616502,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Indeed, done.",
      "created_at": "2025-02-21T22:19:06Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966270890",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966270890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 539,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271206",
      "pull_request_review_id": 2634380073,
      "id": 1966271206,
      "node_id": "PRRC_kwDOABII5851Murm",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed are conflicts.\n+    for (auto i : m_clustersets[level].m_removed) {\n+        auto& entry = m_entries[i];\n+        Assume(entry.m_locator[level - 1].IsPresent());\n+        ret.push_back(entry.m_locator[level - 1].cluster);\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts.\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& clusters = m_clustersets[level].m_clusters[quality];\n+        for (const auto& cluster : clusters) {\n+            cluster->GetConflicts(*this, ret);\n+        }\n+    }\n+    // Deduplicate the result (the same Cluster may appear multiple times).\n+    std::sort(ret.begin(), ret.end());\n+    ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+    return ret;\n+}\n+\n+Cluster* Cluster::CopyTo(TxGraphImpl& graph, int to_level) const noexcept\n+{\n+    // Construct an empty Cluster.\n+    auto ret = std::make_unique<Cluster>();\n+    auto ptr = ret.get();\n+    // Copy depgraph, mapping, and linearization/\n+    ptr->m_depgraph = m_depgraph;\n+    ptr->m_mapping = m_mapping;\n+    ptr->m_linearization = m_linearization;\n+    // Insert the new Cluster into the graph.\n+    graph.InsertCluster(to_level, std::move(ret), m_quality);\n+    // Update its Locators (and possibly linearization data in its Entrys).",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 344,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956629703,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yes, but no, because `to_level` is never 0. I have just dropped it.",
      "created_at": "2025-02-21T22:19:29Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966271206",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 563,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271352",
      "pull_request_review_id": 2634380073,
      "id": 1966271352,
      "node_id": "PRRC_kwDOABII5851Mut4",
      "diff_hunk": "@@ -90,6 +95,17 @@ class Cluster\n     void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n     /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n     void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 39,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956634721,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-21T22:19:43Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966271352",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271352"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271843",
      "pull_request_review_id": 2634380073,
      "id": 1966271843,
      "node_id": "PRRC_kwDOABII5851Mu1j",
      "diff_hunk": "@@ -603,56 +755,102 @@ std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, Clust\n     return ret;\n }\n \n-ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n {\n     // Cannot insert with quality level NONE (as that would mean not inserted).\n     Assume(quality != QualityLevel::NONE);\n     // The passed-in Cluster must not currently be in the TxGraphImpl.\n     Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Append it at the end of the relevant TxGraphImpl::m_cluster.\n-    auto& quality_clusters = m_clusterset.m_clusters[int(quality)];\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n     ClusterSetIndex ret = quality_clusters.size();\n     cluster->m_quality = quality;\n     cluster->m_setindex = ret;\n+    cluster->m_level = level;\n     quality_clusters.push_back(std::move(cluster));\n     return ret;\n }\n \n-void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n {\n     Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Don't do anything if the quality did not change.\n     if (old_quality == new_quality) return;\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n     // And re-insert it where it belongs.\n-    InsertCluster(std::move(cluster_ptr), new_quality);\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n }\n \n void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n {\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n     // And throw it away.\n     cluster_ptr.reset();\n }\n \n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster) noexcept\n+{\n+    int to_level = m_clustersets.size() - 1;\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from the level it was found at to higher levels, if any.\n+    while (level < to_level) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing doable work later.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 558,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956656638,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Actually I meant \"double\", not \"doable\", I think. Fixed.",
      "created_at": "2025-02-21T22:20:28Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966271843",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271843"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 905,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271977",
      "pull_request_review_id": 2634380073,
      "id": 1966271977,
      "node_id": "PRRC_kwDOABII5851Mu3p",
      "diff_hunk": "@@ -603,56 +755,102 @@ std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, Clust\n     return ret;\n }\n \n-ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n {\n     // Cannot insert with quality level NONE (as that would mean not inserted).\n     Assume(quality != QualityLevel::NONE);\n     // The passed-in Cluster must not currently be in the TxGraphImpl.\n     Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Append it at the end of the relevant TxGraphImpl::m_cluster.\n-    auto& quality_clusters = m_clusterset.m_clusters[int(quality)];\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n     ClusterSetIndex ret = quality_clusters.size();\n     cluster->m_quality = quality;\n     cluster->m_setindex = ret;\n+    cluster->m_level = level;\n     quality_clusters.push_back(std::move(cluster));\n     return ret;\n }\n \n-void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n {\n     Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Don't do anything if the quality did not change.\n     if (old_quality == new_quality) return;\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n     // And re-insert it where it belongs.\n-    InsertCluster(std::move(cluster_ptr), new_quality);\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n }\n \n void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n {\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n     // And throw it away.\n     cluster_ptr.reset();\n }\n \n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster) noexcept\n+{\n+    int to_level = m_clustersets.size() - 1;\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from the level it was found at to higher levels, if any.\n+    while (level < to_level) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing doable work later.\n+        MakeAcceptable(*cluster);\n+        ++level;\n+        auto new_cluster = cluster->CopyTo(*this, level);\n+        cluster = new_cluster;\n+    }\n+    return cluster;\n+}\n+\n void TxGraphImpl::ApplyRemovals() noexcept\n {\n-    auto& clusterset = m_clusterset;\n+    int level = m_clustersets.size() - 1;\n+    auto& clusterset = m_clustersets[level];\n     auto& to_remove = clusterset.m_to_remove;\n     // Skip if there is nothing to remove.\n     if (to_remove.empty()) return;\n+    // Pull in all Clusters that are not in the top ClusterSet.\n+    for (GraphIndex index : clusterset.m_to_remove) {",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 576,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956664367,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-21T22:20:41Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966271977",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966271977"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 842,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966272114",
      "pull_request_review_id": 2634380073,
      "id": 1966272114,
      "node_id": "PRRC_kwDOABII5851Mu5y",
      "diff_hunk": "@@ -622,56 +778,104 @@ std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, Clust\n     return ret;\n }\n \n-ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n {\n     // Cannot insert with quality level NONE (as that would mean not inserted).\n     Assume(quality != QualityLevel::NONE);\n     // The passed-in Cluster must not currently be in the TxGraphImpl.\n     Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Append it at the end of the relevant TxGraphImpl::m_cluster.\n-    auto& quality_clusters = m_clusterset.m_clusters[int(quality)];\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n     ClusterSetIndex ret = quality_clusters.size();\n     cluster->m_quality = quality;\n     cluster->m_setindex = ret;\n+    cluster->m_level = level;\n     quality_clusters.push_back(std::move(cluster));\n     return ret;\n }\n \n-void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n {\n     Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Don't do anything if the quality did not change.\n     if (old_quality == new_quality) return;\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n     // And re-insert it where it belongs.\n-    InsertCluster(std::move(cluster_ptr), new_quality);\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n }\n \n void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n {\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n     // And throw it away.\n     cluster_ptr.reset();\n }\n \n-void TxGraphImpl::ApplyRemovals() noexcept\n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 557,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": 1964207103,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-21T22:20:52Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966272114",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966272114"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 828,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966272170",
      "pull_request_review_id": 2634380073,
      "id": 1966272170,
      "node_id": "PRRC_kwDOABII5851Mu6q",
      "diff_hunk": "@@ -1176,101 +1400,201 @@ FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n     return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n {\n-    // Return the empty vector if the Ref is empty.\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Cluster linearization cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n     MakeAcceptable(*cluster);\n     return cluster->GetClusterRefs(*this);\n }\n \n-TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n {\n-    ApplyRemovals();\n-    return m_clusterset.m_txcount;\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n }\n \n FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n-    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n-    ApplyRemovals();\n-    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n-    ApplyDependencies();\n+    ApplyDependencies(/*level=*/0);\n     // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n     // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n     // chunk feerate.\n     MakeAcceptable(*cluster);\n     const auto& entry = m_entries[GetRefIndex(arg)];\n-    return entry.m_chunk_feerate;\n+    return entry.m_main_chunk_feerate;\n }\n \n-bool TxGraphImpl::IsOversized() noexcept\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n {\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n     // Find which Clusters will need to be merged together, as that is where the oversize\n     // property is assessed.\n-    GroupClusters();\n-    Assume(m_clusterset.m_group_data.has_value());\n-    return m_clusterset.m_group_data->m_group_oversized;\n+    GroupClusters(level);\n+    Assume(m_clustersets[level].m_group_data.has_value());\n+    return m_clustersets[level].m_group_data->m_group_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized),\n+    // do all merging work now. This also involves applying all removals.\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark are removed transactions as Missing (so the stage_level locator for these transactions",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1058,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": 1964241681,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-02-21T22:20:58Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966272170",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966272170"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1548,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966274126",
      "pull_request_review_id": 2634380073,
      "id": 1966274126,
      "node_id": "PRRC_kwDOABII5851MvZO",
      "diff_hunk": "@@ -1176,101 +1400,201 @@ FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n     return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n {\n-    // Return the empty vector if the Ref is empty.\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Cluster linearization cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n     MakeAcceptable(*cluster);\n     return cluster->GetClusterRefs(*this);\n }\n \n-TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n {\n-    ApplyRemovals();\n-    return m_clusterset.m_txcount;\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n }\n \n FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n-    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n-    ApplyRemovals();\n-    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n-    ApplyDependencies();\n+    ApplyDependencies(/*level=*/0);\n     // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n     // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n     // chunk feerate.\n     MakeAcceptable(*cluster);\n     const auto& entry = m_entries[GetRefIndex(arg)];\n-    return entry.m_chunk_feerate;\n+    return entry.m_main_chunk_feerate;\n }\n \n-bool TxGraphImpl::IsOversized() noexcept\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n {\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n     // Find which Clusters will need to be merged together, as that is where the oversize\n     // property is assessed.\n-    GroupClusters();\n-    Assume(m_clusterset.m_group_data.has_value());\n-    return m_clusterset.m_group_data->m_group_oversized;\n+    GroupClusters(level);\n+    Assume(m_clustersets[level].m_group_data.has_value());\n+    return m_clustersets[level].m_group_data->m_group_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized),\n+    // do all merging work now. This also involves applying all removals.\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark are removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created).\n+    for (auto idx : stage.m_removed) {\n+        m_entries[idx].m_locator[stage_level].SetMissing();",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1061,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": 1964244998,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This seems to work in fuzzing, but I'm not entirely convinced this is clearly true. Entries can exist in `m_to_remove` which are already removed (if they're unlinked), so I have not taken this.",
      "created_at": "2025-02-21T22:22:56Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966274126",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966274126"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1717,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966275484",
      "pull_request_review_id": 2634380073,
      "id": 1966275484,
      "node_id": "PRRC_kwDOABII5851Mvuc",
      "diff_hunk": "@@ -1176,101 +1400,201 @@ FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n     return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n {\n-    // Return the empty vector if the Ref is empty.\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Cluster linearization cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n     MakeAcceptable(*cluster);\n     return cluster->GetClusterRefs(*this);\n }\n \n-TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n {\n-    ApplyRemovals();\n-    return m_clusterset.m_txcount;\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n }\n \n FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n-    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n-    ApplyRemovals();\n-    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n-    ApplyDependencies();\n+    ApplyDependencies(/*level=*/0);\n     // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n     // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n     // chunk feerate.\n     MakeAcceptable(*cluster);\n     const auto& entry = m_entries[GetRefIndex(arg)];\n-    return entry.m_chunk_feerate;\n+    return entry.m_main_chunk_feerate;\n }\n \n-bool TxGraphImpl::IsOversized() noexcept\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n {\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n     // Find which Clusters will need to be merged together, as that is where the oversize\n     // property is assessed.\n-    GroupClusters();\n-    Assume(m_clusterset.m_group_data.has_value());\n-    return m_clusterset.m_group_data->m_group_oversized;\n+    GroupClusters(level);\n+    Assume(m_clustersets[level].m_group_data.has_value());\n+    return m_clustersets[level].m_group_data->m_group_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized),\n+    // do all merging work now. This also involves applying all removals.\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark are removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created).",
      "path": "src/txgraph.cpp",
      "position": 1760,
      "original_position": 1059,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": 1964248901,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The goal is just that when staging is aborted/committed, and then you start a new staging, the `m_locator[1]` values will all be cleared already. ",
      "created_at": "2025-02-21T22:24:29Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966275484",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966275484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1760,
      "original_line": 1760,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966275969",
      "pull_request_review_id": 2634380073,
      "id": 1966275969,
      "node_id": "PRRC_kwDOABII5851Mv2B",
      "diff_hunk": "@@ -1755,6 +1774,11 @@ void TxGraphImpl::SanityCheck() const\n         if (!clusterset.m_deps_to_add.empty()) compact_possible = false;\n         if (!clusterset.m_to_remove.empty()) compact_possible = false;\n         if (!clusterset.m_removed.empty()) compact_possible = false;\n+\n+        // If m_group_data exists, its m_group_oversized must match m_oversized.\n+        if (clusterset.m_group_data.has_value()) {\n+            assert(clusterset.m_oversized == clusterset.m_group_data->m_group_oversized);",
      "path": "src/txgraph.cpp",
      "position": 2057,
      "original_position": 100,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "07632d6ce09eb3293a255d34703638af69c5dd7c",
      "in_reply_to_id": 1964276025,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "No, because it's comparing an `std::optional<bool>` with a `bool`, which can only be true if the first isn't `std::nullopt`.",
      "created_at": "2025-02-21T22:24:55Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966275969",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966275969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2057,
      "original_line": 2057,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966276311",
      "pull_request_review_id": 2634380073,
      "id": 1966276311,
      "node_id": "PRRC_kwDOABII5851Mv7X",
      "diff_hunk": "@@ -303,6 +303,8 @@ class TxGraphImpl final : public TxGraph\n         Locator m_locator[MAX_LEVELS];\n         /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n         FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */",
      "path": "src/txgraph.cpp",
      "position": 308,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "fdd68be0ac6c7fa1c253e750df56853e1f97ca98",
      "in_reply_to_id": 1964316237,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Not really. The -1 has no meaning, but hopefully would result in a nice detectable error if it were ever used.",
      "created_at": "2025-02-21T22:25:18Z",
      "updated_at": "2025-02-21T22:25:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966276311",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966276311"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 308,
      "original_line": 308,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966322708",
      "pull_request_review_id": 2634477159,
      "id": 1966322708,
      "node_id": "PRRC_kwDOABII5851M7QU",
      "diff_hunk": "@@ -143,10 +143,16 @@ class TxGraph\n      *  staging graph exists, it is queried; otherwise the main graph is queried. The queried\n      *  graph must not be oversized. Returns {} if arg does not exist in the queried graph. */\n     virtual std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Like GetAncestors, but return the Refs for all transactions in the union of the provided\n+     *  arguments' ancestors (each transaction is only reported once). */\n+    virtual std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept = 0;\n     /** Get pointers to all descendants of the specified transaction. If main_only is false and a\n      *  staging graph exists, it is queried; otherwise the main graph is queried. The queried\n      *  graph must not be oversized. Returns {} if arg does not exist in the queried graph. */\n     virtual std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Like GetDescendants, but return the Refs for all transactions in the union of the provided",
      "path": "src/txgraph.h",
      "position": 149,
      "original_position": 11,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "11135464c5c3aef1ce8d2823120467a522ce2c87",
      "in_reply_to_id": 1965825553,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "major reading comprehension issues it seems",
      "created_at": "2025-02-21T23:35:57Z",
      "updated_at": "2025-02-21T23:35:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966322708",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966322708"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966324252",
      "pull_request_review_id": 2634479605,
      "id": 1966324252,
      "node_id": "PRRC_kwDOABII5851M7oc",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956359627,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "yes, thanks",
      "created_at": "2025-02-21T23:38:55Z",
      "updated_at": "2025-02-21T23:38:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966324252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966324252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966333596",
      "pull_request_review_id": 2634495706,
      "id": 1966333596,
      "node_id": "PRRC_kwDOABII5851M96c",
      "diff_hunk": "@@ -603,56 +755,102 @@ std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, Clust\n     return ret;\n }\n \n-ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n {\n     // Cannot insert with quality level NONE (as that would mean not inserted).\n     Assume(quality != QualityLevel::NONE);\n     // The passed-in Cluster must not currently be in the TxGraphImpl.\n     Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Append it at the end of the relevant TxGraphImpl::m_cluster.\n-    auto& quality_clusters = m_clusterset.m_clusters[int(quality)];\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n     ClusterSetIndex ret = quality_clusters.size();\n     cluster->m_quality = quality;\n     cluster->m_setindex = ret;\n+    cluster->m_level = level;\n     quality_clusters.push_back(std::move(cluster));\n     return ret;\n }\n \n-void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n {\n     Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n \n     // Don't do anything if the quality did not change.\n     if (old_quality == new_quality) return;\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n     // And re-insert it where it belongs.\n-    InsertCluster(std::move(cluster_ptr), new_quality);\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n }\n \n void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n {\n     // Extract the cluster from where it currently resides.\n-    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n     // And throw it away.\n     cluster_ptr.reset();\n }\n \n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster) noexcept\n+{\n+    int to_level = m_clustersets.size() - 1;\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from the level it was found at to higher levels, if any.\n+    while (level < to_level) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing doable work later.",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 558,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956656638,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "hah, was my first guess that I doubted :)",
      "created_at": "2025-02-21T23:57:58Z",
      "updated_at": "2025-02-21T23:57:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966333596",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966333596"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 905,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966335575",
      "pull_request_review_id": 2634499661,
      "id": 1966335575,
      "node_id": "PRRC_kwDOABII5851M-ZX",
      "diff_hunk": "@@ -1176,101 +1400,201 @@ FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n     return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n {\n     // Return the empty vector if the Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Ancestry cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n {\n-    // Return the empty vector if the Ref is empty.\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be incorrect otherwise.\n-    ApplyDependencies();\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n     // Cluster linearization cannot be known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n     // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n     MakeAcceptable(*cluster);\n     return cluster->GetClusterRefs(*this);\n }\n \n-TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n {\n-    ApplyRemovals();\n-    return m_clusterset.m_txcount;\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n }\n \n FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n-    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n-    ApplyRemovals();\n-    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n     if (cluster == nullptr) return {};\n     // Dispatch to the Cluster.\n-    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n }\n \n-FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n {\n     // Return the empty FeePerWeight if the passed Ref is empty.\n     if (GetRefGraph(arg) == nullptr) return {};\n     Assume(GetRefGraph(arg) == this);\n     // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n-    ApplyDependencies();\n+    ApplyDependencies(/*level=*/0);\n     // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n-    Assume(m_clusterset.m_deps_to_add.empty());\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n     // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n-    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n     if (cluster == nullptr) return {};\n     // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n     // chunk feerate.\n     MakeAcceptable(*cluster);\n     const auto& entry = m_entries[GetRefIndex(arg)];\n-    return entry.m_chunk_feerate;\n+    return entry.m_main_chunk_feerate;\n }\n \n-bool TxGraphImpl::IsOversized() noexcept\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n {\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n     // Find which Clusters will need to be merged together, as that is where the oversize\n     // property is assessed.\n-    GroupClusters();\n-    Assume(m_clusterset.m_group_data.has_value());\n-    return m_clusterset.m_group_data->m_group_oversized;\n+    GroupClusters(level);\n+    Assume(m_clustersets[level].m_group_data.has_value());\n+    return m_clustersets[level].m_group_data->m_group_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized),\n+    // do all merging work now. This also involves applying all removals.\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark are removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created).\n+    for (auto idx : stage.m_removed) {\n+        m_entries[idx].m_locator[stage_level].SetMissing();",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1061,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "913e14e6fd8bd50b4765747304dd45f14164e728",
      "in_reply_to_id": 1964244998,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "saw the updated comment/code in SanityCheck, makes sense",
      "created_at": "2025-02-22T00:01:01Z",
      "updated_at": "2025-02-22T00:01:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1966335575",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1966335575"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1717,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1970739081",
      "pull_request_review_id": 2642771775,
      "id": 1970739081,
      "node_id": "PRRC_kwDOABII5851dxeJ",
      "diff_hunk": "@@ -1336,6 +1336,35 @@ std::vector<ClusterIndex> MergeLinearizations(const DepGraph<SetType>& depgraph,\n     return ret;\n }\n \n+/** Make linearization topological, retaining its ordering where possible. */\n+template<typename SetType>\n+void FixLinearization(const DepGraph<SetType>& depgraph, Span<ClusterIndex> linearization) noexcept\n+{\n+    // This algorithm can be summarized as moving every element in the linearization backwards\n+    // until it is placed after all this ancestors.\n+    SetType done;\n+    const auto len = linearization.size();\n+    // Iterate over the elements of linearization from back to front (i is distance from back).\n+    for (ClusterIndex i = 0; i < len; ++i) {\n+        /** The element at that position. */\n+        ClusterIndex elem = linearization[len - 1 - i];\n+        /** j represents how far from the back of the linearization elem should be placed. */\n+        ClusterIndex j = i;\n+        // Figure out which elements elem needs to be placed before.\n+        SetType place_before = done & depgraph.Ancestors(elem);\n+        // Find which position to place elem in (updating j), continuously moving the elements\n+        // in between forward.\n+        while (place_before.Any()) {\n+            auto to_swap = linearization[len - 1 - (j - 1)];",
      "path": "src/cluster_linearize.h",
      "position": 472,
      "original_position": 23,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1c5f1c4601e0a895258cfe073125361f7a6ea012",
      "in_reply_to_id": 1909277721,
      "user": {
        "login": "yancyribbens",
        "id": 817736,
        "node_id": "MDQ6VXNlcjgxNzczNg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/817736?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yancyribbens",
        "html_url": "https://github.com/yancyribbens",
        "followers_url": "https://api.github.com/users/yancyribbens/followers",
        "following_url": "https://api.github.com/users/yancyribbens/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/yancyribbens/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/yancyribbens/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/yancyribbens/subscriptions",
        "organizations_url": "https://api.github.com/users/yancyribbens/orgs",
        "repos_url": "https://api.github.com/users/yancyribbens/repos",
        "events_url": "https://api.github.com/users/yancyribbens/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/yancyribbens/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The comment ` // j cannot be 0 here;` implies this should be `j != 0` instead of `j > 0`.  Since it's unsigned `j != 0` is also correct.",
      "created_at": "2025-02-26T00:48:12Z",
      "updated_at": "2025-02-26T00:48:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1970739081",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1970739081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1372,
      "original_line": 1372,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1974177716",
      "pull_request_review_id": 2648789257,
      "id": 1974177716,
      "node_id": "PRRC_kwDOABII5851q4-0",
      "diff_hunk": "@@ -365,26 +369,56 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         --graph.m_txcount;\n     } while(!to_remove.empty());\n \n+    auto quality = m_quality;\n     Assume(todo.Any());\n     // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n     // removed, so we benefit from batching all the removals).\n     m_depgraph.RemoveTransactions(todo);\n     m_mapping.resize(m_depgraph.PositionRange());\n \n-    // Filter removals out of m_linearization.\n-    m_linearization.erase(std::remove_if(\n-        m_linearization.begin(),\n-        m_linearization.end(),\n-        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n-\n-    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (quality == QualityLevel::OPTIMAL || quality == QualityLevel::NEEDS_SPLIT_OPTIMAL) {\n+            quality = QualityLevel::NEEDS_SPLIT_OPTIMAL;\n+        } else if (quality == QualityLevel::ACCEPTABLE || quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else if (quality == QualityLevel::NEEDS_RELINEARIZE) {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_quality, m_setindex, quality);\n     Updated(graph);\n }\n \n bool Cluster::Split(TxGraphImpl& graph) noexcept\n {\n     // This function can only be called when the Cluster needs splitting.\n-    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT || m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ||\n+           m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = m_quality == QualityLevel::NEEDS_SPLIT ? QualityLevel::NEEDS_RELINEARIZE :\n+                               m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ? QualityLevel::OPTIMAL :\n+                               QualityLevel::ACCEPTABLE;\n+    // If the cluster was NEEDS_SPLIT_OPTIMAL, and we're thus going to produce OPTIMAL clusters, we",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "693c3df67dc972dd2fcfbeb8179bcd7833c77bd1",
      "in_reply_to_id": 1955027230,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Update from offline conversation: This was a confusion about what we're calling \"optimal\". The splits clusters are already optimal in the sense of the diagram check, but not minimal or fully connected. PostLinearization makes sure that all chunks are connected/minimal.\r\n\r\nPerhaps a rewording of this section to make it abundantly clear?",
      "created_at": "2025-02-27T19:01:04Z",
      "updated_at": "2025-02-27T19:01:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1974177716",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1974177716"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1977762419",
      "pull_request_review_id": 2654547069,
      "id": 1977762419,
      "node_id": "PRRC_kwDOABII58514kJz",
      "diff_hunk": "@@ -365,26 +369,56 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         --graph.m_txcount;\n     } while(!to_remove.empty());\n \n+    auto quality = m_quality;\n     Assume(todo.Any());\n     // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n     // removed, so we benefit from batching all the removals).\n     m_depgraph.RemoveTransactions(todo);\n     m_mapping.resize(m_depgraph.PositionRange());\n \n-    // Filter removals out of m_linearization.\n-    m_linearization.erase(std::remove_if(\n-        m_linearization.begin(),\n-        m_linearization.end(),\n-        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n-\n-    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (quality == QualityLevel::OPTIMAL || quality == QualityLevel::NEEDS_SPLIT_OPTIMAL) {\n+            quality = QualityLevel::NEEDS_SPLIT_OPTIMAL;\n+        } else if (quality == QualityLevel::ACCEPTABLE || quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else if (quality == QualityLevel::NEEDS_RELINEARIZE) {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_quality, m_setindex, quality);\n     Updated(graph);\n }\n \n bool Cluster::Split(TxGraphImpl& graph) noexcept\n {\n     // This function can only be called when the Cluster needs splitting.\n-    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT || m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ||\n+           m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = m_quality == QualityLevel::NEEDS_SPLIT ? QualityLevel::NEEDS_RELINEARIZE :\n+                               m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ? QualityLevel::OPTIMAL :\n+                               QualityLevel::ACCEPTABLE;\n+    // If the cluster was NEEDS_SPLIT_OPTIMAL, and we're thus going to produce OPTIMAL clusters, we",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "693c3df67dc972dd2fcfbeb8179bcd7833c77bd1",
      "in_reply_to_id": 1955027230,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Also, as discussed offline, this seems like an easy scenario to write a fuzz test for as described above ^",
      "created_at": "2025-03-03T15:54:56Z",
      "updated_at": "2025-03-03T15:54:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1977762419",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1977762419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1980055069",
      "pull_request_review_id": 2658670637,
      "id": 1980055069,
      "node_id": "PRRC_kwDOABII5852BT4d",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref (not pointing to any Entry). */\n+        Ref() noexcept = default;\n+        /** Test if this Ref is not empty. */\n+        explicit operator bool() const noexcept { return m_graph != nullptr; }\n+        /** Destroy this Ref. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeeFrac& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */\n+    virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n+    /** Return a vector of pointers to Ref objects for transactions which have been removed from\n+     *  the graph, and have not been destroyed yet. Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n+    [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n+\n+    /** Determine whether arg exists in this graph (i.e., was not removed). */\n+    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n+     *  does not exist. */\n+    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    /** Get the individual transaction feerate of transaction arg. Returns the empty FeeFrac if\n+     *  arg does not exist. */\n+    virtual FeeFrac GetIndividualFeerate(const Ref& arg) noexcept = 0;\n+    /** Get pointers to all transactions in the connected component (\"cluster\") which arg is in.\n+     *  The transactions will be returned in a topologically-valid order of acceptable quality.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 109,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909271584,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Would it go too far to assure the caller that the ordering reflects the underlying stored linearization i.e. reflects the underlying ordering values like chunk feerates are coming from?",
      "created_at": "2025-03-04T18:59:35Z",
      "updated_at": "2025-03-04T18:59:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1980055069",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1980055069"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994757992",
      "pull_request_review_id": 2684192006,
      "id": 1994757992,
      "node_id": "PRRC_kwDOABII58525Zdo",
      "diff_hunk": "@@ -19,8 +19,8 @@\n \n namespace cluster_linearize {\n \n-/** Data type to represent transaction indices in clusters. */\n-using ClusterIndex = uint32_t;\n+/** Data type to represent transaction indices in DepGraphs and the clusters they represent. */\n+using DepGraphIndex = uint32_t;",
      "path": "src/cluster_linearize.h",
      "position": 7,
      "original_position": 7,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "8872339583446bf206a9500af6695fd52b215532",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This commit could be a scripted diff.\r\n\r\n```\r\n-BEGIN VERIFY SCRIPT-\r\nsed -i 's/Data type to represent transaction indices in clusters./Data type to represent transaction indices in DepGraphs and the clusters they represent./' $(git grep -l 'using ClusterIndex')\r\nsed -i 's|\\<ClusterIndex\\>|DepGraphIndex|g' $(git grep -l 'ClusterIndex')\r\n-END VERIFY SCRIPT-\r\n```",
      "created_at": "2025-03-14T04:52:31Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994757992",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994757992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994762659",
      "pull_request_review_id": 2684192006,
      "id": 1994762659,
      "node_id": "PRRC_kwDOABII58525amj",
      "diff_hunk": "@@ -280,6 +280,7 @@ add_library(bitcoin_node STATIC EXCLUDE_FROM_ALL\n   signet.cpp\n   torcontrol.cpp\n   txdb.cpp\n+  txgraph.cpp",
      "path": "src/CMakeLists.txt",
      "position": 4,
      "original_position": 4,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943239737,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "(\"and so forth\" alternatively)",
      "created_at": "2025-03-14T04:54:53Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994762659",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994762659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 304,
      "original_line": 304,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994831035",
      "pull_request_review_id": 2684192006,
      "id": 1994831035,
      "node_id": "PRRC_kwDOABII58525rS7",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 45,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943247961,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Why does it say earlier \"Destroying this TxGraph::Ref removes the corresponding transaction\" but here \"[destroying this ref] is only allowed when .. the transaction it refers to has been removed from the graph\" ? I think the destructor \"unlinks\" but does not \"remove\" the tx, so failure to remove before destructing will result in an `Assume(!entry.m_locator.IsPresent())` failure in `Compact()`.",
      "created_at": "2025-03-14T05:20:39Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994831035",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994831035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994854097",
      "pull_request_review_id": 2684192006,
      "id": 1994854097,
      "node_id": "PRRC_kwDOABII58525w7R",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 77,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "The invalidation behaviour for Refs seems unclear to me? I think the idea is that if you hold onto a `Ref` you can continue to uniquely refer to a removed transaction, up until the Ref is destructed, at which point the TxGraph is compacted and memory might be reused at that point. This delay then also allows for reordering to occur which can result in optimisations.\r\n\r\nI think the intended behaviour could be made a bit clearer in the header file though? It's not immediately obvious to me under what circumstances the `ApplyRemovals()` and `Compact()` are/should be called.",
      "created_at": "2025-03-14T05:31:29Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994854097",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994854097"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994903294",
      "pull_request_review_id": 2684192006,
      "id": 1994903294,
      "node_id": "PRRC_kwDOABII5852587-",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref (not pointing to any Entry). */\n+        Ref() noexcept = default;\n+        /** Test if this Ref is not empty. */\n+        explicit operator bool() const noexcept { return m_graph != nullptr; }\n+        /** Destroy this Ref. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeeFrac& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */\n+    virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n+    /** Return a vector of pointers to Ref objects for transactions which have been removed from\n+     *  the graph, and have not been destroyed yet. Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n+    [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n+\n+    /** Determine whether arg exists in this graph (i.e., was not removed). */\n+    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n+     *  does not exist. */\n+    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    /** Get the individual transaction feerate of transaction arg. Returns the empty FeeFrac if\n+     *  arg does not exist. */\n+    virtual FeeFrac GetIndividualFeerate(const Ref& arg) noexcept = 0;\n+    /** Get pointers to all transactions in the connected component (\"cluster\") which arg is in.\n+     *  The transactions will be returned in a topologically-valid order of acceptable quality.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 109,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909271584,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Doesn't \"topologically-valid order\" already cover what \"acceptable quality\" means here, as far as the interface is concerned?",
      "created_at": "2025-03-14T06:02:58Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994903294",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994903294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994918766",
      "pull_request_review_id": 2684192006,
      "id": 1994918766,
      "node_id": "PRRC_kwDOABII58526Atu",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 168,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`std::array<std::vector<std::unique_ptr<Cluster>>,int{QualityLevel::NONE}> m_clusters;` might read clearer?",
      "created_at": "2025-03-14T06:11:53Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994918766",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994918766"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994939901",
      "pull_request_review_id": 2684192006,
      "id": 1994939901,
      "node_id": "PRRC_kwDOABII58526F39",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 197,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"A class of objects\" doesn't seem like a very useful description? \"Internal information about each transaction in a TxGraphImpl\" ?",
      "created_at": "2025-03-14T06:29:17Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994939901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994939901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994970731",
      "pull_request_review_id": 2684192006,
      "id": 1994970731,
      "node_id": "PRRC_kwDOABII58526NZr",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};",
      "path": "src/txgraph.cpp",
      "position": 303,
      "original_position": 201,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Having each Ref point to the TxGraph and the TxGraph point to (and potentially modify via SwapIndexes) every Ref seems very self-referential, which is probably a bit confusing and not very cache optimal and so forth...\r\n\r\nI think you could reduce this to a `const Ref*` (so that Refs wouldn't get modified via `entry.m_ref`) by replacing the use of SwapIndexes on Compact() with a free list/heap of no-longer used entries. Probably not worthwhile though.",
      "created_at": "2025-03-14T07:06:06Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994970731",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994970731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 303,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994989000",
      "pull_request_review_id": 2684192006,
      "id": 1994989000,
      "node_id": "PRRC_kwDOABII58526R3I",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());",
      "path": "src/txgraph.cpp",
      "position": 596,
      "original_position": 306,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945148422,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "What's the advantage of using Assume() over Assert()? The condition is still checked in production builds, it's just that the result is discarded and execution continues, rather than triggering an abort, no? My understanding was:\r\n\r\n * `CHECK_NONFATAL(cond)` -- to throw when there's an internal error that prevents continuing in RPC code, but is recoverable overall\r\n * `Assume(x)` -- when we expect `x` to be true-ish, but the code will still operate correctly if it is not\r\n * `Assert(x)` or `assert(x)` when we require `x` to be true-ish and the code won't operate correctly if it is not\r\n\r\nYou could conceivably have `ref.m_graph` be a debug-only field, and write `Assume(ref.CheckGraph(txgraph))` with `bool Ref::CheckGraph(const TxGraph* g) { if constexpr (DEBUG) { return g == m_graph; } else return true; }` perhaps; but otherwise I don't think you're getting any benefit from Assume vs Assert.",
      "created_at": "2025-03-14T07:20:16Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1994989000",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1994989000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 596,
      "original_line": 596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996715147",
      "pull_request_review_id": 2684192006,
      "id": 1996715147,
      "node_id": "PRRC_kwDOABII5853A3SL",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 18,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Might be worth pointing out that the api is designed towards allowing for an implementation that stores the transitive closure of dependencies -- when querying, if B spends C, then you can't differentiate between A spends B and A spends B and C.",
      "created_at": "2025-03-15T10:07:20Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1996715147",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1996715147"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997570195",
      "pull_request_review_id": 2684192006,
      "id": 1997570195,
      "node_id": "PRRC_kwDOABII5853EICT",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing). */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry. This may happen when RemoveTransaction\n+            // was called twice on the same Ref.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step below (which might\n+    // invalidate them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_add entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {",
      "path": "src/txgraph.cpp",
      "position": 1120,
      "original_position": 706,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Slightly surprised the \"union-find algorithm\" section isn't broken out into a top level class or similar, rather than lambda functions.",
      "created_at": "2025-03-16T11:47:47Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1997570195",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1997570195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1120,
      "original_line": 1120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1999180674",
      "pull_request_review_id": 2684192006,
      "id": 1999180674,
      "node_id": "PRRC_kwDOABII5853KROC",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing). */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry. This may happen when RemoveTransaction\n+            // was called twice on the same Ref.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step below (which might\n+    // invalidate them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_add entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_fn = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_root_fn = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_fn = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_root_fn(arg1);\n+            auto rep2 = find_root_fn(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_fn(locate_fn(par_cluster), locate_fn(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_root_fn(&data)->cluster;\n+            Assume(an_clusters[i].second == nullptr);\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_root_fn(locate_fn(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (all parents and children from this grouping\n+        // belong to the same Cluster at this point because of the merging above).\n+        const auto& loc = m_entries[group_data.m_deps[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, group_data.m_deps);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data = std::vector<GroupEntry>{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(!NeedsSplitting());\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (IsOptimal()) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (!cluster.NeedsSplitting() && !cluster.IsAcceptable()) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Don't do anything if this is a dependency on self.\n+    if (GetRefIndex(parent) == GetRefIndex(child)) return;\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Ancestors(idx).Count());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Descendants(idx).Count());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified DepGraphIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (!NeedsSplitting()) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n+{\n+    // Don't do anything if the passed Ref is empty.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);",
      "path": "src/txgraph.cpp",
      "position": 2089,
      "original_position": 1146,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this gives you a segfault when aborting the program if the TxGraph is destructed prior to some of its outstanding Ref's being destructed. It might be worthwhile having the TxGraph destructor iterate through any txs that haven't already been unlinked and clear the `m_graph` pointers back to itself. Alternatively, the TxGraph destructor could issue an assertion failure if there are any linked Refs remaining.",
      "created_at": "2025-03-17T16:35:10Z",
      "updated_at": "2025-03-17T17:30:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r1999180674",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1999180674"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2089,
      "original_line": 2089,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001126453",
      "pull_request_review_id": 2694691922,
      "id": 2001126453,
      "node_id": "PRRC_kwDOABII5853RsQ1",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;",
      "path": "src/txgraph.cpp",
      "position": 112,
      "original_position": 112,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Most of the `Cluster` methods require a `TxGraphImpl` to keep the quality/staging/mapping things consistent; feels a bit like it might be simpler just to have almost all this code stay in `TxGraphImpl`?",
      "created_at": "2025-03-18T14:01:03Z",
      "updated_at": "2025-03-18T18:03:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2001126453",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001126453"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 112,
      "original_line": 112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001315529",
      "pull_request_review_id": 2694691922,
      "id": 2001315529,
      "node_id": "PRRC_kwDOABII5853SabJ",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;",
      "path": "src/txgraph.cpp",
      "position": 27,
      "original_position": 27,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think this is a close to accurate diagram of the data structures here:\r\n\r\n![txgraph excalidraw](https://github.com/user-attachments/assets/7d3dedd0-8243-454d-8926-772cd7f83412)\r\n\r\nTo me, the cycles in that graph seem like a code smell. The `GraphIndex` backrefs make sense (or are unavoidable), as some stable way to refer to each tx is needed. But, I think it would probably be better for a Cluster not to be aware of its quality level or staging level (removing the `m_setindex/m_quality/m_level` back links) and moving the code that would query/change those items into TxGraph instead.\r\n\r\nI think you could think of `GraphIndex` as the unique global reference to a tx in a `TxGraph`, in which case `Ref` could be viewed as an RAII view of a `GraphIndex` (which enforces the need for a reference to `TxGraph` to allow for the resource to be freed on destruction), and which also copes with `GraphIndex` values being updated.",
      "created_at": "2025-03-18T15:22:05Z",
      "updated_at": "2025-03-18T18:03:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2001315529",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001315529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 27,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001430348",
      "pull_request_review_id": 2694691922,
      "id": 2001430348,
      "node_id": "PRRC_kwDOABII5853S2dM",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 240,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`ClusterSet m_main_clusterset; std::optional<ClusterSet> m_staging_clusterset;` might be clearer -- the vector stuff seems more confusing than helpful?\r\n\r\nDoes it ever make sense to have multiple nested staging levels? Parallel staging levels could make sense (I want to compare three RBFs in parallel on multiple cores, having checked that they're all independent and don't interact with each others' clusters) but seems probably more complicated than would be worthwhile. ",
      "created_at": "2025-03-18T16:14:19Z",
      "updated_at": "2025-03-18T18:03:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2001430348",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001430348"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001521035",
      "pull_request_review_id": 2694691922,
      "id": 2001521035,
      "node_id": "PRRC_kwDOABII5853TMmL",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing:\n+     *    - In the main graph:    the transaction does not exist in main.\n+     *    - In the staging graph: the transaction's existence is the same as in main. If it doesn't\n+     *                            exist in main, (M) in staging means it does not exist there\n+     *                            either. If it does exist in main, (M) in staging means the\n+     *                            cluster it is in has not been modified in staging, and thus the\n+     *                            transaction implicitly exists in staging too (without explicit\n+     *                            Cluster object; see PullIn() to create it in staging too).\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.\n+     * - (P,R): the transaction exists in main, but is removed in staging.\n+     *\n+     * When staging does not exist, only (M,M) and (P,M) are possible.\n+     */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified maximum cluster count. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count) noexcept :\n+        m_max_cluster_count(max_cluster_count)\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+        m_clustersets.reserve(MAX_LEVELS);\n+        m_clustersets.emplace_back();\n+    }\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly, or in the level below and not\n+    *   removed), return the Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist at a specified level. It must currently exist there. */\n+    void ClearLocator(int level, GraphIndex index) noexcept;\n+    /** Find which Clusters conflict with the top level. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        // Mark the transaction as to be removed in all levels where it explicitly or implicitly\n+        // exists.\n+        bool exists_anywhere{false};\n+        bool exists{false};\n+        for (size_t level = 0; level < m_clustersets.size(); ++level) {\n+            if (entry.m_locator[level].IsPresent()) {\n+                exists_anywhere = true;\n+                exists = true;\n+            } else if (entry.m_locator[level].IsRemoved()) {\n+                exists = false;\n+            }\n+            if (exists) {\n+                m_clustersets[level].m_to_remove.push_back(idx);\n+                // Force recomputation of grouping data.\n+                m_clustersets[level].m_group_data = std::nullopt;\n+                // Do not wipe the oversized state of a lower level graph (main) if a higher level\n+                // one (staging) exists. The reason for this is that the alternative would mean that\n+                // cluster merges may need to be applied to a formerly-oversized main graph while\n+                // staging exists (to satisfy chunk feerate queries into main, for example), and such\n+                // merges could conflict with pulls of some of their constituents into staging.\n+                if (level == m_clustersets.size() - 1 && m_clustersets[level].m_oversized == true) {\n+                    m_clustersets[level].m_oversized = std::nullopt;\n+                }\n+            }\n+        }\n+        m_unlinked.push_back(idx);\n+        if (!exists_anywhere) Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  or staged removals referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** If cluster is not in to_level, copy it there, and return a pointer to it. This has no\n+    *   effect if to_level is 0 (main), but for to_level=1 (staging) this modifies the locators of\n+    *   its transactions from inherited (P,M) to explicit (P,P). */\n+    Cluster* PullIn(Cluster* cluster, int to_level) noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel) up to the specified level. */\n+    void ApplyRemovals(int up_to_level) noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting up to the specified level. */\n+    void SplitAll(int up_to_level) noexcept;\n+    /** Populate m_group_data based on m_deps_to_add in the specified level. */\n+    void GroupClusters(int level) noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters in the specified level. */\n+    void ApplyDependencies(int level) noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+    /** Make all Clusters at the specified level have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAllAcceptable(int level) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    void DoWork() noexcept final;\n+\n+    void StartStaging() noexcept final;\n+    void CommitStaging() noexcept final;\n+    void AbortStaging() noexcept final;\n+    bool HaveStaging() const noexcept final { return m_clustersets.size() > 1; }\n+\n+    bool Exists(const Ref& arg, bool main_only = false) noexcept final;\n+    FeePerWeight GetMainChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendantsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    GraphIndex GetTransactionCount(bool main_only = false) noexcept final;\n+    bool IsOversized(bool main_only = false) noexcept final;\n+    std::strong_ordering CompareMainOrder(const Ref& a, const Ref& b) noexcept final;\n+    GraphIndex CountDistinctClusters(std::span<const Ref* const> refs, bool main_only = false) noexcept final;\n+\n+    void SanityCheck() const final;\n+};\n+\n+void TxGraphImpl::ClearLocator(int level, GraphIndex idx) noexcept\n+{\n+    auto& entry = m_entries[idx];\n+    Assume(entry.m_locator[level].IsPresent());\n+    // Change the locator from Present to Missing or Removed.\n+    if (level == 0 || !entry.m_locator[level - 1].IsPresent()) {\n+        entry.m_locator[level].SetMissing();\n+    } else {\n+        entry.m_locator[level].SetRemoved();\n+        m_clustersets[level].m_removed.push_back(idx);\n+    }\n+    // Update the transaction count.\n+    --m_clustersets[level].m_txcount;\n+    // Adjust the status of Locators of this transaction at higher levels.\n+    for (size_t after_level = level + 1; after_level < m_clustersets.size(); ++after_level) {\n+        if (entry.m_locator[after_level].IsPresent()) {\n+            break;\n+        } else if (entry.m_locator[after_level].IsRemoved()) {\n+            entry.m_locator[after_level].SetMissing();\n+            break;\n+        } else {\n+            --m_clustersets[after_level].m_txcount;\n+        }\n+    }\n+}\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator[m_level].SetPresent(this, idx);\n+    }\n+    // If this is for the main graph (level = 0), and the Cluster's quality is ACCEPTABLE or\n+    // OPTIMAL, compute its chunking and store its information in the Entry's m_main_lin_index\n+    // and m_main_chunk_feerate. These fields are only accessed after making the entire graph\n+    // ACCEPTABLE, so it is pointless to compute these if we haven't reached that quality level\n+    // yet.\n+    if (m_level == 0 && IsAcceptable()) {\n+        LinearizationChunking chunking(m_depgraph, m_linearization);\n+        LinearizationIndex lin_idx{0};\n+        // Iterate over the chunks.\n+        for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+            auto chunk = chunking.GetChunk(chunk_idx);\n+            Assume(chunk.transactions.Any());\n+            // Iterate over the transactions in the linearization, which must match those in chunk.\n+            do {\n+                DepGraphIndex idx = m_linearization[lin_idx];\n+                GraphIndex graph_idx = m_mapping[idx];\n+                auto& entry = graph.m_entries[graph_idx];\n+                entry.m_main_lin_index = lin_idx++;\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                Assume(chunk.transactions[idx]);\n+                chunk.transactions.Reset(idx);\n+            } while(chunk.transactions.Any());\n+        }\n+    }\n+}\n+\n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed (so (P,R) ones) are conflicts.\n+    for (auto i : m_clustersets[level].m_removed) {\n+        auto& entry = m_entries[i];\n+        if (entry.m_locator[level - 1].IsPresent()) {\n+            ret.push_back(entry.m_locator[level - 1].cluster);\n+        }\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts (the (P,P) ones).\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& clusters = m_clustersets[level].m_clusters[quality];\n+        for (const auto& cluster : clusters) {\n+            cluster->GetConflicts(*this, ret);\n+        }\n+    }\n+    // Deduplicate the result (the same Cluster may appear multiple times).\n+    std::sort(ret.begin(), ret.end());\n+    ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+    return ret;\n+}\n+\n+Cluster* Cluster::CopyTo(TxGraphImpl& graph, int to_level) const noexcept\n+{\n+    // Construct an empty Cluster.\n+    auto ret = std::make_unique<Cluster>();\n+    auto ptr = ret.get();\n+    // Copy depgraph, mapping, and linearization/\n+    ptr->m_depgraph = m_depgraph;\n+    ptr->m_mapping = m_mapping;\n+    ptr->m_linearization = m_linearization;\n+    // Insert the new Cluster into the graph.\n+    graph.InsertCluster(to_level, std::move(ret), m_quality);\n+    // Update its Locators.\n+    ptr->Updated(graph);\n+    return ptr;\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator[m_level];\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Remove its linearization index from the Entry (if in main).\n+        if (m_level == 0) {\n+            entry.m_main_lin_index = LinearizationIndex(-1);\n+        }\n+        // - Mark it as missing/removed in the Entry's locator.\n+        graph.ClearLocator(m_level, idx);\n+        to_remove = to_remove.subspan(1);\n+    } while(!to_remove.empty());\n+\n+    auto quality = m_quality;\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (IsAcceptable(/*after_split=*/true)) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_level, m_quality, m_setindex, quality);\n+    Updated(graph);\n+}\n+\n+void Cluster::Clear(TxGraphImpl& graph) noexcept\n+{\n+    for (auto i : m_linearization) {\n+        graph.ClearLocator(m_level, m_mapping[i]);\n+    }\n+    m_depgraph = {};\n+    m_linearization.clear();\n+    m_mapping.clear();\n+}\n+\n+void Cluster::LevelDown(TxGraphImpl& graph) noexcept\n+{\n+    int level = m_level;\n+    Assume(level > 0);\n+    for (auto i : m_linearization) {\n+        GraphIndex idx = m_mapping[i];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[level].SetMissing();\n+    }\n+    auto quality = m_quality;\n+    auto cluster = graph.ExtractCluster(level, quality, m_setindex);\n+    graph.InsertCluster(level - 1, std::move(cluster), quality);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = IsAcceptable(/*after_split=*/true) ? QualityLevel::ACCEPTABLE\n+                                                                  : QualityLevel::NEEDS_RELINEARIZE;\n+    // If we're going to produce ACCEPTABLE clusters (i.e., when in NEEDS_SPLIT_ACCEPTABLE), we\n+    // need to post-linearize to make sure the split-out versions are all connected (as\n+    // connectivity may have changed by removing part of the cluster). This could be done on each\n+    // resulting split-out cluster separately, but it is simpler to do it once up front before\n+    // splitting. This step is not necessary if the resulting clusters are NEEDS_RELINEARIZE, as\n+    // they will be post-linearized anyway in MakeAcceptable().\n+    if (new_quality == QualityLevel::ACCEPTABLE) {\n+        PostLinearize(m_depgraph, m_linearization);\n+    }\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_level, m_quality, m_setindex, new_quality);\n+            // If this made the quality ACCEPTABLE or OPTIMAL, we need to compute and cache its\n+            // chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(m_level, std::move(new_cluster), new_quality);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator[m_level].SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator[m_level];\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator[m_level];\n+            auto& parent = graph.m_entries[it->first].m_locator[m_level];\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+    ret->m_level = -1;\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters.back()->m_level = level;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    cluster->m_level = level;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level and therefore be\n+        // implicitly existing at this level too.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster, int to_level) noexcept\n+{\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from the level it was found at to higher levels, if any.\n+    while (level < to_level) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing double work later.\n+        MakeAcceptable(*cluster);\n+        ++level;\n+        auto new_cluster = cluster->CopyTo(*this, level);\n+        cluster = new_cluster;\n+    }\n+    return cluster;\n+}\n+\n+void TxGraphImpl::ApplyRemovals(int up_to_level) noexcept\n+{\n+    Assume(up_to_level >= 0 && size_t(up_to_level) < m_clustersets.size());\n+    for (int level = 0; level <= up_to_level; ++level) {\n+        auto& clusterset = m_clustersets[level];\n+        auto& to_remove = clusterset.m_to_remove;\n+        // Skip if there is nothing to remove in this level.\n+        if (to_remove.empty()) continue;\n+        // Pull in all Clusters that are not in the ClusterSet at level level.\n+        for (GraphIndex index : to_remove) {\n+            auto cluster = FindCluster(index, level);\n+            if (cluster != nullptr) PullIn(cluster, level);\n+        }\n+        // Group the set of to-be-removed entries by Cluster*.\n+        std::sort(to_remove.begin(), to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+            return std::less{}(m_entries[a].m_locator[level].cluster, m_entries[b].m_locator[level].cluster);\n+        });\n+        // Process per Cluster.\n+        std::span to_remove_span{to_remove};\n+        while (!to_remove_span.empty()) {\n+            Cluster* cluster = m_entries[to_remove_span.front()].m_locator[level].cluster;\n+            if (cluster != nullptr) {\n+                // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+                // can pop off whatever applies to it.\n+                cluster->ApplyRemovals(*this, to_remove_span);\n+            } else {\n+                // Otherwise, skip this already-removed entry. This may happen when\n+                // RemoveTransaction was called twice on the same Ref, for example.\n+                to_remove_span = to_remove_span.subspan(1);\n+            }\n+        }\n+        to_remove.clear();\n+    }\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref, if any exists.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locators for both levels. The rest of the Entry information will not change,\n+        // so no need to invoke Cluster::Updated().\n+        for (int level = 0; level < MAX_LEVELS; ++level) {\n+            Locator& locator = entry.m_locator[level];\n+            if (locator.IsPresent()) {\n+                locator.cluster->UpdateMapping(locator.index, idx);\n+            }\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations or staged removals remain as we'd need\n+    // to rewrite them. It is easier to delay the compaction until they have been applied.\n+    for (auto& clusterset : m_clustersets) {\n+        if (!clusterset.m_deps_to_add.empty()) return;\n+        if (!clusterset.m_to_remove.empty()) return;\n+        if (!clusterset.m_removed.empty()) return;\n+    }\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step below (which might\n+    // invalidate them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        for (int level = 0; level < MAX_LEVELS; ++level) {\n+            Assume(!entry.m_locator[level].IsPresent());\n+        }\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals(cluster.m_level);\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll(int up_to_level) noexcept\n+{\n+    Assume(up_to_level >= 0 && size_t(up_to_level) < m_clustersets.size());\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals(up_to_level);\n+    for (int level = 0; level <= up_to_level; ++level) {\n+        for (auto quality : {QualityLevel::NEEDS_SPLIT, QualityLevel::NEEDS_SPLIT_ACCEPTABLE}) {\n+            auto& queue = m_clustersets[level].m_clusters[int(quality)];\n+            while (!queue.empty()) {\n+                Split(*queue.back().get());\n+            }\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters(int level) noexcept\n+{\n+    auto& clusterset = m_clustersets[level];\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (clusterset.m_group_data.has_value()) return;\n+\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient and/or oversized Clusters which just end up being split again anyway.\n+    SplitAll(level);\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_add entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : clusterset.m_deps_to_add) {\n+        auto par_cluster = FindCluster(par, level);\n+        auto chl_cluster = FindCluster(chl, level);\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(clusterset.m_deps_to_add.begin(), clusterset.m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = FindCluster(a_chl, level);\n+        auto b_chl_cluster = FindCluster(b_chl, level);\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_fn = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_root_fn = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_fn = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_root_fn(arg1);\n+            auto rep2 = find_root_fn(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : clusterset.m_deps_to_add) {\n+            auto par_cluster = FindCluster(par, level);\n+            auto chl_cluster = FindCluster(chl, level);\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_fn(locate_fn(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_fn(locate_fn(par_cluster), locate_fn(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(clusterset.m_deps_to_add.size());\n+        auto deps_it = clusterset.m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_root_fn(&data)->cluster;\n+            Assume(an_clusters[i].second == nullptr);\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != clusterset.m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = FindCluster(chl, level);\n+                if (std::greater{}(chl_cluster, data.cluster)) break;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (chl_cluster == data.cluster) {\n+                    auto par_cluster = FindCluster(par, level);\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure, and the dependencies\n+    // back to m_deps_to_add.\n+    clusterset.m_group_data = GroupData{};\n+    clusterset.m_group_data->m_group_clusters.reserve(an_clusters.size());\n+    clusterset.m_group_data->m_group_oversized = false;\n+    clusterset.m_deps_to_add.clear();\n+    clusterset.m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = clusterset.m_group_data->m_groups.emplace_back();\n+        new_entry.m_cluster_offset = clusterset.m_group_data->m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = clusterset.m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        uint32_t total_count{0};\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            clusterset.m_group_data->m_group_clusters.push_back(an_clusters_it->first);\n+            total_count += an_clusters_it->first->GetTxCount();\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            clusterset.m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+        // Detect oversizedness.\n+        if (total_count > m_max_cluster_count) {\n+            clusterset.m_group_data->m_group_oversized = true;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    clusterset.m_oversized = clusterset.m_group_data->m_group_oversized;\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies(int level) noexcept\n+{\n+    auto& clusterset = m_clustersets[level];\n+    // Do not bother computing groups if we already know the result will be oversized.\n+    if (clusterset.m_oversized == true) return;\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (clusterset.m_deps_to_add.empty()) return;\n+    // Dependencies cannot be applied if it would result in oversized clusters.\n+    if (clusterset.m_group_data->m_group_oversized) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        // Pull in all the Clusters that contain dependencies.\n+        for (Cluster*& cluster : cluster_span) {\n+            cluster = PullIn(cluster, level);\n+        }\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (all parents and children from this grouping\n+        // belong to the same Cluster at this point because of the merging above).\n+        auto deps_span = std::span{clusterset.m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator[level];\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    clusterset.m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    clusterset.m_group_data = GroupData{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(!NeedsSplitting());\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (IsOptimal()) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_level, m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (!cluster.NeedsSplitting() && !cluster.IsAcceptable()) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+void TxGraphImpl::MakeAllAcceptable(int level) noexcept\n+{\n+    ApplyDependencies(level);\n+    if (m_clustersets[level].m_oversized == true) return;\n+    auto& queue = m_clustersets[level].m_clusters[int(QualityLevel::NEEDS_RELINEARIZE)];\n+    while (!queue.empty()) {\n+        MakeAcceptable(*queue.back().get());\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    int level = m_clustersets.size() - 1;\n+    InsertCluster(level, std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_clustersets[level].m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), m_clustersets.size() - 1);\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    auto& clusterset = m_clustersets.back();\n+    clusterset.m_to_remove.push_back(GetRefIndex(arg));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    clusterset.m_group_data.reset();\n+    if (clusterset.m_oversized == true) clusterset.m_oversized = std::nullopt;\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Don't do anything if this is a dependency on self.\n+    if (GetRefIndex(parent) == GetRefIndex(child)) return;\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = FindCluster(GetRefIndex(parent), m_clustersets.size() - 1);\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = FindCluster(GetRefIndex(child), m_clustersets.size() - 1);\n+    if (chl_cluster == nullptr) return;\n+    // Remember that this dependency is to be applied.\n+    auto& clusterset = m_clustersets.back();\n+    clusterset.m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    clusterset.m_group_data.reset();\n+    if (clusterset.m_oversized == false) clusterset.m_oversized = std::nullopt;\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg, bool main_only) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals(level);\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    return cluster != nullptr;\n+}\n+\n+void Cluster::GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept\n+{\n+    /** The union of all ancestors to be returned. */\n+    SetType ancestors_union;\n+    // Process elements from the front of args, as long as they apply.\n+    while (!args.empty()) {\n+        if (args.front().first != this) break;\n+        ancestors_union |= m_depgraph.Ancestors(args.front().second);\n+        args = args.subspan(1);\n+    }\n+    Assume(ancestors_union.Any());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : ancestors_union) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        Assume(entry.m_ref != nullptr);\n+        output.push_back(entry.m_ref);\n+    }\n+}\n+\n+void Cluster::GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept\n+{\n+    /** The union of all descendants to be returned. */\n+    SetType descendants_union;\n+    // Process elements from the front of args, as long as they apply.\n+    while (!args.empty()) {\n+        if (args.front().first != this) break;\n+        descendants_union |= m_depgraph.Descendants(args.front().second);\n+        args = args.subspan(1);\n+    }\n+    Assume(descendants_union.Any());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : descendants_union) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        Assume(entry.m_ref != nullptr);\n+        output.push_back(entry.m_ref);\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        Assume(entry.m_ref != nullptr);\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    std::pair<Cluster*, DepGraphIndex> match = {cluster, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index};\n+    auto matches = std::span(&match, 1);\n+    std::vector<TxGraph::Ref*> ret;\n+    cluster->GetAncestorRefs(*this, matches, ret);\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    std::pair<Cluster*, DepGraphIndex> match = {cluster, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index};\n+    auto matches = std::span(&match, 1);\n+    std::vector<TxGraph::Ref*> ret;\n+    cluster->GetDescendantRefs(*this, matches, ret);\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestorsUnion(std::span<const Ref* const> args, bool main_only) noexcept\n+{\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+\n+    // Translate args to matches.\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> matches;\n+    matches.reserve(args.size());\n+    for (auto arg : args) {\n+        // Skip empty Refs.\n+        if (GetRefGraph(*arg) == nullptr) continue;\n+        Assume(GetRefGraph(*arg) == this);\n+        // Find the Cluster the argument is in, and skip if none is found.\n+        auto cluster = FindCluster(GetRefIndex(*arg), level);\n+        if (cluster == nullptr) continue;\n+        // Append to matches.\n+        matches.emplace_back(cluster, m_entries[GetRefIndex(*arg)].m_locator[cluster->m_level].index);\n+    }\n+    // Group by Cluster.\n+    std::sort(matches.begin(), matches.end(), [](auto& a, auto& b) noexcept { return std::less{}(a.first, b.first); });\n+    // Dispatch to the Clusters.\n+    std::span match_span(matches);\n+    std::vector<TxGraph::Ref*> ret;\n+    while (!match_span.empty()) {\n+        match_span.front().first->GetAncestorRefs(*this, match_span, ret);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendantsUnion(std::span<const Ref* const> args, bool main_only) noexcept\n+{\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+\n+    // Translate args to matches.\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> matches;\n+    matches.reserve(args.size());\n+    for (auto arg : args) {\n+        // Skip empty Refs.\n+        if (GetRefGraph(*arg) == nullptr) continue;\n+        Assume(GetRefGraph(*arg) == this);\n+        // Find the Cluster the argument is in, and skip if none is found.\n+        auto cluster = FindCluster(GetRefIndex(*arg), level);\n+        if (cluster == nullptr) continue;\n+        // Append to matches.\n+        matches.emplace_back(cluster, m_entries[GetRefIndex(*arg)].m_locator[cluster->m_level].index);\n+    }\n+    // Group by Cluster.\n+    std::sort(matches.begin(), matches.end(), [](auto& a, auto& b) noexcept { return std::less{}(a.first, b.first); });\n+    // Dispatch to the Clusters.\n+    std::span match_span(matches);\n+    std::vector<TxGraph::Ref*> ret;\n+    while (!match_span.empty()) {\n+        match_span.front().first->GetDescendantRefs(*this, match_span, ret);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Cluster linearization cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n+{\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n+}\n+\n+FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing\n+        // transactions.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n+}\n+\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies(/*level=*/0);\n+    // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_main_chunk_feerate;\n+}\n+\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n+{\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    auto& clusterset = m_clustersets[level];\n+    if (clusterset.m_oversized.has_value()) {\n+        // Return cached value if known.\n+        return *clusterset.m_oversized;\n+    }\n+    // Find which Clusters will need to be merged together, as that is where the oversize\n+    // property is assessed.\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    clusterset.m_oversized = clusterset.m_group_data->m_group_oversized;\n+    return *clusterset.m_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized), do\n+    // all merging work now. Call SplitAll() first, so that even if ApplyDependencies does not do\n+    // any thing due to knowing the result is oversized, splitting is still performed.\n+    SplitAll(m_clustersets.size() - 1);\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+    stage.m_oversized = main.m_oversized;\n+    Assume(stage.m_oversized.has_value());\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark all removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created).\n+    for (auto idx : stage.m_removed) {\n+        m_entries[idx].m_locator[stage_level].SetMissing();\n+    }\n+    // Do the same with the non-removed transactions in staging Clusters.\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        for (auto& cluster : stage.m_clusters[quality]) {\n+            cluster->MakeTransactionsMissing(*this);\n+        }\n+    }\n+    // Destroy the staging graph data.\n+    m_clustersets.pop_back();\n+    Compact();\n+    if (!m_clustersets.back().m_group_data.has_value()) {\n+        // In case m_oversized in main was kept after a Ref destruction while staging exists, we\n+        // need to re-evaluate m_oversized now.\n+        m_clustersets.back().m_oversized = std::nullopt;\n+    }\n+}\n+\n+void TxGraphImpl::CommitStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    int main_level = stage_level - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    auto& main = m_clustersets[main_level];\n+    // Delete all conflicting Clusters in main_level, to make place for moving the staging ones\n+    // there. All of these have been PullIn()'d to stage_level before.\n+    auto conflicts = GetConflicts();\n+    for (Cluster* conflict : conflicts) {\n+        conflict->Clear(*this);\n+        DeleteCluster(*conflict);\n+    }\n+    // Mark the removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created0.\n+    for (auto idx : stage.m_removed) {\n+        m_entries[idx].m_locator[stage_level].SetMissing();\n+    }\n+    // Then move all Clusters in staging to main.\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& stage_sets = stage.m_clusters[quality];\n+        while (!stage_sets.empty()) {\n+            stage_sets.back()->LevelDown(*this);\n+        }\n+    }\n+    // Move all statistics, precomputed data, and to-be-applied removals and dependencies.\n+    main.m_deps_to_add = std::move(stage.m_deps_to_add);\n+    main.m_to_remove = std::move(stage.m_to_remove);\n+    main.m_group_data = std::move(stage.m_group_data);\n+    main.m_oversized = std::move(stage.m_oversized);\n+    main.m_txcount = std::move(stage.m_txcount);\n+    // Delete the old staging graph, after all its information was moved to main.\n+    m_clustersets.pop_back();\n+    Compact();\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified DepGraphIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (!NeedsSplitting()) {\n+        graph.SetClusterQuality(m_level, m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    } else {\n+        graph.SetClusterQuality(m_level, m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n+{\n+    // Don't do anything if the passed Ref is empty.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    for (int level = 0; level < MAX_LEVELS; ++level) {\n+        auto& locator = entry.m_locator[level];\n+        if (locator.IsPresent()) {\n+            locator.cluster->SetFee(*this, locator.index, fee);\n+        }\n+    }\n+}\n+\n+std::strong_ordering TxGraphImpl::CompareMainOrder(const Ref& a, const Ref& b) noexcept\n+{\n+    // The references must not be empty.\n+    Assume(GetRefGraph(a) == this);\n+    Assume(GetRefGraph(b) == this);\n+    // Apply dependencies in main.\n+    ApplyDependencies(0);\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n+    // Make both involved Clusters acceptable, so chunk feerates are relevant.\n+    const auto& entry_a = m_entries[GetRefIndex(a)];\n+    const auto& entry_b = m_entries[GetRefIndex(b)];\n+    const auto& locator_a = entry_a.m_locator[0];\n+    const auto& locator_b = entry_b.m_locator[0];\n+    Assume(locator_a.IsPresent());\n+    Assume(locator_b.IsPresent());\n+    MakeAcceptable(*locator_a.cluster);\n+    MakeAcceptable(*locator_b.cluster);\n+    // Compare chunk feerates, and return result if it differs.\n+    auto feerate_cmp = FeeRateCompare(entry_b.m_main_chunk_feerate, entry_a.m_main_chunk_feerate);\n+    if (feerate_cmp < 0) return std::strong_ordering::less;\n+    if (feerate_cmp > 0) return std::strong_ordering::greater;\n+    // Compare Cluster* as tie-break for equal chunk feerates.\n+    if (locator_a.cluster != locator_b.cluster) return locator_a.cluster <=> locator_b.cluster;\n+    // As final tie-break, compare position within cluster linearization.\n+    return entry_a.m_main_lin_index <=> entry_b.m_main_lin_index;\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::CountDistinctClusters(std::span<const Ref* const> refs, bool main_only) noexcept\n+{\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Build a vector of Clusters that the specified Refs occur in.\n+    std::vector<Cluster*> clusters;\n+    clusters.reserve(refs.size());\n+    for (const Ref* ref : refs) {\n+        if (ref == nullptr) continue;\n+        if (GetRefGraph(*ref) == nullptr) continue;\n+        Assume(GetRefGraph(*ref) == this);\n+        auto cluster = FindCluster(GetRefIndex(*ref), level);\n+        if (cluster != nullptr) clusters.push_back(cluster);\n+    }\n+    // Count the number of distinct elements in clusters.\n+    std::sort(clusters.begin(), clusters.end());\n+    Cluster* last{nullptr};\n+    GraphIndex ret{0};\n+    for (Cluster* cluster : clusters) {\n+        ret += (cluster != last);\n+        last = cluster;\n+    }\n+    return ret;\n+}\n+\n+void Cluster::SanityCheck(const TxGraphImpl& graph, int level) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // The number of transactions in a Cluster cannot exceed m_max_cluster_count.\n+    assert(m_linearization.size() <= graph.m_max_cluster_count);\n+    // The level must match the level the Cluster occurs in.\n+    assert(m_level == level);\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    LinearizationIndex linindex{0};\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator[level].cluster == this);\n+        assert(entry.m_locator[level].index == lin_pos);\n+        // For top-level entries, check linearization position and chunk feerate.\n+        if (level == 0 && IsAcceptable()) {\n+            assert(entry.m_main_lin_index == linindex++);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1887,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Avoid side-effects inside asserts if possible?",
      "created_at": "2025-03-18T16:56:42Z",
      "updated_at": "2025-03-18T18:03:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2001521035",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001521035"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1887,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001723093",
      "pull_request_review_id": 2695798609,
      "id": 2001723093,
      "node_id": "PRRC_kwDOABII5853T97V",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 240,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001430348,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I ran into a somewhat contrived use-case, but I have a fairly strong YNGNI feeling of this aspect of the code. That said, I don't think it hurts understanding too much as is.",
      "created_at": "2025-03-18T18:23:34Z",
      "updated_at": "2025-03-18T18:23:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2001723093",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001723093"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001731756",
      "pull_request_review_id": 2695813903,
      "id": 2001731756,
      "node_id": "PRRC_kwDOABII5853UACs",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 240,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001430348,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Curious to know this contrived use case, I also think it's a bit of an overkill in a previous comment https://github.com/bitcoin/bitcoin/pull/31363#pullrequestreview-2618143580, but @sipa made a compelling argument for it https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2666866811",
      "created_at": "2025-03-18T18:28:54Z",
      "updated_at": "2025-03-18T18:28:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2001731756",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2001731756"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2002875046",
      "pull_request_review_id": 2697652429,
      "id": 2002875046,
      "node_id": "PRRC_kwDOABII5853YXKm",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 240,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001430348,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I think `StartStaging()` gets a bit simpler if you know that it can only be called with `m_clustersets.size()==1`:\r\n\r\n```c++\r\n void TxGraphImpl::StartStaging() noexcept\r\n {\r\n+    Assume(m_clustersets.size() == 1);  // vs < MAX_LEVELS\r\n+    SplitAll(0); // vs m_clustersets.size() - 1\r\n+    ApplyDependencies(0); // ditto\r\n     m_clustersets.emplace_back();\r\n+    auto& stage = m_clustersets[1]; // vs m_clustersets.back()\r\n+    auto& main = m_clustersets[0]; // vs *(m_clustersets.rbegin() + 1);\r\n     ...\r\n```\r\n\r\nThat's the only use of `m_clustersets.rbegin()`, the remaining API of m_clustersets seems to be:\r\n\r\n```c++\r\n    class MainStageClusterSets\r\n    {\r\n    private:\r\n        std::vector<ClusterSet> cs;\r\n\r\n    public:\r\n        MainStageClusterSets()\r\n        {\r\n            cs.reserve(MAX_LEVELS);\r\n            cs.emplace_back();\r\n        }\r\n\r\n        bool UnfinishedTodo() const {\r\n            for (auto& clusterset : cs) {\r\n                if (!clusterset.m_deps_to_add.empty()) return true;\r\n                if (!clusterset.m_to_remove.empty()) return true;\r\n                if (!clusterset.m_removed.empty()) return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        const ClusterSet& operator[](size_t i) const { return cs[i]; }\r\n        ClusterSet& operator[](size_t i) { return cs[i]; }\r\n        ClusterSet& back() { return cs.back(); }\r\n        size_t size() const { return cs.size(); }\r\n\r\n        void emplace_back() { cs.emplace_back(); }\r\n        void pop_back() { cs.pop_back(); }\r\n    };\r\n    MainStageClusterSets m_clustersets;\r\n```\r\n\r\nwhich seem pretty straightforward to switch to a main/optional-stage model. Doing some renaming would make sense if so (emplace_back/pop_back to add/remove_staging; back to work maybe; size to has_staging maybe; maybe a templated ForEach() accepting a lambda taking a ClusterSet for iteration).",
      "created_at": "2025-03-19T09:31:27Z",
      "updated_at": "2025-03-19T09:31:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2002875046",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2002875046"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004248031",
      "pull_request_review_id": 2700118245,
      "id": 2004248031,
      "node_id": "PRRC_kwDOABII5853dmXf",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;",
      "path": "src/txgraph.cpp",
      "position": 27,
      "original_position": 27,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001315529,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "See my comment below: https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2734449766 regarding `Cluster` becoming an abstract base class.",
      "created_at": "2025-03-19T20:31:04Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004248031",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004248031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 27,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004249785",
      "pull_request_review_id": 2700118245,
      "id": 2004249785,
      "node_id": "PRRC_kwDOABII5853dmy5",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;",
      "path": "src/txgraph.cpp",
      "position": 112,
      "original_position": 112,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001126453,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "See my comments below: https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2734449766 about how the division between the two follows whether or not the function needs access to `Cluster`'s internals (which may become dependent on the subclass).",
      "created_at": "2025-03-19T20:32:22Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004249785",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004249785"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 112,
      "original_line": 112,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004285089",
      "pull_request_review_id": 2700118245,
      "id": 2004285089,
      "node_id": "PRRC_kwDOABII5853dvah",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};",
      "path": "src/txgraph.cpp",
      "position": 303,
      "original_position": 201,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1994970731,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "So this is roughly the thinking that led to this design of the split between `Ref` and `Entry`.\r\n\r\nThe most direct way of accomplishing this is just moving all data currently in `Entry` into `Ref` instead, but that requires exposing `TxGraphImpl` implementation details in the header. It also lacks a way to refer to entries in a stable manner internally. For example, what if a transaction has been marked for removal or dependency adding, and the `Ref` object is moved by the mempool code... we'd need a way to iterate over all places where a particular `Ref` is marked, which (I believe) needs several more cyclic references between components.\r\n\r\nAnother extreme is to have a map from `GraphIndex` values (which are chosen incrementally and never reused) to `Entry` objects, making them truly globally and permanently unique identifiers for `Ref`s. No rewriting is ever necessary, as there are no compactions needed, but it implies an additional allocation per transaction, plus probably (even) worse memory locality than the current design.\r\n\r\nI think using a freelist-like design can be seen as a variant of this, by storing the map in a `support/allocators/pool.h` pooled resource, and using map iterators as the graph indexes? I feel that's probably overkill.\r\n\r\nThe current design avoids the `Entry`->`Ref` map by allocating them continuously, but compacting at stable points, which necessitates a backreference, but that's still cheaper than an additional map.",
      "created_at": "2025-03-19T20:53:38Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004285089",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004285089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 303,
      "original_line": 303,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004286166",
      "pull_request_review_id": 2700118245,
      "id": 2004286166,
      "node_id": "PRRC_kwDOABII5853dvrW",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());",
      "path": "src/txgraph.cpp",
      "position": 596,
      "original_position": 306,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945148422,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "See my comment here: https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2734449766 about how `Assume()` gives you compiler-guaranteed side-effect-equivalence, largely without runtime cost.",
      "created_at": "2025-03-19T20:54:30Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004286166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004286166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 596,
      "original_line": 596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004287728",
      "pull_request_review_id": 2700118245,
      "id": 2004287728,
      "node_id": "PRRC_kwDOABII5853dwDw",
      "diff_hunk": "@@ -0,0 +1,1150 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. Size equals m_mapping.TxCount().\n+     *  This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply any number of removals from the front of to_remove, popping them off. At least one\n+     *  such element from the front of to_remove must be in this Cluster. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster (or be removed),\n+        apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this ClusterSet (explicit + implicit). */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object, if any. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing) */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove ClusterIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transaction go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);",
      "path": "src/txgraph.cpp",
      "position": 798,
      "original_position": 446,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "781c15bfca1ebaffe7b634196e19144f5ab10a50",
      "in_reply_to_id": 1945495189,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Late update (discussed elsewhere): this property actually did not hold. Added comments, and partially rewritten.",
      "created_at": "2025-03-19T20:55:47Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004287728",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004287728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 798,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004293062",
      "pull_request_review_id": 2700118245,
      "id": 2004293062,
      "node_id": "PRRC_kwDOABII5853dxXG",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing). */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry. This may happen when RemoveTransaction\n+            // was called twice on the same Ref.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step below (which might\n+    // invalidate them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_add entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {",
      "path": "src/txgraph.cpp",
      "position": 1120,
      "original_position": 706,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1997570195,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Yeah, fair point. I will think about this. It's a bit unfortunate that there is a *second* union-find implementation added in #31553, but it's so different (including different per-partition meta-data being kept) that trying to have a single implementation would be too abstract/template-heavy.",
      "created_at": "2025-03-19T20:59:09Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004293062",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004293062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1120,
      "original_line": 1120,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004295237",
      "pull_request_review_id": 2700118245,
      "id": 2004295237,
      "node_id": "PRRC_kwDOABII5853dx5F",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing). */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry. This may happen when RemoveTransaction\n+            // was called twice on the same Ref.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step below (which might\n+    // invalidate them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_add entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_fn = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_root_fn = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in. */\n+        static constexpr auto union_fn = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_root_fn(arg1);\n+            auto rep2 = find_root_fn(arg2);\n+            if (rep1 == rep2) return;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        for (const auto& [par, chl] : m_deps_to_add) {\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            union_fn(locate_fn(par_cluster), locate_fn(chl_cluster));\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_root_fn(&data)->cluster;\n+            Assume(an_clusters[i].second == nullptr);\n+            an_clusters[i].second = rep;\n+        }\n+        an_deps.reserve(m_deps_to_add.size());\n+        for (auto [par, chl] : m_deps_to_add) {\n+            auto chl_cluster = m_entries[chl].m_locator.cluster;\n+            auto par_cluster = m_entries[par].m_locator.cluster;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            // Find the representative of the partition which this dependency's child is in (which\n+            // should be the same as the one for the parent).\n+            auto rep = find_root_fn(locate_fn(chl_cluster))->cluster;\n+            // Create an_deps entry.\n+            an_deps.emplace_back(std::pair{par, chl}, rep);\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure.\n+    m_group_data = std::vector<GroupEntry>{};\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = m_group_data->emplace_back();\n+        // Add all its clusters to it (copying those from an_clusters to m_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            new_entry.m_clusters.push_back(an_clusters_it->first);\n+            ++an_clusters_it;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            new_entry.m_deps.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies() noexcept\n+{\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters();\n+    Assume(m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (m_deps_to_add.empty()) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    for (auto& group_data : *m_group_data) {\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(group_data.m_clusters);\n+        // Actually apply all to-be-added dependencies (all parents and children from this grouping\n+        // belong to the same Cluster at this point because of the merging above).\n+        const auto& loc = m_entries[group_data.m_deps[0].second].m_locator;\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, group_data.m_deps);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    m_group_data = std::vector<GroupEntry>{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(!NeedsSplitting());\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (IsOptimal()) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (!cluster.NeedsSplitting() && !cluster.IsAcceptable()) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    InsertCluster(std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    m_to_remove.push_back(GetRefIndex(arg));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Don't do anything if this is a dependency on self.\n+    if (GetRefIndex(parent) == GetRefIndex(child)) return;\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = m_entries[GetRefIndex(parent)].m_locator.cluster;\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = m_entries[GetRefIndex(child)].m_locator.cluster;\n+    if (chl_cluster == nullptr) return;\n+    // Remember that this dependency is to be applied.\n+    m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    m_group_data.reset();\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals();\n+    return m_entries[GetRefIndex(arg)].m_locator.IsPresent();\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Ancestors(idx).Count());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Ancestors(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_depgraph.Descendants(idx).Count());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : m_depgraph.Descendants(idx)) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetAncestorRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetDescendantRefs(*this, m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    ApplyDependencies();\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount() noexcept\n+{\n+    ApplyRemovals();\n+    return m_txcount;\n+}\n+\n+FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply removals, so that we can correctly report FeePerWeight{} for non-existing transaction.\n+    ApplyRemovals();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator.index);\n+}\n+\n+FeePerWeight TxGraphImpl::GetChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies();\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = m_entries[GetRefIndex(arg)].m_locator.cluster;\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_chunk_feerate;\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified DepGraphIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (!NeedsSplitting()) {\n+        graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n+{\n+    // Don't do anything if the passed Ref is empty.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    auto& locator = entry.m_locator;\n+    if (locator.IsPresent()) {\n+        locator.cluster->SetFee(*this, locator.index, fee);\n+    }\n+}\n+\n+} // namespace\n+\n+TxGraph::Ref::~Ref()\n+{\n+    if (m_graph) {\n+        // Inform the TxGraph about the Ref being destroyed.\n+        m_graph->UnlinkRef(m_index);",
      "path": "src/txgraph.cpp",
      "position": 2089,
      "original_position": 1146,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1999180674,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done. I've made `~TxGraphImpl` clean up all `Ref::m_graph` pointers.",
      "created_at": "2025-03-19T21:00:38Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004295237",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004295237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 2089,
      "original_line": 2089,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004304219",
      "pull_request_review_id": 2700118245,
      "id": 2004304219,
      "node_id": "PRRC_kwDOABII5853d0Fb",
      "diff_hunk": "@@ -189,28 +209,59 @@ class TxGraphImpl final : public TxGraph\n         std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n         /** Information about the merges to be performed, if known. */\n         std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 74,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956359627,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-19T21:08:21Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004304219",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004304219"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004306838",
      "pull_request_review_id": 2700118245,
      "id": 2004306838,
      "node_id": "PRRC_kwDOABII5853d0uW",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 45,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "c89d147209c91bb0464321f5bc733a4eeab0dea0",
      "in_reply_to_id": 1943247961,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@ajtowns That comment was put in the wrong commit. I've fixed it.",
      "created_at": "2025-03-19T21:09:58Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004306838",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004306838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 45,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004308947",
      "pull_request_review_id": 2700118245,
      "id": 2004308947,
      "node_id": "PRRC_kwDOABII5853d1PT",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+#include <cluster_linearize.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/util/random.h>\n+#include <util/bitset.h>\n+#include <util/feefrac.h>\n+\n+#include <algorithm>\n+#include <map>\n+#include <memory>\n+#include <stdint.h>\n+#include <utility>\n+\n+using namespace cluster_linearize;\n+\n+namespace {\n+\n+/** Data type representing a naive simulated TxGraph, keeping all transactions (even from\n+ *  disconnected components) in a single DepGraph. */\n+struct SimTxGraph\n+{\n+    /** Maximum number of transactions to support simultaneously. Set this higher than txgraph's\n+     *  cluster count, so we can exercise situations with more transactions than fit in one\n+     *  cluster. */\n+    static constexpr unsigned MAX_TRANSACTIONS = CLUSTER_COUNT_LIMIT * 2;\n+    /** Set type to use in the simulation. */\n+    using SetType = BitSet<MAX_TRANSACTIONS>;\n+    /** Data type for representing positions within SimTxGraph::graph. */\n+    using Pos = DepGraphIndex;\n+    /** Constant to mean \"missing in this graph\". */\n+    static constexpr auto MISSING = Pos(-1);\n+\n+    /** The dependency graph (for all transactions in the simulation, regardless of\n+     *  connectivity/clustering). */\n+    DepGraph<SetType> graph;\n+    /** For each position in graph, which TxGraph::Ref it corresponds with (if any). */\n+    std::array<std::unique_ptr<TxGraph::Ref>, MAX_TRANSACTIONS> simmap;\n+    /** For each TxGraph::Ref in graph, the position it corresponds with. */\n+    std::map<const TxGraph::Ref*, Pos> simrevmap;\n+    /** The set of TxGraph::Ref entries that have been removed, but not yet destroyed. */\n+    std::vector<std::unique_ptr<TxGraph::Ref>> removed;\n+\n+    /** Determine the number of (non-removed) transactions in the graph. */\n+    DepGraphIndex GetTransactionCount() const { return graph.TxCount(); }\n+\n+    /** Get the position where ref occurs in this simulated graph, or -1 if it does not. */\n+    Pos Find(const TxGraph::Ref* ref) const\n+    {\n+        auto it = simrevmap.find(ref);\n+        if (it != simrevmap.end()) return it->second;\n+        return MISSING;\n+    }\n+\n+    /** Given a position in this simulated graph, get the corresponding TxGraph::Ref. */\n+    TxGraph::Ref* GetRef(Pos pos)\n+    {\n+        assert(graph.Positions()[pos]);\n+        assert(simmap[pos]);\n+        return simmap[pos].get();\n+    }\n+\n+    /** Add a new transaction to the simulation. */\n+    TxGraph::Ref* AddTransaction(const FeePerWeight& feerate)\n+    {\n+        assert(graph.TxCount() < MAX_TRANSACTIONS);\n+        auto simpos = graph.AddTransaction(feerate);\n+        assert(graph.Positions()[simpos]);\n+        simmap[simpos] = std::make_unique<TxGraph::Ref>();\n+        auto ptr = simmap[simpos].get();\n+        simrevmap[ptr] = simpos;\n+        return ptr;\n+    }\n+\n+    /** Add a dependency between two positions in this graph. */\n+    void AddDependency(TxGraph::Ref* parent, TxGraph::Ref* child)\n+    {\n+        auto par_pos = Find(parent);\n+        if (par_pos == MISSING) return;\n+        auto chl_pos = Find(child);\n+        if (chl_pos == MISSING) return;\n+        graph.AddDependencies(SetType::Singleton(par_pos), chl_pos);\n+    }\n+\n+    /** Modify the transaction fee of a ref, if it exists. */\n+    void SetTransactionFee(TxGraph::Ref* ref, int64_t fee)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.FeeRate(pos).fee = fee;\n+    }\n+\n+    /** Remove the transaction in the specified position from the graph. */\n+    void RemoveTransaction(TxGraph::Ref* ref)\n+    {\n+        auto pos = Find(ref);\n+        if (pos == MISSING) return;\n+        graph.RemoveTransactions(SetType::Singleton(pos));\n+        simrevmap.erase(simmap[pos].get());\n+        // Retain the TxGraph::Ref corresponding to this position, until explicitly destroyed.\n+        // to see it when calling Cleanup().\n+        removed.push_back(std::move(simmap[pos]));\n+        simmap[pos].reset();\n+    }\n+\n+    /** Construct the set with all positions in this graph corresponding to the specified\n+     *  TxGraph::Refs. All of them must occur in this graph and not be removed. */\n+    SetType MakeSet(std::span<TxGraph::Ref* const> arg)\n+    {\n+        SetType ret;\n+        for (TxGraph::Ref* ptr : arg) {\n+            auto pos = Find(ptr);\n+            assert(pos != Pos(-1));\n+            ret.Set(pos);\n+        }\n+        return ret;\n+    }\n+\n+    /** Get the set of ancestors (desc=false) or descendants (desc=true) in this graph. */\n+    SetType GetAncDesc(TxGraph::Ref* arg, bool desc)\n+    {\n+        auto pos = Find(arg);\n+        if (pos == MISSING) return {};\n+        return desc ? graph.Descendants(pos) : graph.Ancestors(pos);\n+    }\n+\n+    /** Given a set of Refs (given as a vector of pointers), expand the set to include all its\n+     *  ancestors (desc=false) or all its descendants (desc=true) in this graph. */\n+    void IncludeAncDesc(std::vector<TxGraph::Ref*>& arg, bool desc)\n+    {\n+        std::vector<TxGraph::Ref*> ret;\n+        for (auto ptr : arg) {\n+            auto simpos = Find(ptr);\n+            if (simpos != MISSING) {\n+                for (auto i : desc ? graph.Descendants(simpos) : graph.Ancestors(simpos)) {\n+                    ret.push_back(simmap[i].get());\n+                }\n+            } else {\n+                ret.push_back(ptr);\n+            }\n+        }\n+        // Deduplicate.\n+        std::sort(ret.begin(), ret.end());\n+        ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+        // Replace input.\n+        arg = std::move(ret);\n+    }\n+};\n+\n+} // namespace\n+\n+FUZZ_TARGET(txgraph)\n+{\n+    SeedRandomStateForTest(SeedRand::ZEROS);\n+    FuzzedDataProvider provider(buffer.data(), buffer.size());\n+\n+    /** Internal test RNG, used only for decisions which would require significant amount of data\n+     *  to be read from the provider, without realistically impacting test sensitivity. */\n+    InsecureRandomContext rng(0xdecade2009added + buffer.size());\n+\n+    /** Variable used whenever an empty TxGraph::Ref is needed. */\n+    TxGraph::Ref empty_ref;\n+\n+    // Construct a real and a simulated graph.\n+    auto real = MakeTxGraph();\n+    SimTxGraph sim;\n+\n+    /** Function to pick any Ref (in sim real, sim.removed, or empty). */\n+    auto pick_fn = [&]() noexcept -> TxGraph::Ref* {\n+        auto tx_count = sim.GetTransactionCount();\n+        /** The number of possible choices. */\n+        size_t choices = tx_count + sim.removed.size() + 1;\n+        /** Pick one of them. */\n+        auto choice = provider.ConsumeIntegralInRange<size_t>(0, choices - 1);\n+        if (choice < tx_count) {\n+            // Return from real.\n+            for (auto i : sim.graph.Positions()) {\n+                if (choice == 0) return sim.GetRef(i);\n+                --choice;\n+            }\n+            assert(false);\n+        } else {\n+            choice -= tx_count;\n+        }\n+        if (choice < sim.removed.size()) {\n+            // Return from removed.\n+            return sim.removed[choice].get();\n+        } else {\n+            choice -= sim.removed.size();\n+        }\n+        // Return empty.\n+        assert(choice == 0);\n+        return &empty_ref;\n+    };\n+\n+    LIMITED_WHILE(provider.remaining_bytes() > 0, 200) {",
      "path": "src/test/fuzz/txgraph.cpp",
      "position": 282,
      "original_position": 200,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "1f06bc1e4a8108f1430bcd20fc391c9f663a2e4b",
      "in_reply_to_id": 1953307646,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I added the following comment:\r\n\r\n```\r\n    // This is a big simulation test for TxGraph, which performs a fuzz-derived sequence of valid\r\n    // operations on a TxGraph instance, as well as on a simpler (mostly) reimplementation (see\r\n    // SimTxGraph above), comparing the outcome of functions that return a result, and finally\r\n    // performing a full comparison between the two.\r\n```",
      "created_at": "2025-03-19T21:11:34Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004308947",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004308947"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 282,
      "original_line": 282,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004312349",
      "pull_request_review_id": 2700118245,
      "id": 2004312349,
      "node_id": "PRRC_kwDOABII5853d2Ed",
      "diff_hunk": "@@ -90,6 +95,17 @@ class Cluster\n     void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n     /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n     void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at level-1). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions in a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956385389,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Together with a lot of changes (getting rid of the `ClusterSet` vector), done.",
      "created_at": "2025-03-19T21:14:09Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004312349",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004312349"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 122,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004313231",
      "pull_request_review_id": 2700118245,
      "id": 2004313231,
      "node_id": "PRRC_kwDOABII5853d2SP",
      "diff_hunk": "@@ -356,14 +428,65 @@ void Cluster::Updated(TxGraphImpl& graph) noexcept\n                 DepGraphIndex idx = m_linearization[lin_idx++];\n                 GraphIndex graph_idx = m_mapping[idx];\n                 auto& entry = graph.m_entries[graph_idx];\n-                entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n                 Assume(chunk.transactions[idx]);\n                 chunk.transactions.Reset(idx);\n             } while(chunk.transactions.Any());\n         }\n     }\n }\n \n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 312,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e19bbc328236f64716034277857951184309cd14",
      "in_reply_to_id": 1956442485,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This code is gone now, resolving.",
      "created_at": "2025-03-19T21:14:28Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004313231",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004313231"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 525,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004315650",
      "pull_request_review_id": 2700118245,
      "id": 2004315650,
      "node_id": "PRRC_kwDOABII5853d24C",
      "diff_hunk": "@@ -365,26 +369,56 @@ void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove\n         --graph.m_txcount;\n     } while(!to_remove.empty());\n \n+    auto quality = m_quality;\n     Assume(todo.Any());\n     // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n     // removed, so we benefit from batching all the removals).\n     m_depgraph.RemoveTransactions(todo);\n     m_mapping.resize(m_depgraph.PositionRange());\n \n-    // Filter removals out of m_linearization.\n-    m_linearization.erase(std::remove_if(\n-        m_linearization.begin(),\n-        m_linearization.end(),\n-        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n-\n-    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (quality == QualityLevel::OPTIMAL || quality == QualityLevel::NEEDS_SPLIT_OPTIMAL) {\n+            quality = QualityLevel::NEEDS_SPLIT_OPTIMAL;\n+        } else if (quality == QualityLevel::ACCEPTABLE || quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else if (quality == QualityLevel::NEEDS_RELINEARIZE) {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_quality, m_setindex, quality);\n     Updated(graph);\n }\n \n bool Cluster::Split(TxGraphImpl& graph) noexcept\n {\n     // This function can only be called when the Cluster needs splitting.\n-    Assume(m_quality == QualityLevel::NEEDS_SPLIT);\n+    Assume(m_quality == QualityLevel::NEEDS_SPLIT || m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ||\n+           m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = m_quality == QualityLevel::NEEDS_SPLIT ? QualityLevel::NEEDS_RELINEARIZE :\n+                               m_quality == QualityLevel::NEEDS_SPLIT_OPTIMAL ? QualityLevel::OPTIMAL :\n+                               QualityLevel::ACCEPTABLE;\n+    // If the cluster was NEEDS_SPLIT_OPTIMAL, and we're thus going to produce OPTIMAL clusters, we",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "693c3df67dc972dd2fcfbeb8179bcd7833c77bd1",
      "in_reply_to_id": 1955027230,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "`NEEDS_SPLIT_OPTIMAL` is gone now after further discussion. Marking resolved.",
      "created_at": "2025-03-19T21:15:12Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004315650",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004315650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 662,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004316851",
      "pull_request_review_id": 2700118245,
      "id": 2004316851,
      "node_id": "PRRC_kwDOABII5853d3Kz",
      "diff_hunk": "@@ -19,8 +19,8 @@\n \n namespace cluster_linearize {\n \n-/** Data type to represent transaction indices in clusters. */\n-using ClusterIndex = uint32_t;\n+/** Data type to represent transaction indices in DepGraphs and the clusters they represent. */\n+using DepGraphIndex = uint32_t;",
      "path": "src/cluster_linearize.h",
      "position": 7,
      "original_position": 7,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "8872339583446bf206a9500af6695fd52b215532",
      "in_reply_to_id": 1994757992,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-19T21:15:53Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004316851",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004316851"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322030",
      "pull_request_review_id": 2700118245,
      "id": 2004322030,
      "node_id": "PRRC_kwDOABII5853d4bu",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 77,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1994854097,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "As far as the interface is concerned: you get a `Ref` object from `AddTransaction`, and as long as the object exists, using it remains valid (which, due to the unlinking in `~TxGraphImpl` you've suggested I add, may now even outlive the `TxGraph`). In the initial commit a `Ref` object may only be destroyed after the transaction has been removed, but this is relaxed in \"txgraph: (feature) destroying Ref means removing transaction\" (currently 9a04cc18e19aa03d215ce1fb030809d7e6eb98a6).\r\n\r\nI'd like to keep the implementation details (like when `ApplyRemovals()` and `Compact()` are called) out of the interface definition, but other than that, happy for any suggestions that would clarify things (I've adjusted comments a bit, and moved them to the correct commits already).\r\n\r\n",
      "created_at": "2025-03-19T21:19:48Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004322030",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322030"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322270",
      "pull_request_review_id": 2700118245,
      "id": 2004322270,
      "node_id": "PRRC_kwDOABII5853d4fe",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 168,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1994918766,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-19T21:19:55Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004322270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322378",
      "pull_request_review_id": 2700118245,
      "id": 2004322378,
      "node_id": "PRRC_kwDOABII5853d4hK",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 197,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1994939901,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-19T21:20:01Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004322378",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322378"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322643",
      "pull_request_review_id": 2700118245,
      "id": 2004322643,
      "node_id": "PRRC_kwDOABII5853d4lT",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 18,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1996715147,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-19T21:20:12Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004322643",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004322643"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 18,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004325057",
      "pull_request_review_id": 2700118245,
      "id": 2004325057,
      "node_id": "PRRC_kwDOABII5853d5LB",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 240,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001430348,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I've done something like this; `std::vector<ClusterSet>` is gone, and the code reduced by a whopping 23 lines as a result.\r\n\r\n",
      "created_at": "2025-03-19T21:22:00Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004325057",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004325057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 240,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004325643",
      "pull_request_review_id": 2700118245,
      "id": 2004325643,
      "node_id": "PRRC_kwDOABII5853d5UL",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyTo(TxGraphImpl& graph, int to_level) const noexcept;\n+    /** Get the list of Clusters that conflict with this one (at the level below this Cluster). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from level to level-1. */\n+    void LevelDown(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+    };\n+\n+    /** The ClusterSets in this TxGraphImpl. Has exactly 1 (main) or exactly 2 elements (main and staged). */\n+    std::vector<ClusterSet> m_clustersets;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing:\n+     *    - In the main graph:    the transaction does not exist in main.\n+     *    - In the staging graph: the transaction's existence is the same as in main. If it doesn't\n+     *                            exist in main, (M) in staging means it does not exist there\n+     *                            either. If it does exist in main, (M) in staging means the\n+     *                            cluster it is in has not been modified in staging, and thus the\n+     *                            transaction implicitly exists in staging too (without explicit\n+     *                            Cluster object; see PullIn() to create it in staging too).\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.\n+     * - (P,R): the transaction exists in main, but is removed in staging.\n+     *\n+     * When staging does not exist, only (M,M) and (P,M) are possible.\n+     */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified maximum cluster count. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count) noexcept :\n+        m_max_cluster_count(max_cluster_count)\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+        m_clustersets.reserve(MAX_LEVELS);\n+        m_clustersets.emplace_back();\n+    }\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly, or in the level below and not\n+    *   removed), return the Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Make a transaction not exist at a specified level. It must currently exist there. */\n+    void ClearLocator(int level, GraphIndex index) noexcept;\n+    /** Find which Clusters conflict with the top level. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        // Mark the transaction as to be removed in all levels where it explicitly or implicitly\n+        // exists.\n+        bool exists_anywhere{false};\n+        bool exists{false};\n+        for (size_t level = 0; level < m_clustersets.size(); ++level) {\n+            if (entry.m_locator[level].IsPresent()) {\n+                exists_anywhere = true;\n+                exists = true;\n+            } else if (entry.m_locator[level].IsRemoved()) {\n+                exists = false;\n+            }\n+            if (exists) {\n+                m_clustersets[level].m_to_remove.push_back(idx);\n+                // Force recomputation of grouping data.\n+                m_clustersets[level].m_group_data = std::nullopt;\n+                // Do not wipe the oversized state of a lower level graph (main) if a higher level\n+                // one (staging) exists. The reason for this is that the alternative would mean that\n+                // cluster merges may need to be applied to a formerly-oversized main graph while\n+                // staging exists (to satisfy chunk feerate queries into main, for example), and such\n+                // merges could conflict with pulls of some of their constituents into staging.\n+                if (level == m_clustersets.size() - 1 && m_clustersets[level].m_oversized == true) {\n+                    m_clustersets[level].m_oversized = std::nullopt;\n+                }\n+            }\n+        }\n+        m_unlinked.push_back(idx);\n+        if (!exists_anywhere) Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  or staged removals referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** If cluster is not in to_level, copy it there, and return a pointer to it. This has no\n+    *   effect if to_level is 0 (main), but for to_level=1 (staging) this modifies the locators of\n+    *   its transactions from inherited (P,M) to explicit (P,P). */\n+    Cluster* PullIn(Cluster* cluster, int to_level) noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel) up to the specified level. */\n+    void ApplyRemovals(int up_to_level) noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting up to the specified level. */\n+    void SplitAll(int up_to_level) noexcept;\n+    /** Populate m_group_data based on m_deps_to_add in the specified level. */\n+    void GroupClusters(int level) noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters in the specified level. */\n+    void ApplyDependencies(int level) noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+    /** Make all Clusters at the specified level have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAllAcceptable(int level) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    void DoWork() noexcept final;\n+\n+    void StartStaging() noexcept final;\n+    void CommitStaging() noexcept final;\n+    void AbortStaging() noexcept final;\n+    bool HaveStaging() const noexcept final { return m_clustersets.size() > 1; }\n+\n+    bool Exists(const Ref& arg, bool main_only = false) noexcept final;\n+    FeePerWeight GetMainChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendantsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    GraphIndex GetTransactionCount(bool main_only = false) noexcept final;\n+    bool IsOversized(bool main_only = false) noexcept final;\n+    std::strong_ordering CompareMainOrder(const Ref& a, const Ref& b) noexcept final;\n+    GraphIndex CountDistinctClusters(std::span<const Ref* const> refs, bool main_only = false) noexcept final;\n+\n+    void SanityCheck() const final;\n+};\n+\n+void TxGraphImpl::ClearLocator(int level, GraphIndex idx) noexcept\n+{\n+    auto& entry = m_entries[idx];\n+    Assume(entry.m_locator[level].IsPresent());\n+    // Change the locator from Present to Missing or Removed.\n+    if (level == 0 || !entry.m_locator[level - 1].IsPresent()) {\n+        entry.m_locator[level].SetMissing();\n+    } else {\n+        entry.m_locator[level].SetRemoved();\n+        m_clustersets[level].m_removed.push_back(idx);\n+    }\n+    // Update the transaction count.\n+    --m_clustersets[level].m_txcount;\n+    // Adjust the status of Locators of this transaction at higher levels.\n+    for (size_t after_level = level + 1; after_level < m_clustersets.size(); ++after_level) {\n+        if (entry.m_locator[after_level].IsPresent()) {\n+            break;\n+        } else if (entry.m_locator[after_level].IsRemoved()) {\n+            entry.m_locator[after_level].SetMissing();\n+            break;\n+        } else {\n+            --m_clustersets[after_level].m_txcount;\n+        }\n+    }\n+}\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator[m_level].SetPresent(this, idx);\n+    }\n+    // If this is for the main graph (level = 0), and the Cluster's quality is ACCEPTABLE or\n+    // OPTIMAL, compute its chunking and store its information in the Entry's m_main_lin_index\n+    // and m_main_chunk_feerate. These fields are only accessed after making the entire graph\n+    // ACCEPTABLE, so it is pointless to compute these if we haven't reached that quality level\n+    // yet.\n+    if (m_level == 0 && IsAcceptable()) {\n+        LinearizationChunking chunking(m_depgraph, m_linearization);\n+        LinearizationIndex lin_idx{0};\n+        // Iterate over the chunks.\n+        for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+            auto chunk = chunking.GetChunk(chunk_idx);\n+            Assume(chunk.transactions.Any());\n+            // Iterate over the transactions in the linearization, which must match those in chunk.\n+            do {\n+                DepGraphIndex idx = m_linearization[lin_idx];\n+                GraphIndex graph_idx = m_mapping[idx];\n+                auto& entry = graph.m_entries[graph_idx];\n+                entry.m_main_lin_index = lin_idx++;\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                Assume(chunk.transactions[idx]);\n+                chunk.transactions.Reset(idx);\n+            } while(chunk.transactions.Any());\n+        }\n+    }\n+}\n+\n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[m_level - 1].IsPresent()) {\n+            out.push_back(entry.m_locator[m_level - 1].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    int level = m_clustersets.size() - 1;\n+    std::vector<Cluster*> ret;\n+    // All Clusters at level-1 containing transactions in m_removed (so (P,R) ones) are conflicts.\n+    for (auto i : m_clustersets[level].m_removed) {\n+        auto& entry = m_entries[i];\n+        if (entry.m_locator[level - 1].IsPresent()) {\n+            ret.push_back(entry.m_locator[level - 1].cluster);\n+        }\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts (the (P,P) ones).\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& clusters = m_clustersets[level].m_clusters[quality];\n+        for (const auto& cluster : clusters) {\n+            cluster->GetConflicts(*this, ret);\n+        }\n+    }\n+    // Deduplicate the result (the same Cluster may appear multiple times).\n+    std::sort(ret.begin(), ret.end());\n+    ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+    return ret;\n+}\n+\n+Cluster* Cluster::CopyTo(TxGraphImpl& graph, int to_level) const noexcept\n+{\n+    // Construct an empty Cluster.\n+    auto ret = std::make_unique<Cluster>();\n+    auto ptr = ret.get();\n+    // Copy depgraph, mapping, and linearization/\n+    ptr->m_depgraph = m_depgraph;\n+    ptr->m_mapping = m_mapping;\n+    ptr->m_linearization = m_linearization;\n+    // Insert the new Cluster into the graph.\n+    graph.InsertCluster(to_level, std::move(ret), m_quality);\n+    // Update its Locators.\n+    ptr->Updated(graph);\n+    return ptr;\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator[m_level];\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Remove its linearization index from the Entry (if in main).\n+        if (m_level == 0) {\n+            entry.m_main_lin_index = LinearizationIndex(-1);\n+        }\n+        // - Mark it as missing/removed in the Entry's locator.\n+        graph.ClearLocator(m_level, idx);\n+        to_remove = to_remove.subspan(1);\n+    } while(!to_remove.empty());\n+\n+    auto quality = m_quality;\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (IsAcceptable(/*after_split=*/true)) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_level, m_quality, m_setindex, quality);\n+    Updated(graph);\n+}\n+\n+void Cluster::Clear(TxGraphImpl& graph) noexcept\n+{\n+    for (auto i : m_linearization) {\n+        graph.ClearLocator(m_level, m_mapping[i]);\n+    }\n+    m_depgraph = {};\n+    m_linearization.clear();\n+    m_mapping.clear();\n+}\n+\n+void Cluster::LevelDown(TxGraphImpl& graph) noexcept\n+{\n+    int level = m_level;\n+    Assume(level > 0);\n+    for (auto i : m_linearization) {\n+        GraphIndex idx = m_mapping[i];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[level].SetMissing();\n+    }\n+    auto quality = m_quality;\n+    auto cluster = graph.ExtractCluster(level, quality, m_setindex);\n+    graph.InsertCluster(level - 1, std::move(cluster), quality);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = IsAcceptable(/*after_split=*/true) ? QualityLevel::ACCEPTABLE\n+                                                                  : QualityLevel::NEEDS_RELINEARIZE;\n+    // If we're going to produce ACCEPTABLE clusters (i.e., when in NEEDS_SPLIT_ACCEPTABLE), we\n+    // need to post-linearize to make sure the split-out versions are all connected (as\n+    // connectivity may have changed by removing part of the cluster). This could be done on each\n+    // resulting split-out cluster separately, but it is simpler to do it once up front before\n+    // splitting. This step is not necessary if the resulting clusters are NEEDS_RELINEARIZE, as\n+    // they will be post-linearized anyway in MakeAcceptable().\n+    if (new_quality == QualityLevel::ACCEPTABLE) {\n+        PostLinearize(m_depgraph, m_linearization);\n+    }\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_level, m_quality, m_setindex, new_quality);\n+            // If this made the quality ACCEPTABLE or OPTIMAL, we need to compute and cache its\n+            // chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(m_level, std::move(new_cluster), new_quality);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator[m_level].SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator[m_level];\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator[m_level];\n+            auto& parent = graph.m_entries[it->first].m_locator[m_level];\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+    ret->m_level = -1;\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters.back()->m_level = level;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+    // The specified level must exist.\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& clusterset = m_clustersets[level];\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    cluster->m_level = level;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && size_t(level) < m_clustersets.size());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level and therefore be\n+        // implicitly existing at this level too.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster, int to_level) noexcept\n+{\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from the level it was found at to higher levels, if any.\n+    while (level < to_level) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing double work later.\n+        MakeAcceptable(*cluster);\n+        ++level;\n+        auto new_cluster = cluster->CopyTo(*this, level);\n+        cluster = new_cluster;\n+    }\n+    return cluster;\n+}\n+\n+void TxGraphImpl::ApplyRemovals(int up_to_level) noexcept\n+{\n+    Assume(up_to_level >= 0 && size_t(up_to_level) < m_clustersets.size());\n+    for (int level = 0; level <= up_to_level; ++level) {\n+        auto& clusterset = m_clustersets[level];\n+        auto& to_remove = clusterset.m_to_remove;\n+        // Skip if there is nothing to remove in this level.\n+        if (to_remove.empty()) continue;\n+        // Pull in all Clusters that are not in the ClusterSet at level level.\n+        for (GraphIndex index : to_remove) {\n+            auto cluster = FindCluster(index, level);\n+            if (cluster != nullptr) PullIn(cluster, level);\n+        }\n+        // Group the set of to-be-removed entries by Cluster*.\n+        std::sort(to_remove.begin(), to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+            return std::less{}(m_entries[a].m_locator[level].cluster, m_entries[b].m_locator[level].cluster);\n+        });\n+        // Process per Cluster.\n+        std::span to_remove_span{to_remove};\n+        while (!to_remove_span.empty()) {\n+            Cluster* cluster = m_entries[to_remove_span.front()].m_locator[level].cluster;\n+            if (cluster != nullptr) {\n+                // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+                // can pop off whatever applies to it.\n+                cluster->ApplyRemovals(*this, to_remove_span);\n+            } else {\n+                // Otherwise, skip this already-removed entry. This may happen when\n+                // RemoveTransaction was called twice on the same Ref, for example.\n+                to_remove_span = to_remove_span.subspan(1);\n+            }\n+        }\n+        to_remove.clear();\n+    }\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref, if any exists.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locators for both levels. The rest of the Entry information will not change,\n+        // so no need to invoke Cluster::Updated().\n+        for (int level = 0; level < MAX_LEVELS; ++level) {\n+            Locator& locator = entry.m_locator[level];\n+            if (locator.IsPresent()) {\n+                locator.cluster->UpdateMapping(locator.index, idx);\n+            }\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations or staged removals remain as we'd need\n+    // to rewrite them. It is easier to delay the compaction until they have been applied.\n+    for (auto& clusterset : m_clustersets) {\n+        if (!clusterset.m_deps_to_add.empty()) return;\n+        if (!clusterset.m_to_remove.empty()) return;\n+        if (!clusterset.m_removed.empty()) return;\n+    }\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step below (which might\n+    // invalidate them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        for (int level = 0; level < MAX_LEVELS; ++level) {\n+            Assume(!entry.m_locator[level].IsPresent());\n+        }\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals(cluster.m_level);\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll(int up_to_level) noexcept\n+{\n+    Assume(up_to_level >= 0 && size_t(up_to_level) < m_clustersets.size());\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals(up_to_level);\n+    for (int level = 0; level <= up_to_level; ++level) {\n+        for (auto quality : {QualityLevel::NEEDS_SPLIT, QualityLevel::NEEDS_SPLIT_ACCEPTABLE}) {\n+            auto& queue = m_clustersets[level].m_clusters[int(quality)];\n+            while (!queue.empty()) {\n+                Split(*queue.back().get());\n+            }\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters(int level) noexcept\n+{\n+    auto& clusterset = m_clustersets[level];\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (clusterset.m_group_data.has_value()) return;\n+\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient and/or oversized Clusters which just end up being split again anyway.\n+    SplitAll(level);\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_add entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : clusterset.m_deps_to_add) {\n+        auto par_cluster = FindCluster(par, level);\n+        auto chl_cluster = FindCluster(chl, level);\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Sort the dependencies by child Cluster.\n+    std::sort(clusterset.m_deps_to_add.begin(), clusterset.m_deps_to_add.end(), [&](auto& a, auto& b) noexcept {\n+        auto [_a_par, a_chl] = a;\n+        auto [_b_par, b_chl] = b;\n+        auto a_chl_cluster = FindCluster(a_chl, level);\n+        auto b_chl_cluster = FindCluster(b_chl, level);\n+        return std::less{}(a_chl_cluster, b_chl_cluster);\n+    });\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {\n+        /** Each PartitionData entry contains information about a single input Cluster. */\n+        struct PartitionData\n+        {\n+            /** The cluster this holds information for. */\n+            Cluster* cluster;\n+            /** All PartitionData entries belonging to the same partition are organized in a tree.\n+             *  Each element points to its parent, or to itself if it is the root. The root is then\n+             *  a representative for the entire tree, and can be found by walking upwards from any\n+             *  element. */\n+            PartitionData* parent;\n+            /** (only if this is a root, so when parent == this) An upper bound on the height of\n+             *  tree for this partition. */\n+            unsigned rank;\n+        };\n+        /** Information about each input Cluster. Sorted by Cluster* pointer. */\n+        std::vector<PartitionData> partition_data;\n+\n+        /** Given a Cluster, find its corresponding PartitionData. */\n+        auto locate_fn = [&](Cluster* arg) noexcept -> PartitionData* {\n+            auto it = std::lower_bound(partition_data.begin(), partition_data.end(), arg,\n+                                       [](auto& a, Cluster* ptr) noexcept { return a.cluster < ptr; });\n+            Assume(it != partition_data.end());\n+            Assume(it->cluster == arg);\n+            return &*it;\n+        };\n+\n+        /** Given a PartitionData, find the root of the tree it is in (its representative). */\n+        static constexpr auto find_root_fn = [](PartitionData* data) noexcept -> PartitionData* {\n+            while (data->parent != data) {\n+                // Replace pointers to parents with pointers to grandparents.\n+                // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Finding_set_representatives.\n+                auto par = data->parent;\n+                data->parent = par->parent;\n+                data = par;\n+            }\n+            return data;\n+        };\n+\n+        /** Given two PartitionDatas, union the partitions they are in, and return their\n+         *  representative. */\n+        static constexpr auto union_fn = [](PartitionData* arg1, PartitionData* arg2) noexcept {\n+            // Find the roots of the trees, and bail out if they are already equal (which would\n+            // mean they are in the same partition already).\n+            auto rep1 = find_root_fn(arg1);\n+            auto rep2 = find_root_fn(arg2);\n+            if (rep1 == rep2) return rep1;\n+            // Pick the lower-rank root to become a child of the higher-rank one.\n+            // See https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Union_by_rank.\n+            if (rep1->rank < rep2->rank) std::swap(rep1, rep2);\n+            rep2->parent = rep1;\n+            rep1->rank += (rep1->rank == rep2->rank);\n+            return rep1;\n+        };\n+\n+        // Start by initializing every Cluster as its own singleton partition.\n+        partition_data.resize(an_clusters.size());\n+        for (size_t i = 0; i < an_clusters.size(); ++i) {\n+            partition_data[i].cluster = an_clusters[i].first;\n+            partition_data[i].parent = &partition_data[i];\n+            partition_data[i].rank = 0;\n+        }\n+\n+        // Run through all parent/child pairs in m_deps_to_add, and union the\n+        // the partitions their Clusters are in.\n+        Cluster* last_chl_cluster{nullptr};\n+        PartitionData* last_partition{nullptr};\n+        for (const auto& [par, chl] : clusterset.m_deps_to_add) {\n+            auto par_cluster = FindCluster(par, level);\n+            auto chl_cluster = FindCluster(chl, level);\n+            // Nothing to do if parent and child are in the same Cluster.\n+            if (par_cluster == chl_cluster) continue;\n+            // Nothing to do if either parent or child transaction is removed already.\n+            if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+            Assume(par != chl);\n+            if (chl_cluster == last_chl_cluster) {\n+                // If the child Clusters is the same as the previous iteration, union with the\n+                // tree they were in, avoiding the need for another lookup. Note that m_deps_to_add\n+                // is sorted by child Cluster, so batches with the same child are expected.\n+                last_partition = union_fn(locate_fn(par_cluster), last_partition);\n+            } else {\n+                last_chl_cluster = chl_cluster;\n+                last_partition = union_fn(locate_fn(par_cluster), locate_fn(chl_cluster));\n+            }\n+        }\n+\n+        // Populate the an_clusters and an_deps data structures with the list of input Clusters,\n+        // and the input dependencies, annotated with the representative of the Cluster partition\n+        // it applies to.\n+        an_deps.reserve(clusterset.m_deps_to_add.size());\n+        auto deps_it = clusterset.m_deps_to_add.begin();\n+        for (size_t i = 0; i < partition_data.size(); ++i) {\n+            auto& data = partition_data[i];\n+            // Find the representative of the partition Cluster i is in, and store it with the\n+            // Cluster.\n+            auto rep = find_root_fn(&data)->cluster;\n+            Assume(an_clusters[i].second == nullptr);\n+            an_clusters[i].second = rep;\n+            // Find all dependencies whose child Cluster is Cluster i, and annotate them with rep.\n+            while (deps_it != clusterset.m_deps_to_add.end()) {\n+                auto [par, chl] = *deps_it;\n+                auto chl_cluster = FindCluster(chl, level);\n+                if (std::greater{}(chl_cluster, data.cluster)) break;\n+                // Skip dependencies that apply to earlier Clusters (those necessary are for\n+                // deleted transactions, as otherwise we'd have processed them already).\n+                if (chl_cluster == data.cluster) {\n+                    auto par_cluster = FindCluster(par, level);\n+                    // Also filter out dependencies applying to a removed parent.\n+                    if (par_cluster != nullptr) an_deps.emplace_back(*deps_it, rep);\n+                }\n+                ++deps_it;\n+            }\n+        }\n+    }\n+\n+    // Sort both an_clusters and an_deps by representative of the partition they are in, grouping\n+    // all those applying to the same partition together.\n+    std::sort(an_deps.begin(), an_deps.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+    std::sort(an_clusters.begin(), an_clusters.end(), [](auto& a, auto& b) noexcept { return a.second < b.second; });\n+\n+    // Translate the resulting cluster groups to the m_group_data structure, and the dependencies\n+    // back to m_deps_to_add.\n+    clusterset.m_group_data = GroupData{};\n+    clusterset.m_group_data->m_group_clusters.reserve(an_clusters.size());\n+    clusterset.m_group_data->m_group_oversized = false;\n+    clusterset.m_deps_to_add.clear();\n+    clusterset.m_deps_to_add.reserve(an_deps.size());\n+    auto an_deps_it = an_deps.begin();\n+    auto an_clusters_it = an_clusters.begin();\n+    while (an_clusters_it != an_clusters.end()) {\n+        // Process all clusters/dependencies belonging to the partition with representative rep.\n+        auto rep = an_clusters_it->second;\n+        // Create and initialize a new GroupData entry for the partition.\n+        auto& new_entry = clusterset.m_group_data->m_groups.emplace_back();\n+        new_entry.m_cluster_offset = clusterset.m_group_data->m_group_clusters.size();\n+        new_entry.m_cluster_count = 0;\n+        new_entry.m_deps_offset = clusterset.m_deps_to_add.size();\n+        new_entry.m_deps_count = 0;\n+        uint32_t total_count{0};\n+        // Add all its clusters to it (copying those from an_clusters to m_group_clusters).\n+        while (an_clusters_it != an_clusters.end() && an_clusters_it->second == rep) {\n+            clusterset.m_group_data->m_group_clusters.push_back(an_clusters_it->first);\n+            total_count += an_clusters_it->first->GetTxCount();\n+            ++an_clusters_it;\n+            ++new_entry.m_cluster_count;\n+        }\n+        // Add all its dependencies to it (copying those back from an_deps to m_deps_to_add).\n+        while (an_deps_it != an_deps.end() && an_deps_it->second == rep) {\n+            clusterset.m_deps_to_add.push_back(an_deps_it->first);\n+            ++an_deps_it;\n+            ++new_entry.m_deps_count;\n+        }\n+        // Detect oversizedness.\n+        if (total_count > m_max_cluster_count) {\n+            clusterset.m_group_data->m_group_oversized = true;\n+        }\n+    }\n+    Assume(an_deps_it == an_deps.end());\n+    Assume(an_clusters_it == an_clusters.end());\n+    clusterset.m_oversized = clusterset.m_group_data->m_group_oversized;\n+    Compact();\n+}\n+\n+void TxGraphImpl::Merge(std::span<Cluster*> to_merge) noexcept\n+{\n+    Assume(!to_merge.empty());\n+    // Nothing to do if a group consists of just a single Cluster.\n+    if (to_merge.size() == 1) return;\n+\n+    // Move the largest Cluster to the front of to_merge. As all transactions in other to-be-merged\n+    // Clusters will be moved to that one, putting the largest one first minimizes the number of\n+    // moves.\n+    size_t max_size_pos{0};\n+    DepGraphIndex max_size = to_merge[max_size_pos]->GetTxCount();\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        DepGraphIndex size = to_merge[i]->GetTxCount();\n+        if (size > max_size) {\n+            max_size_pos = i;\n+            max_size = size;\n+        }\n+    }\n+    if (max_size_pos != 0) std::swap(to_merge[0], to_merge[max_size_pos]);\n+\n+    // Merge all further Clusters in the group into the first one, and delete them.\n+    for (size_t i = 1; i < to_merge.size(); ++i) {\n+        to_merge[0]->Merge(*this, *to_merge[i]);\n+        DeleteCluster(*to_merge[i]);\n+    }\n+}\n+\n+void TxGraphImpl::ApplyDependencies(int level) noexcept\n+{\n+    auto& clusterset = m_clustersets[level];\n+    // Do not bother computing groups if we already know the result will be oversized.\n+    if (clusterset.m_oversized == true) return;\n+    // Compute the groups of to-be-merged Clusters (which also applies all removals, and splits).\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    // Nothing to do if there are no dependencies to be added.\n+    if (clusterset.m_deps_to_add.empty()) return;\n+    // Dependencies cannot be applied if it would result in oversized clusters.\n+    if (clusterset.m_group_data->m_group_oversized) return;\n+\n+    // For each group of to-be-merged Clusters.\n+    for (const auto& group_data : clusterset.m_group_data->m_groups) {\n+        auto cluster_span = std::span{clusterset.m_group_data->m_group_clusters}\n+                                .subspan(group_data.m_cluster_offset, group_data.m_cluster_count);\n+        // Pull in all the Clusters that contain dependencies.\n+        for (Cluster*& cluster : cluster_span) {\n+            cluster = PullIn(cluster, level);\n+        }\n+        // Invoke Merge() to merge them into a single Cluster.\n+        Merge(cluster_span);\n+        // Actually apply all to-be-added dependencies (all parents and children from this grouping\n+        // belong to the same Cluster at this point because of the merging above).\n+        auto deps_span = std::span{clusterset.m_deps_to_add}\n+                             .subspan(group_data.m_deps_offset, group_data.m_deps_count);\n+        Assume(!deps_span.empty());\n+        const auto& loc = m_entries[deps_span[0].second].m_locator[level];\n+        Assume(loc.IsPresent());\n+        loc.cluster->ApplyDependencies(*this, deps_span);\n+    }\n+\n+    // Wipe the list of to-be-added dependencies now that they are applied.\n+    clusterset.m_deps_to_add.clear();\n+    Compact();\n+    // Also no further Cluster mergings are needed (note that we clear, but don't set to\n+    // std::nullopt, as that would imply the groupings are unknown).\n+    clusterset.m_group_data = GroupData{};\n+}\n+\n+void Cluster::Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept\n+{\n+    // We can only relinearize Clusters that do not need splitting.\n+    Assume(!NeedsSplitting());\n+    // No work is required for Clusters which are already optimally linearized.\n+    if (IsOptimal()) return;\n+    // Invoke the actual linearization algorithm (passing in the existing one).\n+    uint64_t rng_seed = graph.m_rng.rand64();\n+    auto [linearization, optimal] = Linearize(m_depgraph, max_iters, rng_seed, m_linearization);\n+    // Postlinearize if the result isn't optimal already. This guarantees (among other things)\n+    // that the chunks of the resulting linearization are all connected.\n+    if (!optimal) PostLinearize(m_depgraph, linearization);\n+    // Update the linearization.\n+    m_linearization = std::move(linearization);\n+    // Update the Cluster's quality.\n+    auto new_quality = optimal ? QualityLevel::OPTIMAL : QualityLevel::ACCEPTABLE;\n+    graph.SetClusterQuality(m_level, m_quality, m_setindex, new_quality);\n+    // Update the Entry objects.\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::MakeAcceptable(Cluster& cluster) noexcept\n+{\n+    // Relinearize the Cluster if needed.\n+    if (!cluster.NeedsSplitting() && !cluster.IsAcceptable()) {\n+        cluster.Relinearize(*this, 10000);\n+    }\n+}\n+\n+void TxGraphImpl::MakeAllAcceptable(int level) noexcept\n+{\n+    ApplyDependencies(level);\n+    if (m_clustersets[level].m_oversized == true) return;\n+    auto& queue = m_clustersets[level].m_clusters[int(QualityLevel::NEEDS_RELINEARIZE)];\n+    while (!queue.empty()) {\n+        MakeAcceptable(*queue.back().get());\n+    }\n+}\n+\n+Cluster::Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept\n+{\n+    // Create a new transaction in the DepGraph, and remember its position in m_mapping.\n+    auto cluster_idx = m_depgraph.AddTransaction(feerate);\n+    m_mapping.push_back(graph_index);\n+    m_linearization.push_back(cluster_idx);\n+}\n+\n+TxGraph::Ref TxGraphImpl::AddTransaction(const FeePerWeight& feerate) noexcept\n+{\n+    // Construct a new Ref.\n+    Ref ret;\n+    // Construct a new Entry, and link it with the Ref.\n+    auto idx = m_entries.size();\n+    m_entries.emplace_back();\n+    auto& entry = m_entries.back();\n+    entry.m_ref = &ret;\n+    GetRefGraph(ret) = this;\n+    GetRefIndex(ret) = idx;\n+    // Construct a new singleton Cluster (which is necessarily optimally linearized).\n+    auto cluster = std::make_unique<Cluster>(*this, feerate, idx);\n+    auto cluster_ptr = cluster.get();\n+    int level = m_clustersets.size() - 1;\n+    InsertCluster(level, std::move(cluster), QualityLevel::OPTIMAL);\n+    cluster_ptr->Updated(*this);\n+    ++m_clustersets[level].m_txcount;\n+    // Return the Ref.\n+    return ret;\n+}\n+\n+void TxGraphImpl::RemoveTransaction(const Ref& arg) noexcept\n+{\n+    // Don't do anything if the Ref is empty (which may be indicative of the transaction already\n+    // having been removed).\n+    if (GetRefGraph(arg) == nullptr) return;\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the Cluster the transaction is in, and stop if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), m_clustersets.size() - 1);\n+    if (cluster == nullptr) return;\n+    // Remember that the transaction is to be removed.\n+    auto& clusterset = m_clustersets.back();\n+    clusterset.m_to_remove.push_back(GetRefIndex(arg));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    clusterset.m_group_data.reset();\n+    if (clusterset.m_oversized == true) clusterset.m_oversized = std::nullopt;\n+}\n+\n+void TxGraphImpl::AddDependency(const Ref& parent, const Ref& child) noexcept\n+{\n+    // Don't do anything if either Ref is empty (which may be indicative of it having already been\n+    // removed).\n+    if (GetRefGraph(parent) == nullptr || GetRefGraph(child) == nullptr) return;\n+    Assume(GetRefGraph(parent) == this && GetRefGraph(child) == this);\n+    // Don't do anything if this is a dependency on self.\n+    if (GetRefIndex(parent) == GetRefIndex(child)) return;\n+    // Find the Cluster the parent and child transaction are in, and stop if either appears to be\n+    // already removed.\n+    auto par_cluster = FindCluster(GetRefIndex(parent), m_clustersets.size() - 1);\n+    if (par_cluster == nullptr) return;\n+    auto chl_cluster = FindCluster(GetRefIndex(child), m_clustersets.size() - 1);\n+    if (chl_cluster == nullptr) return;\n+    // Remember that this dependency is to be applied.\n+    auto& clusterset = m_clustersets.back();\n+    clusterset.m_deps_to_add.emplace_back(GetRefIndex(parent), GetRefIndex(child));\n+    // Wipe m_group_data (as it will need to be recomputed).\n+    clusterset.m_group_data.reset();\n+    if (clusterset.m_oversized == false) clusterset.m_oversized = std::nullopt;\n+}\n+\n+bool TxGraphImpl::Exists(const Ref& arg, bool main_only) noexcept\n+{\n+    if (GetRefGraph(arg) == nullptr) return false;\n+    Assume(GetRefGraph(arg) == this);\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    // Make sure the transaction isn't scheduled for removal.\n+    ApplyRemovals(level);\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    return cluster != nullptr;\n+}\n+\n+void Cluster::GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept\n+{\n+    /** The union of all ancestors to be returned. */\n+    SetType ancestors_union;\n+    // Process elements from the front of args, as long as they apply.\n+    while (!args.empty()) {\n+        if (args.front().first != this) break;\n+        ancestors_union |= m_depgraph.Ancestors(args.front().second);\n+        args = args.subspan(1);\n+    }\n+    Assume(ancestors_union.Any());\n+    // Translate all ancestors (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : ancestors_union) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        Assume(entry.m_ref != nullptr);\n+        output.push_back(entry.m_ref);\n+    }\n+}\n+\n+void Cluster::GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept\n+{\n+    /** The union of all descendants to be returned. */\n+    SetType descendants_union;\n+    // Process elements from the front of args, as long as they apply.\n+    while (!args.empty()) {\n+        if (args.front().first != this) break;\n+        descendants_union |= m_depgraph.Descendants(args.front().second);\n+        args = args.subspan(1);\n+    }\n+    Assume(descendants_union.Any());\n+    // Translate all descendants (in arbitrary order) to Refs (if they have any), and return them.\n+    for (auto idx : descendants_union) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        Assume(entry.m_ref != nullptr);\n+        output.push_back(entry.m_ref);\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> Cluster::GetClusterRefs(const TxGraphImpl& graph) noexcept\n+{\n+    std::vector<TxGraph::Ref*> ret;\n+    ret.reserve(m_linearization.size());\n+    // Translate all transactions in the Cluster (in linearization order) to Refs.\n+    for (auto idx : m_linearization) {\n+        const auto& entry = graph.m_entries[m_mapping[idx]];\n+        Assume(entry.m_ref != nullptr);\n+        ret.push_back(entry.m_ref);\n+    }\n+    return ret;\n+}\n+\n+FeePerWeight Cluster::GetIndividualFeerate(DepGraphIndex idx) noexcept\n+{\n+    return FeePerWeight::FromFeeFrac(m_depgraph.FeeRate(idx));\n+}\n+\n+void Cluster::MakeTransactionsMissing(TxGraphImpl& graph) noexcept\n+{\n+    // Mark all transactions of a Cluster missing, needed when aborting staging, so that the\n+    // corresponding Locators don't retain references into aborted Clusters.\n+    for (auto ci : m_linearization) {\n+        GraphIndex idx = m_mapping[ci];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[m_level].SetMissing();\n+    }\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestors(const Ref& arg, bool main_only) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    std::pair<Cluster*, DepGraphIndex> match = {cluster, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index};\n+    auto matches = std::span(&match, 1);\n+    std::vector<TxGraph::Ref*> ret;\n+    cluster->GetAncestorRefs(*this, matches, ret);\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendants(const Ref& arg, bool main_only) noexcept\n+{\n+    // Return the empty vector if the Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    std::pair<Cluster*, DepGraphIndex> match = {cluster, m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index};\n+    auto matches = std::span(&match, 1);\n+    std::vector<TxGraph::Ref*> ret;\n+    cluster->GetDescendantRefs(*this, matches, ret);\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetAncestorsUnion(std::span<const Ref* const> args, bool main_only) noexcept\n+{\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+\n+    // Translate args to matches.\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> matches;\n+    matches.reserve(args.size());\n+    for (auto arg : args) {\n+        // Skip empty Refs.\n+        if (GetRefGraph(*arg) == nullptr) continue;\n+        Assume(GetRefGraph(*arg) == this);\n+        // Find the Cluster the argument is in, and skip if none is found.\n+        auto cluster = FindCluster(GetRefIndex(*arg), level);\n+        if (cluster == nullptr) continue;\n+        // Append to matches.\n+        matches.emplace_back(cluster, m_entries[GetRefIndex(*arg)].m_locator[cluster->m_level].index);\n+    }\n+    // Group by Cluster.\n+    std::sort(matches.begin(), matches.end(), [](auto& a, auto& b) noexcept { return std::less{}(a.first, b.first); });\n+    // Dispatch to the Clusters.\n+    std::span match_span(matches);\n+    std::vector<TxGraph::Ref*> ret;\n+    while (!match_span.empty()) {\n+        match_span.front().first->GetAncestorRefs(*this, match_span, ret);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetDescendantsUnion(std::span<const Ref* const> args, bool main_only) noexcept\n+{\n+    // Apply all dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Ancestry cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+\n+    // Translate args to matches.\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> matches;\n+    matches.reserve(args.size());\n+    for (auto arg : args) {\n+        // Skip empty Refs.\n+        if (GetRefGraph(*arg) == nullptr) continue;\n+        Assume(GetRefGraph(*arg) == this);\n+        // Find the Cluster the argument is in, and skip if none is found.\n+        auto cluster = FindCluster(GetRefIndex(*arg), level);\n+        if (cluster == nullptr) continue;\n+        // Append to matches.\n+        matches.emplace_back(cluster, m_entries[GetRefIndex(*arg)].m_locator[cluster->m_level].index);\n+    }\n+    // Group by Cluster.\n+    std::sort(matches.begin(), matches.end(), [](auto& a, auto& b) noexcept { return std::less{}(a.first, b.first); });\n+    // Dispatch to the Clusters.\n+    std::span match_span(matches);\n+    std::vector<TxGraph::Ref*> ret;\n+    while (!match_span.empty()) {\n+        match_span.front().first->GetDescendantRefs(*this, match_span, ret);\n+    }\n+    return ret;\n+}\n+\n+std::vector<TxGraph::Ref*> TxGraphImpl::GetCluster(const Ref& arg, bool main_only) noexcept\n+{\n+    // Return the empty vector if the Ref is empty (which may be indicative of the transaction\n+    // having been removed already.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be incorrect otherwise.\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    // Cluster linearization cannot be known if unapplied dependencies remain.\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Find the Cluster the argument is in, and return the empty vector if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), level);\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then dispatch to it.\n+    MakeAcceptable(*cluster);\n+    return cluster->GetClusterRefs(*this);\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::GetTransactionCount(bool main_only) noexcept\n+{\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyRemovals(level);\n+    return m_clustersets[level].m_txcount;\n+}\n+\n+FeePerWeight TxGraphImpl::GetIndividualFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Find the cluster the argument is in (the level does not matter as individual feerates will\n+    // be identical if it occurs in both), and return the empty FeePerWeight if it isn't in any.\n+    Cluster* cluster{nullptr};\n+    for (int level = 0; size_t(level) < m_clustersets.size(); ++level) {\n+        // Apply removals, so that we can correctly report FeePerWeight{} for non-existing\n+        // transactions.\n+        ApplyRemovals(level);\n+        if (m_entries[GetRefIndex(arg)].m_locator[level].IsPresent()) {\n+            cluster = m_entries[GetRefIndex(arg)].m_locator[level].cluster;\n+            break;\n+        }\n+    }\n+    if (cluster == nullptr) return {};\n+    // Dispatch to the Cluster.\n+    return cluster->GetIndividualFeerate(m_entries[GetRefIndex(arg)].m_locator[cluster->m_level].index);\n+}\n+\n+FeePerWeight TxGraphImpl::GetMainChunkFeerate(const Ref& arg) noexcept\n+{\n+    // Return the empty FeePerWeight if the passed Ref is empty.\n+    if (GetRefGraph(arg) == nullptr) return {};\n+    Assume(GetRefGraph(arg) == this);\n+    // Apply all removals and dependencies, as the result might be inaccurate otherwise.\n+    ApplyDependencies(/*level=*/0);\n+    // Chunk feerates cannot be accurately known if unapplied dependencies remain.\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n+    // Find the cluster the argument is in, and return the empty FeePerWeight if it isn't in any.\n+    auto cluster = FindCluster(GetRefIndex(arg), 0);\n+    if (cluster == nullptr) return {};\n+    // Make sure the Cluster has an acceptable quality level, and then return the transaction's\n+    // chunk feerate.\n+    MakeAcceptable(*cluster);\n+    const auto& entry = m_entries[GetRefIndex(arg)];\n+    return entry.m_main_chunk_feerate;\n+}\n+\n+bool TxGraphImpl::IsOversized(bool main_only) noexcept\n+{\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    auto& clusterset = m_clustersets[level];\n+    if (clusterset.m_oversized.has_value()) {\n+        // Return cached value if known.\n+        return *clusterset.m_oversized;\n+    }\n+    // Find which Clusters will need to be merged together, as that is where the oversize\n+    // property is assessed.\n+    GroupClusters(level);\n+    Assume(clusterset.m_group_data.has_value());\n+    clusterset.m_oversized = clusterset.m_group_data->m_group_oversized;\n+    return *clusterset.m_oversized;\n+}\n+\n+void TxGraphImpl::StartStaging() noexcept\n+{\n+    Assume(m_clustersets.size() < MAX_LEVELS);\n+    // Apply all remaining dependencies in main before creating a staging graph. Once staging\n+    // exists, we cannot merge Clusters anymore (because of interference with Clusters being\n+    // pulled into staging), so to make sure all inspectors are available (if not oversized), do\n+    // all merging work now. Call SplitAll() first, so that even if ApplyDependencies does not do\n+    // any thing due to knowing the result is oversized, splitting is still performed.\n+    SplitAll(m_clustersets.size() - 1);\n+    ApplyDependencies(m_clustersets.size() - 1);\n+    // Construct a new graph.\n+    m_clustersets.emplace_back();\n+    // Copy statistics, precomputed data, and to-be-applied dependencies (only if oversized) to\n+    // the new graph. To-be-applied removals will always be empty at this point.\n+    auto& stage = m_clustersets.back();\n+    auto& main = *(m_clustersets.rbegin() + 1);\n+    stage.m_txcount = main.m_txcount;\n+    stage.m_deps_to_add = main.m_deps_to_add;\n+    stage.m_group_data = main.m_group_data;\n+    stage.m_oversized = main.m_oversized;\n+    Assume(stage.m_oversized.has_value());\n+}\n+\n+void TxGraphImpl::AbortStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    // Mark all removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created).\n+    for (auto idx : stage.m_removed) {\n+        m_entries[idx].m_locator[stage_level].SetMissing();\n+    }\n+    // Do the same with the non-removed transactions in staging Clusters.\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        for (auto& cluster : stage.m_clusters[quality]) {\n+            cluster->MakeTransactionsMissing(*this);\n+        }\n+    }\n+    // Destroy the staging graph data.\n+    m_clustersets.pop_back();\n+    Compact();\n+    if (!m_clustersets.back().m_group_data.has_value()) {\n+        // In case m_oversized in main was kept after a Ref destruction while staging exists, we\n+        // need to re-evaluate m_oversized now.\n+        m_clustersets.back().m_oversized = std::nullopt;\n+    }\n+}\n+\n+void TxGraphImpl::CommitStaging() noexcept\n+{\n+    Assume(m_clustersets.size() > 1);\n+    int stage_level = m_clustersets.size() - 1;\n+    int main_level = stage_level - 1;\n+    auto& stage = m_clustersets[stage_level];\n+    auto& main = m_clustersets[main_level];\n+    // Delete all conflicting Clusters in main_level, to make place for moving the staging ones\n+    // there. All of these have been PullIn()'d to stage_level before.\n+    auto conflicts = GetConflicts();\n+    for (Cluster* conflict : conflicts) {\n+        conflict->Clear(*this);\n+        DeleteCluster(*conflict);\n+    }\n+    // Mark the removed transactions as Missing (so the stage_level locator for these transactions\n+    // can be reused if another staging is created0.\n+    for (auto idx : stage.m_removed) {\n+        m_entries[idx].m_locator[stage_level].SetMissing();\n+    }\n+    // Then move all Clusters in staging to main.\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& stage_sets = stage.m_clusters[quality];\n+        while (!stage_sets.empty()) {\n+            stage_sets.back()->LevelDown(*this);\n+        }\n+    }\n+    // Move all statistics, precomputed data, and to-be-applied removals and dependencies.\n+    main.m_deps_to_add = std::move(stage.m_deps_to_add);\n+    main.m_to_remove = std::move(stage.m_to_remove);\n+    main.m_group_data = std::move(stage.m_group_data);\n+    main.m_oversized = std::move(stage.m_oversized);\n+    main.m_txcount = std::move(stage.m_txcount);\n+    // Delete the old staging graph, after all its information was moved to main.\n+    m_clustersets.pop_back();\n+    Compact();\n+}\n+\n+void Cluster::SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept\n+{\n+    // Make sure the specified DepGraphIndex exists in this Cluster.\n+    Assume(m_depgraph.Positions()[idx]);\n+    // Bail out if the fee isn't actually being changed.\n+    if (m_depgraph.FeeRate(idx).fee == fee) return;\n+    // Update the fee, remember that relinearization will be necessary, and update the Entries\n+    // in the same Cluster.\n+    m_depgraph.FeeRate(idx).fee = fee;\n+    if (!NeedsSplitting()) {\n+        graph.SetClusterQuality(m_level, m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+    } else {\n+        graph.SetClusterQuality(m_level, m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    }\n+    Updated(graph);\n+}\n+\n+void TxGraphImpl::SetTransactionFee(const Ref& ref, int64_t fee) noexcept\n+{\n+    // Don't do anything if the passed Ref is empty.\n+    if (GetRefGraph(ref) == nullptr) return;\n+    Assume(GetRefGraph(ref) == this);\n+    // Find the entry, its locator, and inform its Cluster about the new feerate, if any.\n+    auto& entry = m_entries[GetRefIndex(ref)];\n+    for (int level = 0; level < MAX_LEVELS; ++level) {\n+        auto& locator = entry.m_locator[level];\n+        if (locator.IsPresent()) {\n+            locator.cluster->SetFee(*this, locator.index, fee);\n+        }\n+    }\n+}\n+\n+std::strong_ordering TxGraphImpl::CompareMainOrder(const Ref& a, const Ref& b) noexcept\n+{\n+    // The references must not be empty.\n+    Assume(GetRefGraph(a) == this);\n+    Assume(GetRefGraph(b) == this);\n+    // Apply dependencies in main.\n+    ApplyDependencies(0);\n+    Assume(m_clustersets[0].m_deps_to_add.empty());\n+    // Make both involved Clusters acceptable, so chunk feerates are relevant.\n+    const auto& entry_a = m_entries[GetRefIndex(a)];\n+    const auto& entry_b = m_entries[GetRefIndex(b)];\n+    const auto& locator_a = entry_a.m_locator[0];\n+    const auto& locator_b = entry_b.m_locator[0];\n+    Assume(locator_a.IsPresent());\n+    Assume(locator_b.IsPresent());\n+    MakeAcceptable(*locator_a.cluster);\n+    MakeAcceptable(*locator_b.cluster);\n+    // Compare chunk feerates, and return result if it differs.\n+    auto feerate_cmp = FeeRateCompare(entry_b.m_main_chunk_feerate, entry_a.m_main_chunk_feerate);\n+    if (feerate_cmp < 0) return std::strong_ordering::less;\n+    if (feerate_cmp > 0) return std::strong_ordering::greater;\n+    // Compare Cluster* as tie-break for equal chunk feerates.\n+    if (locator_a.cluster != locator_b.cluster) return locator_a.cluster <=> locator_b.cluster;\n+    // As final tie-break, compare position within cluster linearization.\n+    return entry_a.m_main_lin_index <=> entry_b.m_main_lin_index;\n+}\n+\n+TxGraph::GraphIndex TxGraphImpl::CountDistinctClusters(std::span<const Ref* const> refs, bool main_only) noexcept\n+{\n+    size_t level = main_only ? 0 : m_clustersets.size() - 1;\n+    ApplyDependencies(level);\n+    Assume(m_clustersets[level].m_deps_to_add.empty());\n+    // Build a vector of Clusters that the specified Refs occur in.\n+    std::vector<Cluster*> clusters;\n+    clusters.reserve(refs.size());\n+    for (const Ref* ref : refs) {\n+        if (ref == nullptr) continue;\n+        if (GetRefGraph(*ref) == nullptr) continue;\n+        Assume(GetRefGraph(*ref) == this);\n+        auto cluster = FindCluster(GetRefIndex(*ref), level);\n+        if (cluster != nullptr) clusters.push_back(cluster);\n+    }\n+    // Count the number of distinct elements in clusters.\n+    std::sort(clusters.begin(), clusters.end());\n+    Cluster* last{nullptr};\n+    GraphIndex ret{0};\n+    for (Cluster* cluster : clusters) {\n+        ret += (cluster != last);\n+        last = cluster;\n+    }\n+    return ret;\n+}\n+\n+void Cluster::SanityCheck(const TxGraphImpl& graph, int level) const\n+{\n+    // There must be an m_mapping for each m_depgraph position (including holes).\n+    assert(m_depgraph.PositionRange() == m_mapping.size());\n+    // The linearization for this Cluster must contain every transaction once.\n+    assert(m_depgraph.TxCount() == m_linearization.size());\n+    // The number of transactions in a Cluster cannot exceed m_max_cluster_count.\n+    assert(m_linearization.size() <= graph.m_max_cluster_count);\n+    // The level must match the level the Cluster occurs in.\n+    assert(m_level == level);\n+    // m_quality and m_setindex are checked in TxGraphImpl::SanityCheck.\n+\n+    // Compute the chunking of m_linearization.\n+    LinearizationChunking linchunking(m_depgraph, m_linearization);\n+\n+    // Verify m_linearization.\n+    SetType m_done;\n+    LinearizationIndex linindex{0};\n+    assert(m_depgraph.IsAcyclic());\n+    for (auto lin_pos : m_linearization) {\n+        assert(lin_pos < m_mapping.size());\n+        const auto& entry = graph.m_entries[m_mapping[lin_pos]];\n+        // Check that the linearization is topological.\n+        m_done.Set(lin_pos);\n+        assert(m_done.IsSupersetOf(m_depgraph.Ancestors(lin_pos)));\n+        // Check that the Entry has a locator pointing back to this Cluster & position within it.\n+        assert(entry.m_locator[level].cluster == this);\n+        assert(entry.m_locator[level].index == lin_pos);\n+        // For top-level entries, check linearization position and chunk feerate.\n+        if (level == 0 && IsAcceptable()) {\n+            assert(entry.m_main_lin_index == linindex++);",
      "path": "src/txgraph.cpp",
      "position": null,
      "original_position": 1887,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001521035,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-19T21:22:27Z",
      "updated_at": "2025-03-19T21:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004325643",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004325643"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1887,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004544338",
      "pull_request_review_id": 2700705362,
      "id": 2004544338,
      "node_id": "PRRC_kwDOABII5853eutS",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 77,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1994854097,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe it would be helpful to explain in the header that AddTransaction() creates a Ref, which you're then expected to assign/move into your own container, which may be a subclass containing even more info about the tx, and then that serves as a permanent handle, even as the txgraph gets rearranged internally and that it's deleted from the graph either with RemoveTransaction explicitly or implicitly by destructing the Ref? Essentially expanding the \"Data type used to reference transactions within a TxGraph\" comment that's already there to be a bit more ELI5 maybe?\r\n\r\nIf you create an empty Ref (ie, construct it directly, not via AddTransaction) is there any way to associate that Ref with a TxGraph or is it forever useless as a Ref? Would it make any sense to have an AddTransaction variant that takes a Ref& argument rather than returning a new Ref? I guess equivalently, is an empty Ref useful for anything other than tests? Maybe \"Non-empty Refs can only be created using AddTx\" should be more explicit and say \"You want to use AddTransaction() rather than constructing a Ref directly\".",
      "created_at": "2025-03-20T00:34:09Z",
      "updated_at": "2025-03-20T00:34:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004544338",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004544338"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004553119",
      "pull_request_review_id": 2700724502,
      "id": 2004553119,
      "node_id": "PRRC_kwDOABII5853ew2f",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;",
      "path": "src/txgraph.cpp",
      "position": 27,
      "original_position": 27,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001315529,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sounds like this is something that can be reconsidered when we get a PR that introduces variant Clusters then. Mark as resolved for now?",
      "created_at": "2025-03-20T00:41:13Z",
      "updated_at": "2025-03-20T00:41:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004553119",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004553119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 27,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004931183",
      "pull_request_review_id": 2701470073,
      "id": 2004931183,
      "node_id": "PRRC_kwDOABII5853gNJv",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions.\n+ *\n+ *  The interface is designed to accommodate an implementation that only stores the transitive\n+ *  closure of dependencies, so when querying, if B spends C, then you can't distinguish between\n+ *  A spending B, or A spending both B and C.\n+ */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be cast to, and used as, this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. If it is not empty, the corresponding transaction is removed (in both\n+         *  main and staging, if it exists). */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it.\n+     *  If a staging graph exists, the new transaction is only created there. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. If a staging graph exists, the removal only happens\n+     *  there. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, the dependency adding has no effect. If, together with\n+     * the deletion of B also either A or C is deleted, there is no distinction between the\n+     * original order case and the reordered case.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n+    virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n+\n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */\n+    virtual void DoWork() noexcept = 0;\n+\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Determine whether the graph is oversized (contains a connected component of more than the\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n+     *  for oversized graphs. The mutators above are always available. Removing a transaction by\n+     *  destroying its Ref while staging exists will not clear main's oversizedness until staging\n+     *  is aborted or committed. */\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 117,
      "original_position": 133,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "If I'm understanding right, this seem like it makes `IsOversized()` largely unfixable by the client -- so the only reasonable strategy I can see is to do:\r\n\r\n```c++\r\n    StartStaging();\r\n    // change transactions\r\n    if (IsOversized() || otherwise_undesirable()) {\r\n        AbortStaging();\r\n    } else {\r\n        CommitStaging();`\r\n    }\r\n```\r\n\r\nThat's a very reasonable strategy of course, so this isn't a complaint! Just that if so, it seems like it should be documented a bit more clearly?  I wonder a bit if `CommitStaging()` should have an `Assume(G_FUZZING || !m_oversized)` or something...\r\n\r\n(In particular, if you ever end up with the main graph being oversized, I don't see how you can even discover which txs are contributing to the oversized-ness in order to remove them -- `GetCluster(ref)` will fail the `m_deps_to_add.empty()` check I think, so you can't use that, and if you do you'll just get a subset of the actual cluster that is within limits; same with `GetDescendants`)",
      "created_at": "2025-03-20T06:50:22Z",
      "updated_at": "2025-03-20T06:50:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004931183",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004931183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004952081",
      "pull_request_review_id": 2701505735,
      "id": 2004952081,
      "node_id": "PRRC_kwDOABII5853gSQR",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions.\n+ *\n+ *  The interface is designed to accommodate an implementation that only stores the transitive\n+ *  closure of dependencies, so when querying, if B spends C, then you can't distinguish between\n+ *  A spending B, or A spending both B and C.\n+ */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be cast to, and used as, this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. If it is not empty, the corresponding transaction is removed (in both\n+         *  main and staging, if it exists). */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it.\n+     *  If a staging graph exists, the new transaction is only created there. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. If a staging graph exists, the removal only happens\n+     *  there. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, the dependency adding has no effect. If, together with\n+     * the deletion of B also either A or C is deleted, there is no distinction between the\n+     * original order case and the reordered case.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n+    virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n+\n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */\n+    virtual void DoWork() noexcept = 0;\n+\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Determine whether the graph is oversized (contains a connected component of more than the\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n+     *  for oversized graphs. The mutators above are always available. Removing a transaction by\n+     *  destroying its Ref while staging exists will not clear main's oversizedness until staging\n+     *  is aborted or committed. */\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 117,
      "original_position": 133,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": 2004931183,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "see also the TODO item\r\n\r\n> * Ability to inspect the would-be-constructed clusters (so they can be \"fixed\" if they violate policy rules, as opposed to just accepted/rejected, before applying - this is needed for reorgs which are not optional).",
      "created_at": "2025-03-20T07:08:27Z",
      "updated_at": "2025-03-20T07:08:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004952081",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004952081"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004991819",
      "pull_request_review_id": 2701575596,
      "id": 2004991819,
      "node_id": "PRRC_kwDOABII5853gb9L",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions.\n+ *\n+ *  The interface is designed to accommodate an implementation that only stores the transitive\n+ *  closure of dependencies, so when querying, if B spends C, then you can't distinguish between\n+ *  A spending B, or A spending both B and C.\n+ */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be cast to, and used as, this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. If it is not empty, the corresponding transaction is removed (in both\n+         *  main and staging, if it exists). */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it.\n+     *  If a staging graph exists, the new transaction is only created there. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. If a staging graph exists, the removal only happens\n+     *  there. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, the dependency adding has no effect. If, together with\n+     * the deletion of B also either A or C is deleted, there is no distinction between the\n+     * original order case and the reordered case.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n+    virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n+\n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */\n+    virtual void DoWork() noexcept = 0;\n+\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Determine whether the graph is oversized (contains a connected component of more than the\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n+     *  for oversized graphs. The mutators above are always available. Removing a transaction by\n+     *  destroying its Ref while staging exists will not clear main's oversizedness until staging\n+     *  is aborted or committed. */\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 117,
      "original_position": 133,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": 2004931183,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "See #31553, which adds a `TxGraph::Trim` function that removes some subset of transactions + their descendants, such that the result is no longer oversized, in O(n log n) time.\n\nWhen I started this PR, the idea was to expose ways to inspect would-be-oversized clusters, so they could be fixed by the user, before committing.\n\nIt turned out that really nothing beats an internal \"figure it out, and fix it\" method in terms of efficiency and convenience, so that's what 31553 does. It's a bit of a design break compared to the rest of TxGraph, which lets the user make all decisions about the *content* of the graph, but it's very practical.\n\nI've fixed the TODO here to reflect this.",
      "created_at": "2025-03-20T07:42:21Z",
      "updated_at": "2025-03-20T08:05:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2004991819",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2004991819"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005061988",
      "pull_request_review_id": 2701701219,
      "id": 2005061988,
      "node_id": "PRRC_kwDOABII5853gtFk",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions.\n+ *\n+ *  The interface is designed to accommodate an implementation that only stores the transitive\n+ *  closure of dependencies, so when querying, if B spends C, then you can't distinguish between\n+ *  A spending B, or A spending both B and C.\n+ */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be cast to, and used as, this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. If it is not empty, the corresponding transaction is removed (in both\n+         *  main and staging, if it exists). */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it.\n+     *  If a staging graph exists, the new transaction is only created there. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. If a staging graph exists, the removal only happens\n+     *  there. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, the dependency adding has no effect. If, together with\n+     * the deletion of B also either A or C is deleted, there is no distinction between the\n+     * original order case and the reordered case.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n+    virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n+\n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */\n+    virtual void DoWork() noexcept = 0;\n+\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Determine whether the graph is oversized (contains a connected component of more than the\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n+     *  for oversized graphs. The mutators above are always available. Removing a transaction by\n+     *  destroying its Ref while staging exists will not clear main's oversizedness until staging\n+     *  is aborted or committed. */\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 117,
      "original_position": 133,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": 2004931183,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": ":+1: I think it makes sense for TxGraph to take care of all the topology checks and feerate comparison decisions, which includes finding the best txs (block building), finding the worst txs (eviction) and finding good subsets when limits would otherwise be exceeded (reorgs, \"rbf\"/\"carve out\" cases maybe). So this doesn't feel like a design break at all to me, but rather pretty much exactly parallel to `GetWorstMainChunk()` -- \"here's a bunch of txs that you want to remove\".",
      "created_at": "2025-03-20T08:38:03Z",
      "updated_at": "2025-03-20T08:38:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2005061988",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005061988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005075531",
      "pull_request_review_id": 2701725334,
      "id": 2005075531,
      "node_id": "PRRC_kwDOABII5853gwZL",
      "diff_hunk": "@@ -0,0 +1,2120 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster in staging, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyToStaging(TxGraphImpl& graph) const noexcept;\n+    /** Get the list of Clusters in main that conflict with this one (which is assumed to be in staging). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this staging Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeStagingTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from 1 (staging) to 0 (main). */\n+    void MoveToMain(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::array<std::vector<std::unique_ptr<Cluster>>, int(QualityLevel::NONE)> m_clusters;\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). This\n+         *  includes all entries which have an (R) removed locator at this level (staging only),\n+         *  plus optionally any transaction in m_unlinked. */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+\n+        ClusterSet() noexcept = default;\n+    };\n+\n+    /** The main ClusterSet. */\n+    ClusterSet m_main_clusterset;\n+    /** The staging ClusterSet, if any. */\n+    std::optional<ClusterSet> m_staging_clusterset;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing:\n+     *    - In the main graph:    the transaction does not exist in main.\n+     *    - In the staging graph: the transaction's existence is the same as in main. If it doesn't\n+     *                            exist in main, (M) in staging means it does not exist there\n+     *                            either. If it does exist in main, (M) in staging means the\n+     *                            cluster it is in has not been modified in staging, and thus the\n+     *                            transaction implicitly exists in staging too (without explicit\n+     *                            Cluster object; see PullIn() to create it in staging too).\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.\n+     * - (P,R): the transaction exists in main, but is removed in staging.\n+     *\n+     * When staging does not exist, only (M,M) and (P,M) are possible.\n+     */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** Internal information about each transaction in a TxGraphImpl. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified maximum cluster count. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count) noexcept :\n+        m_max_cluster_count(max_cluster_count)\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+    }\n+\n+    /** Destructor. */\n+    ~TxGraphImpl() noexcept;\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly, or in the level below and not\n+    *   removed), return the Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Get the index of the top level ClusterSet (staging if it exists, main otherwise). */\n+    int GetTopLevel() const noexcept { return m_staging_clusterset.has_value(); }\n+    /** Get the specified level (staging if it exists and main_only is not specified, main otherwise). */\n+    int GetSpecifiedLevel(bool main_only) const noexcept { return m_staging_clusterset.has_value() && !main_only; }\n+    /** Get a reference to the ClusterSet at the specified level (which must exist). */\n+    ClusterSet& GetClusterSet(int level) noexcept;\n+    const ClusterSet& GetClusterSet(int level) const noexcept;\n+    /** Make a transaction not exist at a specified level. It must currently exist there. */\n+    void ClearLocator(int level, GraphIndex index) noexcept;\n+    /** Find which Clusters in main conflict with ones in staging. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        // Mark the transaction as to be removed in all levels where it explicitly or implicitly\n+        // exists.\n+        bool exists_anywhere{false};\n+        bool exists{false};\n+        for (int level = 0; level <= GetTopLevel(); ++level) {\n+            if (entry.m_locator[level].IsPresent()) {\n+                exists_anywhere = true;\n+                exists = true;\n+            } else if (entry.m_locator[level].IsRemoved()) {\n+                exists = false;\n+            }\n+            if (exists) {\n+                auto& clusterset = GetClusterSet(level);\n+                clusterset.m_to_remove.push_back(idx);\n+                // Force recomputation of grouping data.\n+                clusterset.m_group_data = std::nullopt;\n+                // Do not wipe the oversized state of main if staging exists. The reason for this\n+                // is that the alternative would mean that cluster merges may need to be applied to\n+                // a formerly-oversized main graph while staging exists (to satisfy chunk feerate\n+                // queries into main, for example), and such merges could conflict with pulls of\n+                // some of their constituents into staging.\n+                if (level == GetTopLevel() && clusterset.m_oversized == true) {\n+                    clusterset.m_oversized = std::nullopt;\n+                }\n+            }\n+        }\n+        m_unlinked.push_back(idx);\n+        if (!exists_anywhere) Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  or staged removals referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** If cluster is not in staging, copy it there, and return a pointer to it. This has no\n+    *   effect if only a main graph exists, but if staging exists this modifies the locators of its\n+    *   transactions from inherited (P,M) to explicit (P,P). */\n+    Cluster* PullIn(Cluster* cluster) noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel) up to the specified level. */\n+    void ApplyRemovals(int up_to_level) noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting up to the specified level. */\n+    void SplitAll(int up_to_level) noexcept;\n+    /** Populate m_group_data based on m_deps_to_add in the specified level. */\n+    void GroupClusters(int level) noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters in the specified level. */\n+    void ApplyDependencies(int level) noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+    /** Make all Clusters at the specified level have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAllAcceptable(int level) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    void DoWork() noexcept final;\n+\n+    void StartStaging() noexcept final;\n+    void CommitStaging() noexcept final;\n+    void AbortStaging() noexcept final;\n+    bool HaveStaging() const noexcept final { return m_staging_clusterset.has_value(); }\n+\n+    bool Exists(const Ref& arg, bool main_only = false) noexcept final;\n+    FeePerWeight GetMainChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendantsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    GraphIndex GetTransactionCount(bool main_only = false) noexcept final;\n+    bool IsOversized(bool main_only = false) noexcept final;\n+    std::strong_ordering CompareMainOrder(const Ref& a, const Ref& b) noexcept final;\n+    GraphIndex CountDistinctClusters(std::span<const Ref* const> refs, bool main_only = false) noexcept final;\n+\n+    void SanityCheck() const final;\n+};\n+\n+TxGraphImpl::ClusterSet& TxGraphImpl::GetClusterSet(int level) noexcept\n+{\n+    if (level == 0) return m_main_clusterset;\n+    Assume(level == 1);\n+    Assume(m_staging_clusterset.has_value());\n+    return *m_staging_clusterset;\n+}\n+\n+const TxGraphImpl::ClusterSet& TxGraphImpl::GetClusterSet(int level) const noexcept\n+{\n+    if (level == 0) return m_main_clusterset;\n+    Assume(level == 1);\n+    Assume(m_staging_clusterset.has_value());\n+    return *m_staging_clusterset;\n+}\n+\n+void TxGraphImpl::ClearLocator(int level, GraphIndex idx) noexcept\n+{\n+    auto& entry = m_entries[idx];\n+    auto& clusterset = GetClusterSet(level);\n+    Assume(entry.m_locator[level].IsPresent());\n+    // Change the locator from Present to Missing or Removed.\n+    if (level == 0 || !entry.m_locator[level - 1].IsPresent()) {\n+        entry.m_locator[level].SetMissing();\n+    } else {\n+        entry.m_locator[level].SetRemoved();\n+        clusterset.m_removed.push_back(idx);\n+    }\n+    // Update the transaction count.\n+    --clusterset.m_txcount;\n+    // If clearing main, adjust the status of Locators of this transaction in staging, if it exists.\n+    if (level == 0 && GetTopLevel() == 1) {\n+        if (entry.m_locator[1].IsRemoved()) {\n+            entry.m_locator[1].SetMissing();\n+        } else if (!entry.m_locator[1].IsPresent()) {\n+            --m_staging_clusterset->m_txcount;\n+        }\n+    }\n+}\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator[m_level].SetPresent(this, idx);\n+    }\n+    // If this is for the main graph (level = 0), and the Cluster's quality is ACCEPTABLE or\n+    // OPTIMAL, compute its chunking and store its information in the Entry's m_main_lin_index\n+    // and m_main_chunk_feerate. These fields are only accessed after making the entire graph\n+    // ACCEPTABLE, so it is pointless to compute these if we haven't reached that quality level\n+    // yet.\n+    if (m_level == 0 && IsAcceptable()) {\n+        LinearizationChunking chunking(m_depgraph, m_linearization);\n+        LinearizationIndex lin_idx{0};\n+        // Iterate over the chunks.\n+        for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+            auto chunk = chunking.GetChunk(chunk_idx);\n+            Assume(chunk.transactions.Any());\n+            // Iterate over the transactions in the linearization, which must match those in chunk.\n+            do {\n+                DepGraphIndex idx = m_linearization[lin_idx];\n+                GraphIndex graph_idx = m_mapping[idx];\n+                auto& entry = graph.m_entries[graph_idx];\n+                entry.m_main_lin_index = lin_idx++;\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                Assume(chunk.transactions[idx]);\n+                chunk.transactions.Reset(idx);\n+            } while(chunk.transactions.Any());\n+        }\n+    }\n+}\n+\n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    Assume(m_level == 1);\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[0].IsPresent()) {\n+            out.push_back(entry.m_locator[0].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    Assume(GetTopLevel() == 1);\n+    auto& clusterset = GetClusterSet(1);\n+    std::vector<Cluster*> ret;\n+    // All main Clusters containing transactions in m_removed (so (P,R) ones) are conflicts.\n+    for (auto i : clusterset.m_removed) {\n+        auto& entry = m_entries[i];\n+        if (entry.m_locator[0].IsPresent()) {\n+            ret.push_back(entry.m_locator[0].cluster);\n+        }\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts (the (P,P) ones).\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& clusters = clusterset.m_clusters[quality];\n+        for (const auto& cluster : clusters) {\n+            cluster->GetConflicts(*this, ret);\n+        }\n+    }\n+    // Deduplicate the result (the same Cluster may appear multiple times).\n+    std::sort(ret.begin(), ret.end());\n+    ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+    return ret;\n+}\n+\n+Cluster* Cluster::CopyToStaging(TxGraphImpl& graph) const noexcept\n+{\n+    // Construct an empty Cluster.\n+    auto ret = std::make_unique<Cluster>();\n+    auto ptr = ret.get();\n+    // Copy depgraph, mapping, and linearization/\n+    ptr->m_depgraph = m_depgraph;\n+    ptr->m_mapping = m_mapping;\n+    ptr->m_linearization = m_linearization;\n+    // Insert the new Cluster into the graph.\n+    graph.InsertCluster(1, std::move(ret), m_quality);\n+    // Update its Locators.\n+    ptr->Updated(graph);\n+    return ptr;\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator[m_level];\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Remove its linearization index from the Entry (if in main).\n+        if (m_level == 0) {\n+            entry.m_main_lin_index = LinearizationIndex(-1);\n+        }\n+        // - Mark it as missing/removed in the Entry's locator.\n+        graph.ClearLocator(m_level, idx);\n+        to_remove = to_remove.subspan(1);\n+    } while(!to_remove.empty());\n+\n+    auto quality = m_quality;\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (IsAcceptable(/*after_split=*/true)) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_level, m_quality, m_setindex, quality);\n+    Updated(graph);\n+}\n+\n+void Cluster::Clear(TxGraphImpl& graph) noexcept\n+{\n+    for (auto i : m_linearization) {\n+        graph.ClearLocator(m_level, m_mapping[i]);\n+    }\n+    m_depgraph = {};\n+    m_linearization.clear();\n+    m_mapping.clear();\n+}\n+\n+void Cluster::MoveToMain(TxGraphImpl& graph) noexcept\n+{\n+    Assume(m_level == 1);\n+    for (auto i : m_linearization) {\n+        GraphIndex idx = m_mapping[i];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[1].SetMissing();\n+    }\n+    auto quality = m_quality;\n+    auto cluster = graph.ExtractCluster(1, quality, m_setindex);\n+    graph.InsertCluster(0, std::move(cluster), quality);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = IsAcceptable(/*after_split=*/true) ? QualityLevel::ACCEPTABLE\n+                                                                  : QualityLevel::NEEDS_RELINEARIZE;\n+    // If we're going to produce ACCEPTABLE clusters (i.e., when in NEEDS_SPLIT_ACCEPTABLE), we\n+    // need to post-linearize to make sure the split-out versions are all connected (as\n+    // connectivity may have changed by removing part of the cluster). This could be done on each\n+    // resulting split-out cluster separately, but it is simpler to do it once up front before\n+    // splitting. This step is not necessary if the resulting clusters are NEEDS_RELINEARIZE, as\n+    // they will be post-linearized anyway in MakeAcceptable().\n+    if (new_quality == QualityLevel::ACCEPTABLE) {\n+        PostLinearize(m_depgraph, m_linearization);\n+    }\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_level, m_quality, m_setindex, new_quality);\n+            // If this made the quality ACCEPTABLE or OPTIMAL, we need to compute and cache its\n+            // chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(m_level, std::move(new_cluster), new_quality);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator[m_level].SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator[m_level];\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator[m_level];\n+            auto& parent = graph.m_entries[it->first].m_locator[m_level];\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+TxGraphImpl::~TxGraphImpl() noexcept\n+{\n+    // If Refs outlive the TxGraphImpl they refer to, unlink them, so that their destructor does not\n+    // try to reach into a non-existing TxGraphImpl anymore.\n+    for (auto& entry : m_entries) {\n+        if (entry.m_ref != nullptr) {\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+        }\n+    }\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& clusterset = GetClusterSet(level);\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+    ret->m_level = -1;\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters.back()->m_level = level;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& clusterset = GetClusterSet(level);\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    cluster->m_level = level;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && level <= GetTopLevel());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level and therefore be\n+        // implicitly existing at this level too.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster) noexcept\n+{\n+    int to_level = GetTopLevel();\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from main to staging, if it's not already there.\n+    if (level == 0) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing double work later.\n+        MakeAcceptable(*cluster);\n+        cluster = cluster->CopyToStaging(*this);\n+    }\n+    return cluster;\n+}\n+\n+void TxGraphImpl::ApplyRemovals(int up_to_level) noexcept\n+{\n+    Assume(up_to_level >= 0 && up_to_level <= GetTopLevel());\n+    for (int level = 0; level <= up_to_level; ++level) {\n+        auto& clusterset = GetClusterSet(level);\n+        auto& to_remove = clusterset.m_to_remove;\n+        // Skip if there is nothing to remove in this level.\n+        if (to_remove.empty()) continue;\n+        // Pull in all Clusters that are not in staging.\n+        if (level == 1) {\n+            for (GraphIndex index : to_remove) {\n+                auto cluster = FindCluster(index, level);\n+                if (cluster != nullptr) PullIn(cluster);\n+            }\n+        }\n+        // Group the set of to-be-removed entries by Cluster*.\n+        std::sort(to_remove.begin(), to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+            return std::less{}(m_entries[a].m_locator[level].cluster, m_entries[b].m_locator[level].cluster);\n+        });\n+        // Process per Cluster.\n+        std::span to_remove_span{to_remove};\n+        while (!to_remove_span.empty()) {\n+            Cluster* cluster = m_entries[to_remove_span.front()].m_locator[level].cluster;\n+            if (cluster != nullptr) {\n+                // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+                // can pop off whatever applies to it.\n+                cluster->ApplyRemovals(*this, to_remove_span);\n+            } else {\n+                // Otherwise, skip this already-removed entry. This may happen when\n+                // RemoveTransaction was called twice on the same Ref, for example.\n+                to_remove_span = to_remove_span.subspan(1);\n+            }\n+        }\n+        to_remove.clear();\n+    }\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref, if any exists.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locators for both levels. The rest of the Entry information will not change,\n+        // so no need to invoke Cluster::Updated().\n+        for (int level = 0; level < MAX_LEVELS; ++level) {\n+            Locator& locator = entry.m_locator[level];\n+            if (locator.IsPresent()) {\n+                locator.cluster->UpdateMapping(locator.index, idx);\n+            }\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations or staged removals remain as we'd need\n+    // to rewrite them. It is easier to delay the compaction until they have been applied.\n+    if (!m_main_clusterset.m_deps_to_add.empty()) return;\n+    if (!m_main_clusterset.m_to_remove.empty()) return;\n+    if (!m_main_clusterset.m_removed.empty()) return;\n+    if (m_staging_clusterset.has_value()) {\n+        if (!m_staging_clusterset->m_deps_to_add.empty()) return;\n+        if (!m_staging_clusterset->m_to_remove.empty()) return;\n+        if (!m_staging_clusterset->m_removed.empty()) return;",
      "path": "src/txgraph.cpp",
      "position": 1015,
      "original_position": 1015,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Could tidy this up:\r\n\r\n```c++\r\n    if (!m_main_clusterset.empty()) return;\r\n    if (m_staging_clusterset.has_value() && !m_staging_clusterset->empty()) return;\r\n\r\nbool ClusterSet::empty() {\r\n    return m_deps_to_add.empty() && m_to_remove.empty() && m_removed.empty();\r\n}\r\n```",
      "created_at": "2025-03-20T08:46:57Z",
      "updated_at": "2025-03-20T09:01:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2005075531",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005075531"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1015,
      "original_line": 1015,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005207380",
      "pull_request_review_id": 2701946995,
      "id": 2005207380,
      "node_id": "PRRC_kwDOABII5853hQlU",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref (not pointing to any Entry). */\n+        Ref() noexcept = default;\n+        /** Test if this Ref is not empty. */\n+        explicit operator bool() const noexcept { return m_graph != nullptr; }\n+        /** Destroy this Ref. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeeFrac& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */\n+    virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n+    /** Return a vector of pointers to Ref objects for transactions which have been removed from\n+     *  the graph, and have not been destroyed yet. Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n+    [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n+\n+    /** Determine whether arg exists in this graph (i.e., was not removed). */\n+    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n+     *  does not exist. */\n+    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    /** Get the individual transaction feerate of transaction arg. Returns the empty FeeFrac if\n+     *  arg does not exist. */\n+    virtual FeeFrac GetIndividualFeerate(const Ref& arg) noexcept = 0;\n+    /** Get pointers to all transactions in the connected component (\"cluster\") which arg is in.\n+     *  The transactions will be returned in a topologically-valid order of acceptable quality.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 109,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909271584,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "\"acceptable quality\" is more than just a topologically valid order.\r\nIt refers to a linearization that may not be optimal but is the best we can achieve for that cluster within resource limitations.",
      "created_at": "2025-03-20T09:53:08Z",
      "updated_at": "2025-03-20T09:53:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2005207380",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005207380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005273964",
      "pull_request_review_id": 2702061968,
      "id": 2005273964,
      "node_id": "PRRC_kwDOABII5853hg1s",
      "diff_hunk": "@@ -164,11 +164,23 @@ class TxGraphImpl final : public TxGraph\n     /** Information about one group of Clusters to be merged. */\n     struct GroupEntry\n     {\n-        /** Which clusters are to be merged. */\n-        std::vector<Cluster*> m_clusters;\n-        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n-         *  pairs. */\n-        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */",
      "path": "src/txgraph.cpp",
      "position": 199,
      "original_position": 13,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "101a8ee3280e50c3272a80939b46a67faca838e4",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "In  101a8ee3280e50c3272a80939b46a67faca838e4 \"txgraph: (optimization) avoid per-group vectors for clusters & dependencies\"\r\n```suggestion\r\n        /** Where the dependencies for this cluster group in ClusterSet::m_deps_to_add start. */\r\n\r\n```",
      "created_at": "2025-03-20T10:27:58Z",
      "updated_at": "2025-03-20T10:27:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2005273964",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005273964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 199,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005673107",
      "pull_request_review_id": 2702791066,
      "id": 2005673107,
      "node_id": "PRRC_kwDOABII5853jCST",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions.\n+ *\n+ *  The interface is designed to accommodate an implementation that only stores the transitive\n+ *  closure of dependencies, so when querying, if B spends C, then you can't distinguish between\n+ *  A spending B, or A spending both B and C.\n+ */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be cast to, and used as, this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. If it is not empty, the corresponding transaction is removed (in both\n+         *  main and staging, if it exists). */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it.\n+     *  If a staging graph exists, the new transaction is only created there. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. If a staging graph exists, the removal only happens\n+     *  there. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, the dependency adding has no effect. If, together with\n+     * the deletion of B also either A or C is deleted, there is no distinction between the\n+     * original order case and the reordered case.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n+    virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n+\n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */\n+    virtual void DoWork() noexcept = 0;\n+\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Determine whether the graph is oversized (contains a connected component of more than the\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n+     *  for oversized graphs. The mutators above are always available. Removing a transaction by\n+     *  destroying its Ref while staging exists will not clear main's oversizedness until staging\n+     *  is aborted or committed. */\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 117,
      "original_position": 133,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": 2004931183,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> so the only reasonable strategy I can see is to do:\r\n\r\nThe other reason to not follow this strategy, aside from reorgs, is \"kindred eviction\", where the caller is in charge of gathering sufficient information try to get back to an un-oversized state in the staging area, using non-oversized main stage information as a guiding tool.",
      "created_at": "2025-03-20T13:40:22Z",
      "updated_at": "2025-03-20T13:40:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2005673107",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2005673107"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008491083",
      "pull_request_review_id": 2707582068,
      "id": 2008491083,
      "node_id": "PRRC_kwDOABII5853tyRL",
      "diff_hunk": "@@ -0,0 +1,2076 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;",
      "path": "src/txgraph.cpp",
      "position": 27,
      "original_position": 27,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "72a97c0a07ea6e5a95ab37c8d95e1ea02cff8e92",
      "in_reply_to_id": 2001315529,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Marking resolved.",
      "created_at": "2025-03-21T23:57:44Z",
      "updated_at": "2025-03-22T00:06:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2008491083",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008491083"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 27,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008491150",
      "pull_request_review_id": 2707582068,
      "id": 2008491150,
      "node_id": "PRRC_kwDOABII5853tySO",
      "diff_hunk": "@@ -164,11 +164,23 @@ class TxGraphImpl final : public TxGraph\n     /** Information about one group of Clusters to be merged. */\n     struct GroupEntry\n     {\n-        /** Which clusters are to be merged. */\n-        std::vector<Cluster*> m_clusters;\n-        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n-         *  pairs. */\n-        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */",
      "path": "src/txgraph.cpp",
      "position": 199,
      "original_position": 13,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "101a8ee3280e50c3272a80939b46a67faca838e4",
      "in_reply_to_id": 2005273964,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-03-21T23:58:00Z",
      "updated_at": "2025-03-22T00:06:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2008491150",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008491150"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 199,
      "original_line": 199,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008491413",
      "pull_request_review_id": 2707582068,
      "id": 2008491413,
      "node_id": "PRRC_kwDOABII5853tyWV",
      "diff_hunk": "@@ -0,0 +1,2120 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <set>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+/** The maximum number of levels a TxGraph can have (0 = main, 1 = staging). */\n+static constexpr int MAX_LEVELS{2};\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::ClusterSet::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster may have multiple disconnected components, which are all ACCEPTABLE. */\n+    NEEDS_SPLIT_ACCEPTABLE,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any ClusterSet::m_clusters.\n+     *  This must be the last entry in QualityLevel as ClusterSet::m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl::ClusterSet. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<MAX_CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::ClusterSet::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+    /** Which level this Cluster is at in the graph (-1=not inserted, 0=main, 1=staging). */\n+    int m_level{-1};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and ClusterSet). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable(bool after_split = false) const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL ||\n+               (after_split && m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE);\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT ||\n+               m_quality == QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Given a DepGraphIndex into this Cluster, find the corresponding GraphIndex. */\n+    GraphIndex GetClusterEntry(DepGraphIndex index) const noexcept { return m_mapping[index]; }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+    /** Create a copy of this Cluster in staging, returning a pointer to it (used by PullIn). */\n+    Cluster* CopyToStaging(TxGraphImpl& graph) const noexcept;\n+    /** Get the list of Clusters in main that conflict with this one (which is assumed to be in staging). */\n+    void GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept;\n+    /** Mark all the Entry objects belonging to this staging Cluster as missing. The Cluster must be\n+     *  deleted immediately after. */\n+    void MakeStagingTransactionsMissing(TxGraphImpl& graph) noexcept;\n+    /** Remove all transactions from a Cluster. */\n+    void Clear(TxGraphImpl& graph) noexcept;\n+    /** Change a Cluster's level from 1 (staging) to 0 (main). */\n+    void MoveToMain(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their ancestors to output. */\n+    void GetAncestorRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Process elements from the front of args that apply to this cluster, and append Refs for the\n+     *  union of their descendants to output. */\n+    void GetDescendantRefs(const TxGraphImpl& graph, std::span<std::pair<Cluster*, DepGraphIndex>>& args, std::vector<TxGraph::Ref*>& output) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+\n+    // Debugging functions.\n+\n+    void SanityCheck(const TxGraphImpl& graph, int level) const;\n+};\n+\n+/** The transaction graph, including staged changes.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl::ClusterSet).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * The Clusters are kept in one or two ClusterSet objects, one for the \"main\" graph, and one for\n+ * the proposed changes (\"staging\"). If a transaction occurs in both, they share the same Entry,\n+ * but there will be a separate Cluster per graph.\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+    /** This TxGraphImpl's maximum cluster count limit. */\n+    const DepGraphIndex m_max_cluster_count;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Where the clusters to be merged start in m_group_clusters. */\n+        uint32_t m_cluster_offset;\n+        /** How many clusters to merge. */\n+        uint32_t m_cluster_count;\n+        /** Where the dependencies for this cluster group in m_deps_to_add start. */\n+        uint32_t m_deps_offset;\n+        /** How many dependencies to add. */\n+        uint32_t m_deps_count;\n+    };\n+\n+    /** Information about all groups of Clusters to be merged. */\n+    struct GroupData\n+    {\n+        /** The groups of Clusters to be merged. */\n+        std::vector<GroupEntry> m_groups;\n+        /** Which clusters are to be merged. GroupEntry::m_cluster_offset indexes into this. */\n+        std::vector<Cluster*> m_group_clusters;\n+        /** Whether at least one of the groups cannot be applied because it would result in a\n+         *  Cluster that violates the cluster count limit. */\n+        bool m_group_oversized;\n+    };\n+\n+    /** The collection of all Clusters in main or staged. */\n+    struct ClusterSet\n+    {\n+        /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+        std::array<std::vector<std::unique_ptr<Cluster>>, int(QualityLevel::NONE)> m_clusters;\n+        /** Which removals have yet to be applied. */\n+        std::vector<GraphIndex> m_to_remove;\n+        /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+         *  into this. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+        /** Information about the merges to be performed, if known. */\n+        std::optional<GroupData> m_group_data = GroupData{};\n+        /** Which entries were removed in this ClusterSet (so they can be wiped on abort). This\n+         *  includes all entries which have an (R) removed locator at this level (staging only),\n+         *  plus optionally any transaction in m_unlinked. */\n+        std::vector<GraphIndex> m_removed;\n+        /** Total number of transactions in this graph (sum of all transaction counts in all\n+         *  Clusters, and for staging also those inherited from the main ClusterSet). */\n+        GraphIndex m_txcount{0};\n+        /** Whether this graph is oversized (if known). This roughly matches\n+         *  m_group_data->m_group_oversized, but may be known even if m_group_data is not. */\n+        std::optional<bool> m_oversized{false};\n+\n+        ClusterSet() noexcept = default;\n+    };\n+\n+    /** The main ClusterSet. */\n+    ClusterSet m_main_clusterset;\n+    /** The staging ClusterSet, if any. */\n+    std::optional<ClusterSet> m_staging_clusterset;\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears.\n+     *  Every Entry has MAX_LEVELS locators, as it may appear in one Cluster per level.\n+     *\n+     *  Each level of a Locator is in one of three states:\n+     *\n+     *  - (P)resent: actually occurs in a Cluster at that level.\n+     *\n+     *  - (M)issing:\n+     *    - In the main graph:    the transaction does not exist in main.\n+     *    - In the staging graph: the transaction's existence is the same as in main. If it doesn't\n+     *                            exist in main, (M) in staging means it does not exist there\n+     *                            either. If it does exist in main, (M) in staging means the\n+     *                            cluster it is in has not been modified in staging, and thus the\n+     *                            transaction implicitly exists in staging too (without explicit\n+     *                            Cluster object; see PullIn() to create it in staging too).\n+     *\n+     *  - (R)emoved: only possible in staging; it means the transaction exists in main, but is\n+     *               removed in staging.\n+     *\n+     * The following combinations are possible:\n+     * - (M,M): the transaction doesn't exist in either graph.\n+     * - (P,M): the transaction exists in both, but only exists explicitly in a Cluster object in\n+     *          main. Its existence in staging is inherited from main.\n+     * - (P,P): the transaction exists in both, and is materialized in both. Thus, the clusters\n+     *          and/or their linearizations may be different in main and staging.\n+     * - (M,P): the transaction is added in staging, and does not exist in main.\n+     * - (P,R): the transaction exists in main, but is removed in staging.\n+     *\n+     * When staging does not exist, only (M,M) and (P,M) are possible.\n+     */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (if cluster == nullptr: 0 = missing, -1 = removed). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing (= same as lower level, or non-existing if level 0). */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as removed (not allowed in level 0). */\n+        void SetRemoved() noexcept { cluster = nullptr; index = DepGraphIndex(-1); }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is missing. */\n+        bool IsMissing() const noexcept { return cluster == nullptr && index == 0; }\n+        /** Check if this Locator is removed. */\n+        bool IsRemoved() const noexcept { return cluster == nullptr && index == DepGraphIndex(-1); }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** Internal information about each transaction in a TxGraphImpl. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. ([0] = main, [1] = staged). */\n+        Locator m_locator[MAX_LEVELS];\n+        /** The chunk feerate of this transaction in main (if present in m_locator[0]). */\n+        FeePerWeight m_main_chunk_feerate;\n+        /** The position this transaction has in the main linearization (if present). */\n+        LinearizationIndex m_main_lin_index;\n+    };\n+\n+    /** The set of all transactions (in all levels combined). GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl with the specified maximum cluster count. */\n+    explicit TxGraphImpl(DepGraphIndex max_cluster_count) noexcept :\n+        m_max_cluster_count(max_cluster_count)\n+    {\n+        Assume(max_cluster_count >= 1);\n+        Assume(max_cluster_count <= MAX_CLUSTER_COUNT_LIMIT);\n+    }\n+\n+    /** Destructor. */\n+    ~TxGraphImpl() noexcept;\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** If idx exists in the specified level ClusterSet (explicitly, or in the level below and not\n+    *   removed), return the Cluster it is in. Otherwise, return nullptr. */\n+    Cluster* FindCluster(GraphIndex idx, int level) const noexcept;\n+    /** Extract a Cluster from its ClusterSet. */\n+    std::unique_ptr<Cluster> ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster into its ClusterSet. */\n+    ClusterSetIndex InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+    /** Get the index of the top level ClusterSet (staging if it exists, main otherwise). */\n+    int GetTopLevel() const noexcept { return m_staging_clusterset.has_value(); }\n+    /** Get the specified level (staging if it exists and main_only is not specified, main otherwise). */\n+    int GetSpecifiedLevel(bool main_only) const noexcept { return m_staging_clusterset.has_value() && !main_only; }\n+    /** Get a reference to the ClusterSet at the specified level (which must exist). */\n+    ClusterSet& GetClusterSet(int level) noexcept;\n+    const ClusterSet& GetClusterSet(int level) const noexcept;\n+    /** Make a transaction not exist at a specified level. It must currently exist there. */\n+    void ClearLocator(int level, GraphIndex index) noexcept;\n+    /** Find which Clusters in main conflict with ones in staging. */\n+    std::vector<Cluster*> GetConflicts() const noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        // Mark the transaction as to be removed in all levels where it explicitly or implicitly\n+        // exists.\n+        bool exists_anywhere{false};\n+        bool exists{false};\n+        for (int level = 0; level <= GetTopLevel(); ++level) {\n+            if (entry.m_locator[level].IsPresent()) {\n+                exists_anywhere = true;\n+                exists = true;\n+            } else if (entry.m_locator[level].IsRemoved()) {\n+                exists = false;\n+            }\n+            if (exists) {\n+                auto& clusterset = GetClusterSet(level);\n+                clusterset.m_to_remove.push_back(idx);\n+                // Force recomputation of grouping data.\n+                clusterset.m_group_data = std::nullopt;\n+                // Do not wipe the oversized state of main if staging exists. The reason for this\n+                // is that the alternative would mean that cluster merges may need to be applied to\n+                // a formerly-oversized main graph while staging exists (to satisfy chunk feerate\n+                // queries into main, for example), and such merges could conflict with pulls of\n+                // some of their constituents into staging.\n+                if (level == GetTopLevel() && clusterset.m_oversized == true) {\n+                    clusterset.m_oversized = std::nullopt;\n+                }\n+            }\n+        }\n+        m_unlinked.push_back(idx);\n+        if (!exists_anywhere) Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  or staged removals referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** If cluster is not in staging, copy it there, and return a pointer to it. This has no\n+    *   effect if only a main graph exists, but if staging exists this modifies the locators of its\n+    *   transactions from inherited (P,M) to explicit (P,P). */\n+    Cluster* PullIn(Cluster* cluster) noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel) up to the specified level. */\n+    void ApplyRemovals(int up_to_level) noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting up to the specified level. */\n+    void SplitAll(int up_to_level) noexcept;\n+    /** Populate m_group_data based on m_deps_to_add in the specified level. */\n+    void GroupClusters(int level) noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters in the specified level. */\n+    void ApplyDependencies(int level) noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+    /** Make all Clusters at the specified level have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAllAcceptable(int level) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    void DoWork() noexcept final;\n+\n+    void StartStaging() noexcept final;\n+    void CommitStaging() noexcept final;\n+    void AbortStaging() noexcept final;\n+    bool HaveStaging() const noexcept final { return m_staging_clusterset.has_value(); }\n+\n+    bool Exists(const Ref& arg, bool main_only = false) noexcept final;\n+    FeePerWeight GetMainChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetAncestorsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    std::vector<Ref*> GetDescendantsUnion(std::span<const Ref* const> args, bool main_only = false) noexcept final;\n+    GraphIndex GetTransactionCount(bool main_only = false) noexcept final;\n+    bool IsOversized(bool main_only = false) noexcept final;\n+    std::strong_ordering CompareMainOrder(const Ref& a, const Ref& b) noexcept final;\n+    GraphIndex CountDistinctClusters(std::span<const Ref* const> refs, bool main_only = false) noexcept final;\n+\n+    void SanityCheck() const final;\n+};\n+\n+TxGraphImpl::ClusterSet& TxGraphImpl::GetClusterSet(int level) noexcept\n+{\n+    if (level == 0) return m_main_clusterset;\n+    Assume(level == 1);\n+    Assume(m_staging_clusterset.has_value());\n+    return *m_staging_clusterset;\n+}\n+\n+const TxGraphImpl::ClusterSet& TxGraphImpl::GetClusterSet(int level) const noexcept\n+{\n+    if (level == 0) return m_main_clusterset;\n+    Assume(level == 1);\n+    Assume(m_staging_clusterset.has_value());\n+    return *m_staging_clusterset;\n+}\n+\n+void TxGraphImpl::ClearLocator(int level, GraphIndex idx) noexcept\n+{\n+    auto& entry = m_entries[idx];\n+    auto& clusterset = GetClusterSet(level);\n+    Assume(entry.m_locator[level].IsPresent());\n+    // Change the locator from Present to Missing or Removed.\n+    if (level == 0 || !entry.m_locator[level - 1].IsPresent()) {\n+        entry.m_locator[level].SetMissing();\n+    } else {\n+        entry.m_locator[level].SetRemoved();\n+        clusterset.m_removed.push_back(idx);\n+    }\n+    // Update the transaction count.\n+    --clusterset.m_txcount;\n+    // If clearing main, adjust the status of Locators of this transaction in staging, if it exists.\n+    if (level == 0 && GetTopLevel() == 1) {\n+        if (entry.m_locator[1].IsRemoved()) {\n+            entry.m_locator[1].SetMissing();\n+        } else if (!entry.m_locator[1].IsPresent()) {\n+            --m_staging_clusterset->m_txcount;\n+        }\n+    }\n+}\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator[m_level].SetPresent(this, idx);\n+    }\n+    // If this is for the main graph (level = 0), and the Cluster's quality is ACCEPTABLE or\n+    // OPTIMAL, compute its chunking and store its information in the Entry's m_main_lin_index\n+    // and m_main_chunk_feerate. These fields are only accessed after making the entire graph\n+    // ACCEPTABLE, so it is pointless to compute these if we haven't reached that quality level\n+    // yet.\n+    if (m_level == 0 && IsAcceptable()) {\n+        LinearizationChunking chunking(m_depgraph, m_linearization);\n+        LinearizationIndex lin_idx{0};\n+        // Iterate over the chunks.\n+        for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+            auto chunk = chunking.GetChunk(chunk_idx);\n+            Assume(chunk.transactions.Any());\n+            // Iterate over the transactions in the linearization, which must match those in chunk.\n+            do {\n+                DepGraphIndex idx = m_linearization[lin_idx];\n+                GraphIndex graph_idx = m_mapping[idx];\n+                auto& entry = graph.m_entries[graph_idx];\n+                entry.m_main_lin_index = lin_idx++;\n+                entry.m_main_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+                Assume(chunk.transactions[idx]);\n+                chunk.transactions.Reset(idx);\n+            } while(chunk.transactions.Any());\n+        }\n+    }\n+}\n+\n+void Cluster::GetConflicts(const TxGraphImpl& graph, std::vector<Cluster*>& out) const noexcept\n+{\n+    Assume(m_level == 1);\n+    for (auto i : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[i]];\n+        // For every transaction Entry in this Cluster, if it also exists in a lower-level Cluster,\n+        // then that Cluster conflicts.\n+        if (entry.m_locator[0].IsPresent()) {\n+            out.push_back(entry.m_locator[0].cluster);\n+        }\n+    }\n+}\n+\n+std::vector<Cluster*> TxGraphImpl::GetConflicts() const noexcept\n+{\n+    Assume(GetTopLevel() == 1);\n+    auto& clusterset = GetClusterSet(1);\n+    std::vector<Cluster*> ret;\n+    // All main Clusters containing transactions in m_removed (so (P,R) ones) are conflicts.\n+    for (auto i : clusterset.m_removed) {\n+        auto& entry = m_entries[i];\n+        if (entry.m_locator[0].IsPresent()) {\n+            ret.push_back(entry.m_locator[0].cluster);\n+        }\n+    }\n+    // Then go over all Clusters at this level, and find their conflicts (the (P,P) ones).\n+    for (int quality = 0; quality < int(QualityLevel::NONE); ++quality) {\n+        auto& clusters = clusterset.m_clusters[quality];\n+        for (const auto& cluster : clusters) {\n+            cluster->GetConflicts(*this, ret);\n+        }\n+    }\n+    // Deduplicate the result (the same Cluster may appear multiple times).\n+    std::sort(ret.begin(), ret.end());\n+    ret.erase(std::unique(ret.begin(), ret.end()), ret.end());\n+    return ret;\n+}\n+\n+Cluster* Cluster::CopyToStaging(TxGraphImpl& graph) const noexcept\n+{\n+    // Construct an empty Cluster.\n+    auto ret = std::make_unique<Cluster>();\n+    auto ptr = ret.get();\n+    // Copy depgraph, mapping, and linearization/\n+    ptr->m_depgraph = m_depgraph;\n+    ptr->m_mapping = m_mapping;\n+    ptr->m_linearization = m_linearization;\n+    // Insert the new Cluster into the graph.\n+    graph.InsertCluster(1, std::move(ret), m_quality);\n+    // Update its Locators.\n+    ptr->Updated(graph);\n+    return ptr;\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator[m_level];\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Remove its linearization index from the Entry (if in main).\n+        if (m_level == 0) {\n+            entry.m_main_lin_index = LinearizationIndex(-1);\n+        }\n+        // - Mark it as missing/removed in the Entry's locator.\n+        graph.ClearLocator(m_level, idx);\n+        to_remove = to_remove.subspan(1);\n+    } while(!to_remove.empty());\n+\n+    auto quality = m_quality;\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // First remove all removals at the end of the linearization.\n+    while (!m_linearization.empty() && todo[m_linearization.back()]) {\n+        todo.Reset(m_linearization.back());\n+        m_linearization.pop_back();\n+    }\n+    if (todo.None()) {\n+        // If no further removals remain, and thus all removals were at the end, we may be able\n+        // to leave the cluster at a better quality level.\n+        if (IsAcceptable(/*after_split=*/true)) {\n+            quality = QualityLevel::NEEDS_SPLIT_ACCEPTABLE;\n+        } else {\n+            quality = QualityLevel::NEEDS_SPLIT;\n+        }\n+    } else {\n+        // If more removals remain, filter those out of m_linearization.\n+        m_linearization.erase(std::remove_if(\n+            m_linearization.begin(),\n+            m_linearization.end(),\n+            [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+        quality = QualityLevel::NEEDS_SPLIT;\n+    }\n+    graph.SetClusterQuality(m_level, m_quality, m_setindex, quality);\n+    Updated(graph);\n+}\n+\n+void Cluster::Clear(TxGraphImpl& graph) noexcept\n+{\n+    for (auto i : m_linearization) {\n+        graph.ClearLocator(m_level, m_mapping[i]);\n+    }\n+    m_depgraph = {};\n+    m_linearization.clear();\n+    m_mapping.clear();\n+}\n+\n+void Cluster::MoveToMain(TxGraphImpl& graph) noexcept\n+{\n+    Assume(m_level == 1);\n+    for (auto i : m_linearization) {\n+        GraphIndex idx = m_mapping[i];\n+        auto& entry = graph.m_entries[idx];\n+        entry.m_locator[1].SetMissing();\n+    }\n+    auto quality = m_quality;\n+    auto cluster = graph.ExtractCluster(1, quality, m_setindex);\n+    graph.InsertCluster(0, std::move(cluster), quality);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    // Determine the new quality the split-off Clusters will have.\n+    QualityLevel new_quality = IsAcceptable(/*after_split=*/true) ? QualityLevel::ACCEPTABLE\n+                                                                  : QualityLevel::NEEDS_RELINEARIZE;\n+    // If we're going to produce ACCEPTABLE clusters (i.e., when in NEEDS_SPLIT_ACCEPTABLE), we\n+    // need to post-linearize to make sure the split-out versions are all connected (as\n+    // connectivity may have changed by removing part of the cluster). This could be done on each\n+    // resulting split-out cluster separately, but it is simpler to do it once up front before\n+    // splitting. This step is not necessary if the resulting clusters are NEEDS_RELINEARIZE, as\n+    // they will be post-linearized anyway in MakeAcceptable().\n+    if (new_quality == QualityLevel::ACCEPTABLE) {\n+        PostLinearize(m_depgraph, m_linearization);\n+    }\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_level, m_quality, m_setindex, new_quality);\n+            // If this made the quality ACCEPTABLE or OPTIMAL, we need to compute and cache its\n+            // chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(m_level, std::move(new_cluster), new_quality);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator[m_level].SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator[m_level];\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator[m_level];\n+            auto& parent = graph.m_entries[it->first].m_locator[m_level];\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+TxGraphImpl::~TxGraphImpl() noexcept\n+{\n+    // If Refs outlive the TxGraphImpl they refer to, unlink them, so that their destructor does not\n+    // try to reach into a non-existing TxGraphImpl anymore.\n+    for (auto& entry : m_entries) {\n+        if (entry.m_ref != nullptr) {\n+            GetRefGraph(*entry.m_ref) = nullptr;\n+        }\n+    }\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(int level, QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& clusterset = GetClusterSet(level);\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+    ret->m_level = -1;\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters.back()->m_level = level;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(int level, std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& clusterset = GetClusterSet(level);\n+    auto& quality_clusters = clusterset.m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    cluster->m_level = level;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(int level, QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(level, old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(level, std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_level, cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+Cluster* TxGraphImpl::FindCluster(GraphIndex idx, int level) const noexcept\n+{\n+    Assume(level >= 0 && level <= GetTopLevel());\n+    auto& entry = m_entries[idx];\n+    // Search the entry's locators from top to bottom.\n+    for (int l = level; l >= 0; --l) {\n+        // If the locator is missing, dig deeper; it may exist at a lower level and therefore be\n+        // implicitly existing at this level too.\n+        if (entry.m_locator[l].IsMissing()) continue;\n+        // If the locator has the entry marked as explicitly removed, stop.\n+        if (entry.m_locator[l].IsRemoved()) break;\n+        // Otherwise, we have found the topmost ClusterSet that contains this entry.\n+        return entry.m_locator[l].cluster;\n+    }\n+    // If no non-empty locator was found, or an explicitly removed was hit, return nothing.\n+    return nullptr;\n+}\n+\n+Cluster* TxGraphImpl::PullIn(Cluster* cluster) noexcept\n+{\n+    int to_level = GetTopLevel();\n+    if (to_level == 0) return cluster;\n+    int level = cluster->m_level;\n+    Assume(level <= to_level);\n+    // Copy the Cluster from main to staging, if it's not already there.\n+    if (level == 0) {\n+        // Make the Cluster Acceptable before copying. This isn't strictly necessary, but doing it\n+        // now avoids doing double work later.\n+        MakeAcceptable(*cluster);\n+        cluster = cluster->CopyToStaging(*this);\n+    }\n+    return cluster;\n+}\n+\n+void TxGraphImpl::ApplyRemovals(int up_to_level) noexcept\n+{\n+    Assume(up_to_level >= 0 && up_to_level <= GetTopLevel());\n+    for (int level = 0; level <= up_to_level; ++level) {\n+        auto& clusterset = GetClusterSet(level);\n+        auto& to_remove = clusterset.m_to_remove;\n+        // Skip if there is nothing to remove in this level.\n+        if (to_remove.empty()) continue;\n+        // Pull in all Clusters that are not in staging.\n+        if (level == 1) {\n+            for (GraphIndex index : to_remove) {\n+                auto cluster = FindCluster(index, level);\n+                if (cluster != nullptr) PullIn(cluster);\n+            }\n+        }\n+        // Group the set of to-be-removed entries by Cluster*.\n+        std::sort(to_remove.begin(), to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+            return std::less{}(m_entries[a].m_locator[level].cluster, m_entries[b].m_locator[level].cluster);\n+        });\n+        // Process per Cluster.\n+        std::span to_remove_span{to_remove};\n+        while (!to_remove_span.empty()) {\n+            Cluster* cluster = m_entries[to_remove_span.front()].m_locator[level].cluster;\n+            if (cluster != nullptr) {\n+                // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+                // can pop off whatever applies to it.\n+                cluster->ApplyRemovals(*this, to_remove_span);\n+            } else {\n+                // Otherwise, skip this already-removed entry. This may happen when\n+                // RemoveTransaction was called twice on the same Ref, for example.\n+                to_remove_span = to_remove_span.subspan(1);\n+            }\n+        }\n+        to_remove.clear();\n+    }\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref, if any exists.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locators for both levels. The rest of the Entry information will not change,\n+        // so no need to invoke Cluster::Updated().\n+        for (int level = 0; level < MAX_LEVELS; ++level) {\n+            Locator& locator = entry.m_locator[level];\n+            if (locator.IsPresent()) {\n+                locator.cluster->UpdateMapping(locator.index, idx);\n+            }\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations or staged removals remain as we'd need\n+    // to rewrite them. It is easier to delay the compaction until they have been applied.\n+    if (!m_main_clusterset.m_deps_to_add.empty()) return;\n+    if (!m_main_clusterset.m_to_remove.empty()) return;\n+    if (!m_main_clusterset.m_removed.empty()) return;\n+    if (m_staging_clusterset.has_value()) {\n+        if (!m_staging_clusterset->m_deps_to_add.empty()) return;\n+        if (!m_staging_clusterset->m_to_remove.empty()) return;\n+        if (!m_staging_clusterset->m_removed.empty()) return;",
      "path": "src/txgraph.cpp",
      "position": 1015,
      "original_position": 1015,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": 2005075531,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Good idea. Done through a `ClusterSet::HoldsGraphIndexes()` function.",
      "created_at": "2025-03-21T23:58:58Z",
      "updated_at": "2025-03-22T00:06:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2008491413",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008491413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1015,
      "original_line": 1015,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008492939",
      "pull_request_review_id": 2707582068,
      "id": 2008492939,
      "node_id": "PRRC_kwDOABII5853tyuL",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+static constexpr unsigned MAX_CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions.\n+ *\n+ *  The interface is designed to accommodate an implementation that only stores the transitive\n+ *  closure of dependencies, so when querying, if B spends C, then you can't distinguish between\n+ *  A spending B, or A spending both B and C.\n+ */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be cast to, and used as, this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. If it is not empty, the corresponding transaction is removed (in both\n+         *  main and staging, if it exists). */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it.\n+     *  If a staging graph exists, the new transaction is only created there. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. If a staging graph exists, the removal only happens\n+     *  there. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, the dependency adding has no effect. If, together with\n+     * the deletion of B also either A or C is deleted, there is no distinction between the\n+     * original order case and the reordered case.\n+     */\n+    virtual void RemoveTransaction(const Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. If a staging graph exists, the\n+     *  dependency is only added there. Parent may not be a descendant of child already (but may\n+     *  be an ancestor of it already, in which case this is a no-op). If either transaction is\n+     *  already removed, this is a no-op. */\n+    virtual void AddDependency(const Ref& parent, const Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction, in both the main graph and the staging\n+     *  graph if it exists. Wherever the transaction does not exist (or was removed), this has no\n+     *  effect. */\n+    virtual void SetTransactionFee(const Ref& arg, int64_t fee) noexcept = 0;\n+\n+    /** TxGraph is internally lazy, and will not compute many things until they are needed.\n+     *  Calling DoWork will compute everything now, so that future operations are fast. This can be\n+     *  invoked while oversized. */\n+    virtual void DoWork() noexcept = 0;\n+\n+    /** Create a staging graph (which cannot exist already). This acts as if a full copy of\n+     *  the transaction graph is made, upon which further modifications are made. This copy can\n+     *  be inspected, and then either discarded, or the main graph can be replaced by it by\n+     *  commiting it. */\n+    virtual void StartStaging() noexcept = 0;\n+    /** Discard the existing active staging graph (which must exist). */\n+    virtual void AbortStaging() noexcept = 0;\n+    /** Replace the main graph with the staging graph (which must exist). */\n+    virtual void CommitStaging() noexcept = 0;\n+    /** Check whether a staging graph exists. */\n+    virtual bool HaveStaging() const noexcept = 0;\n+\n+    /** Determine whether arg exists in the graph (i.e., was not removed). If main_only is false\n+     *  and a staging graph exists, it is queried; otherwise the main graph is queried. */\n+    virtual bool Exists(const Ref& arg, bool main_only = false) noexcept = 0;\n+    /** Determine whether the graph is oversized (contains a connected component of more than the\n+     *  configured maximum cluster count). If main_only is false and a staging graph exists, it is\n+     *  queried; otherwise the main graph is queried. Some of the functions below are not available\n+     *  for oversized graphs. The mutators above are always available. Removing a transaction by\n+     *  destroying its Ref while staging exists will not clear main's oversizedness until staging\n+     *  is aborted or committed. */\n+    virtual bool IsOversized(bool main_only = false) noexcept = 0;",
      "path": "src/txgraph.h",
      "position": 117,
      "original_position": 133,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "63b8f96e67f9ad649070a231532d48fb6c3573e4",
      "in_reply_to_id": 2004931183,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "@ajtowns That's fair; I liked to think of TxGraph as something with well-specified behavior, but there are several instances of unspecified/best-effort behavior already:\r\n* The cluster linearizations used (as no optimality is guaranteed)\r\n* Reordering of tx removal / dep adding due to lazy batching\r\n* Tie-breaking of order of same-chunk-feerate transactions from different clusters\r\n* The exact logic Trim uses\r\n\r\nGoing to mark this resolved.",
      "created_at": "2025-03-22T00:02:42Z",
      "updated_at": "2025-03-22T00:06:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2008492939",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008492939"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 117,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008636799",
      "pull_request_review_id": 2707784406,
      "id": 2008636799,
      "node_id": "PRRC_kwDOABII5853uV1_",
      "diff_hunk": "@@ -0,0 +1,125 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref (not pointing to any Entry). */\n+        Ref() noexcept = default;\n+        /** Test if this Ref is not empty. */\n+        explicit operator bool() const noexcept { return m_graph != nullptr; }\n+        /** Destroy this Ref. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeeFrac& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.\n+     *\n+     * TxGraph may internally reorder transaction removals with dependency additions for\n+     * performance reasons. If together with any transaction removal all its descendants, or all\n+     * its ancestors, are removed as well (which is what always happens in realistic scenarios),\n+     * this reordering will not affect the behavior of TxGraph.\n+     *\n+     * As an example, imagine 3 transactions A,B,C where B depends on A. If a dependency of C on B\n+     * is added, and then B is deleted, C will still depend on A. If the deletion of B is reordered\n+     * before the C->B dependency is added, it has no effect instead. If, together with the\n+     * deletion of B also either A or C is deleted, there is no distinction.\n+     */\n+    virtual void RemoveTransaction(Ref& arg) noexcept = 0;\n+    /** Add a dependency between two specified transactions. Parent may not be a descendant of\n+     *  child already (but may be an ancestor of it already, in which case this is a no-op). If\n+     *  either transaction is already removed, this is a no-op. */\n+    virtual void AddDependency(Ref& parent, Ref& child) noexcept = 0;\n+    /** Modify the fee of the specified transaction. If the transaction does not exist (or was\n+     *  removed), this has no effect. */\n+    virtual void SetTransactionFee(Ref& arg, int64_t fee) noexcept = 0;\n+    /** Return a vector of pointers to Ref objects for transactions which have been removed from\n+     *  the graph, and have not been destroyed yet. Each transaction is only reported once by\n+     *  Cleanup(). Afterwards, all Refs will be empty. */\n+    [[nodiscard]] virtual std::vector<Ref*> Cleanup() noexcept = 0;\n+\n+    /** Determine whether arg exists in this graph (i.e., was not removed). */\n+    virtual bool Exists(const Ref& arg) noexcept = 0;\n+    /** Get the feerate of the chunk which transaction arg is in. Returns the empty FeeFrac if arg\n+     *  does not exist. */\n+    virtual FeeFrac GetChunkFeerate(const Ref& arg) noexcept = 0;\n+    /** Get the individual transaction feerate of transaction arg. Returns the empty FeeFrac if\n+     *  arg does not exist. */\n+    virtual FeeFrac GetIndividualFeerate(const Ref& arg) noexcept = 0;\n+    /** Get pointers to all transactions in the connected component (\"cluster\") which arg is in.\n+     *  The transactions will be returned in a topologically-valid order of acceptable quality.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 109,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "0c8dc2323eb1ec34357a807f0860cf0a08a63a75",
      "in_reply_to_id": 1909271584,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This has been rewritten.",
      "created_at": "2025-03-22T03:37:24Z",
      "updated_at": "2025-03-22T03:37:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2008636799",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2008636799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 142,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2009188901",
      "pull_request_review_id": 2708677659,
      "id": 2009188901,
      "node_id": "PRRC_kwDOABII5853wcol",
      "diff_hunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <compare>\n+#include <stdint.h>\n+#include <memory>\n+#include <vector>\n+\n+#include <util/feefrac.h>\n+\n+#ifndef BITCOIN_TXGRAPH_H\n+#define BITCOIN_TXGRAPH_H\n+\n+/** No connected component within TxGraph is allowed to exceed this number of transactions. */\n+static constexpr unsigned CLUSTER_COUNT_LIMIT{64};\n+\n+/** Data structure to encapsulate fees, sizes, and dependencies for a set of transactions. */\n+class TxGraph\n+{\n+public:\n+    /** Internal identifier for a transaction within a TxGraph. */\n+    using GraphIndex = uint32_t;\n+\n+    /** Data type used to reference transactions within a TxGraph.\n+     *\n+     * Every transaction within a TxGraph has exactly one corresponding TxGraph::Ref, held by users\n+     * of the class. Destroying the TxGraph::Ref removes the corresponding transaction.\n+     *\n+     * Users of the class can inherit from TxGraph::Ref. If all Refs are inherited this way, the\n+     * Ref* pointers returned by TxGraph functions can be used as this inherited type.\n+     */\n+    class Ref\n+    {\n+        // Allow TxGraph's GetRefGraph and GetRefIndex to access internals.\n+        friend class TxGraph;\n+        /** Which Graph the Entry lives in. nullptr if this Ref is empty. */\n+        TxGraph* m_graph = nullptr;\n+        /** Index into the Graph's m_entries. Only used if m_graph != nullptr. */\n+        GraphIndex m_index = GraphIndex(-1);\n+    public:\n+        /** Construct an empty Ref. Non-empty Refs can only be created using\n+         *  TxGraph::AddTransaction. */\n+        Ref() noexcept = default;\n+        /** Destroy this Ref. This is only allowed when it is empty, or the transaction it refers\n+         *  to has been removed from the graph. */\n+        virtual ~Ref();\n+        // Support moving a Ref.\n+        Ref& operator=(Ref&& other) noexcept;\n+        Ref(Ref&& other) noexcept;\n+        // Do not permit copy constructing or copy assignment. A TxGraph entry can have at most one\n+        // Ref pointing to it.\n+        Ref& operator=(const Ref&) = delete;\n+        Ref(const Ref&) = delete;\n+    };\n+\n+protected:\n+    // Allow TxGraph::Ref to call UpdateRef and UnlinkRef.\n+    friend class TxGraph::Ref;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref has moved. */\n+    virtual void UpdateRef(GraphIndex index, Ref& new_location) noexcept = 0;\n+    /** Inform the TxGraph implementation that a TxGraph::Ref was destroyed. */\n+    virtual void UnlinkRef(GraphIndex index) noexcept = 0;\n+    // Allow TxGraph implementations (inheriting from it) to access Ref internals.\n+    static TxGraph*& GetRefGraph(Ref& arg) noexcept { return arg.m_graph; }\n+    static TxGraph* GetRefGraph(const Ref& arg) noexcept { return arg.m_graph; }\n+    static GraphIndex& GetRefIndex(Ref& arg) noexcept { return arg.m_index; }\n+    static GraphIndex GetRefIndex(const Ref& arg) noexcept { return arg.m_index; }\n+\n+public:\n+    /** Virtual destructor, so inheriting is safe. */\n+    virtual ~TxGraph() = default;\n+    /** Construct a new transaction with the specified feerate, and return a Ref to it. In all\n+     *  further calls, only Refs created by AddTransaction() are allowed to be passed to this\n+     *  TxGraph object (or empty Ref objects). */\n+    [[nodiscard]] virtual Ref AddTransaction(const FeePerWeight& feerate) noexcept = 0;\n+    /** Remove the specified transaction. This is a no-op if the transaction was already removed.",
      "path": "src/txgraph.h",
      "position": null,
      "original_position": 77,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1994854097,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "This works:\r\n\r\n```c++\r\nTxGraph::Ref ref;\r\n...\r\nref = txgraph.AddTransaction(fee, size):\r\n```\r\n\r\nSo think of an empty Ref as an equivalent to an `std::unique_ptr` to `nullptr` or so. It's potentially useful just so you can have a variable declared as a member in a class or so without immediately initializing it.\r\n\r\nIt even goes further in that this works even through subclasses:\r\n\r\n```c++\r\nclass TxMempoolEntry : public TxGraph::Ref { ... }\r\n\r\nTxMemoolEntry entry;\r\n...\r\nentry = txgraph.AddTransaction(fee, size);\r\n```",
      "created_at": "2025-03-23T18:10:44Z",
      "updated_at": "2025-03-23T18:10:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2009188901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2009188901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2009189848",
      "pull_request_review_id": 2708678641,
      "id": 2009189848,
      "node_id": "PRRC_kwDOABII5853wc3Y",
      "diff_hunk": "@@ -0,0 +1,1177 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txgraph.h>\n+\n+#include <cluster_linearize.h>\n+#include <random.h>\n+#include <util/bitset.h>\n+#include <util/check.h>\n+#include <util/feefrac.h>\n+\n+#include <compare>\n+#include <memory>\n+#include <span>\n+#include <utility>\n+\n+namespace {\n+\n+using namespace cluster_linearize;\n+\n+// Forward declare the TxGraph implementation class.\n+class TxGraphImpl;\n+\n+/** Position of a DepGraphIndex within a Cluster::m_linearization. */\n+using LinearizationIndex = uint32_t;\n+/** Position of a Cluster within Graph::m_clusters. */\n+using ClusterSetIndex = uint32_t;\n+\n+/** Quality levels for cached cluster linearizations. */\n+enum class QualityLevel\n+{\n+    /** This cluster may have multiple disconnected components, which are all NEEDS_RELINEARIZE. */\n+    NEEDS_SPLIT,\n+    /** This cluster has undergone changes that warrant re-linearization. */\n+    NEEDS_RELINEARIZE,\n+    /** The minimal level of linearization has been performed, but it is not known to be optimal. */\n+    ACCEPTABLE,\n+    /** The linearization is known to be optimal. */\n+    OPTIMAL,\n+    /** This cluster is not registered in any m_clusters.\n+     *  This must be the last entry in QualityLevel as m_clusters is sized using it. */\n+    NONE,\n+};\n+\n+/** A grouping of connected transactions inside a TxGraphImpl. */\n+class Cluster\n+{\n+    friend class TxGraphImpl;\n+    using GraphIndex = TxGraph::GraphIndex;\n+    using SetType = BitSet<CLUSTER_COUNT_LIMIT>;\n+    /** The DepGraph for this cluster, holding all feerates, and ancestors/descendants. */\n+    DepGraph<SetType> m_depgraph;\n+    /** m_mapping[i] gives the GraphIndex for the position i transaction in m_depgraph. Values for\n+     *  positions i that do not exist in m_depgraph shouldn't ever be accessed and thus don't\n+     *  matter. m_mapping.size() equals m_depgraph.PositionRange(). */\n+    std::vector<GraphIndex> m_mapping;\n+    /** The current linearization of the cluster. m_linearization.size() equals\n+     *  m_depgraph.TxCount(). This is always kept topological. */\n+    std::vector<DepGraphIndex> m_linearization;\n+    /** The quality level of m_linearization. */\n+    QualityLevel m_quality{QualityLevel::NONE};\n+    /** Which position this Cluster has in Graph::m_clusters[m_quality]. */\n+    ClusterSetIndex m_setindex{ClusterSetIndex(-1)};\n+\n+public:\n+    /** Construct an empty Cluster. */\n+    Cluster() noexcept = default;\n+    /** Construct a singleton Cluster. */\n+    explicit Cluster(TxGraphImpl& graph, const FeePerWeight& feerate, GraphIndex graph_index) noexcept;\n+\n+    // Cannot move or copy (would invalidate Cluster* in Locator and TxGraphImpl). */\n+    Cluster(const Cluster&) = delete;\n+    Cluster& operator=(const Cluster&) = delete;\n+    Cluster(Cluster&&) = delete;\n+    Cluster& operator=(Cluster&&) = delete;\n+\n+    // Generic helper functions.\n+\n+    /** Whether the linearization of this Cluster can be exposed. */\n+    bool IsAcceptable() const noexcept\n+    {\n+        return m_quality == QualityLevel::ACCEPTABLE || m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether the linearization of this Cluster is optimal. */\n+    bool IsOptimal() const noexcept\n+    {\n+        return m_quality == QualityLevel::OPTIMAL;\n+    }\n+    /** Whether this cluster requires splitting. */\n+    bool NeedsSplitting() const noexcept\n+    {\n+        return m_quality == QualityLevel::NEEDS_SPLIT;\n+    }\n+    /** Get the number of transactions in this Cluster. */\n+    LinearizationIndex GetTxCount() const noexcept { return m_linearization.size(); }\n+    /** Only called by Graph::SwapIndexes. */\n+    void UpdateMapping(DepGraphIndex cluster_idx, GraphIndex graph_idx) noexcept { m_mapping[cluster_idx] = graph_idx; }\n+    /** Push changes to Cluster and its linearization to the TxGraphImpl Entry objects. */\n+    void Updated(TxGraphImpl& graph) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of internal TxGraphImpl mutations.\n+\n+    /** Apply all removals from the front of to_remove that apply to this Cluster, popping them\n+     *  off. These must be at least one such entry. */\n+    void ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept;\n+    /** Split this cluster (must have a NEEDS_SPLIT* quality). Returns whether to delete this\n+     *  Cluster afterwards. */\n+    [[nodiscard]] bool Split(TxGraphImpl& graph) noexcept;\n+    /** Move all transactions from cluster to *this (as separate components). */\n+    void Merge(TxGraphImpl& graph, Cluster& cluster) noexcept;\n+    /** Given a span of (parent, child) pairs that all belong to this Cluster, apply them. */\n+    void ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept;\n+    /** Improve the linearization of this Cluster. */\n+    void Relinearize(TxGraphImpl& graph, uint64_t max_iters) noexcept;\n+\n+    // Functions that implement the Cluster-specific side of public TxGraph functions.\n+\n+    /** Get a vector of Refs for the ancestors of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetAncestorRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for the descendants of a given Cluster element. */\n+    std::vector<TxGraph::Ref*> GetDescendantRefs(const TxGraphImpl& graph, DepGraphIndex idx) noexcept;\n+    /** Get a vector of Refs for all elements of this Cluster, in linearization order. */\n+    std::vector<TxGraph::Ref*> GetClusterRefs(const TxGraphImpl& graph) noexcept;\n+    /** Get the individual transaction feerate of a Cluster element. */\n+    FeePerWeight GetIndividualFeerate(DepGraphIndex idx) noexcept;\n+    /** Modify the fee of a Cluster element. */\n+    void SetFee(TxGraphImpl& graph, DepGraphIndex idx, int64_t fee) noexcept;\n+};\n+\n+/** The transaction graph.\n+ *\n+ * The overall design of the data structure consists of 3 interlinked representations:\n+ * - The transactions (held as a vector of TxGraphImpl::Entry inside TxGraphImpl).\n+ * - The clusters (Cluster objects in per-quality vectors inside TxGraphImpl).\n+ * - The Refs (TxGraph::Ref objects, held externally by users of the TxGraph class)\n+ *\n+ * Clusters and Refs contain the index of the Entry objects they refer to, and the Entry objects\n+ * refer back to the Clusters and Refs the corresponding transaction is contained in.\n+ *\n+ * While redundant, this permits moving all of them independently, without invalidating things\n+ * or costly iteration to fix up everything:\n+ * - Entry objects can be moved to fill holes left by removed transactions in the Entry vector\n+ *   (see TxGraphImpl::Compact).\n+ * - Clusters can be rewritten continuously (removals can cause them to split, new dependencies\n+ *   can cause them to be merged).\n+ * - Ref objects can be held outside the class, while permitting them to be moved around, and\n+ *   inherited from.\n+ */\n+class TxGraphImpl final : public TxGraph\n+{\n+    friend class Cluster;\n+private:\n+    /** Internal RNG. */\n+    FastRandomContext m_rng;\n+\n+    /** Information about one group of Clusters to be merged. */\n+    struct GroupEntry\n+    {\n+        /** Which clusters are to be merged. */\n+        std::vector<Cluster*> m_clusters;\n+        /** Which dependencies are to be applied to those merged clusters, as (parent, child)\n+         *  pairs. */\n+        std::vector<std::pair<GraphIndex, GraphIndex>> m_deps;\n+    };\n+\n+    /** The vectors of clusters, one vector per quality level. ClusterSetIndex indexes into each. */\n+    std::vector<std::unique_ptr<Cluster>> m_clusters[int(QualityLevel::NONE)];\n+    /** Which removals have yet to be applied. */\n+    std::vector<GraphIndex> m_to_remove;\n+    /** Which dependencies are to be added ((parent,child) pairs). GroupData::m_deps_offset indexes\n+     *  into this. */\n+    std::vector<std::pair<GraphIndex, GraphIndex>> m_deps_to_add;\n+    /** Information about the merges to be performed, if known. */\n+    std::optional<std::vector<GroupEntry>> m_group_data = std::vector<GroupEntry>{};\n+    /** Total number of transactions in this graph (sum of all transaction counts in all Clusters).\n+     *  */\n+    GraphIndex m_txcount{0};\n+\n+    /** A Locator that describes whether, where, and in which Cluster an Entry appears. */\n+    struct Locator\n+    {\n+        /** Which Cluster the Entry appears in (nullptr = missing). */\n+        Cluster* cluster{nullptr};\n+        /** Where in the Cluster it appears (only if cluster != nullptr). */\n+        DepGraphIndex index{0};\n+\n+        /** Mark this Locator as missing. */\n+        void SetMissing() noexcept { cluster = nullptr; index = 0; }\n+        /** Mark this Locator as present, in the specified Cluster. */\n+        void SetPresent(Cluster* c, DepGraphIndex i) noexcept { cluster = c; index = i; }\n+        /** Check if this Locator is present (in some Cluster). */\n+        bool IsPresent() const noexcept { return cluster != nullptr; }\n+    };\n+\n+    /** A class of objects held internally in TxGraphImpl, with information about a single\n+     *  transaction. */\n+    struct Entry\n+    {\n+        /** Pointer to the corresponding Ref object if any, or nullptr if unlinked. */\n+        Ref* m_ref{nullptr};\n+        /** Which Cluster and position therein this Entry appears in. */\n+        Locator m_locator;\n+        /** The chunk feerate of this transaction (if not missing). */\n+        FeePerWeight m_chunk_feerate;\n+    };\n+\n+    /** The set of all transactions. GraphIndex values index into this. */\n+    std::vector<Entry> m_entries;\n+\n+    /** Set of Entries which have no linked Ref anymore. */\n+    std::vector<GraphIndex> m_unlinked;\n+\n+public:\n+    /** Construct a new TxGraphImpl. */\n+    explicit TxGraphImpl() noexcept {}\n+\n+    // Cannot move or copy (would invalidate TxGraphImpl* in Ref, MiningOrder, EvictionOrder).\n+    TxGraphImpl(const TxGraphImpl&) = delete;\n+    TxGraphImpl& operator=(const TxGraphImpl&) = delete;\n+    TxGraphImpl(TxGraphImpl&&) = delete;\n+    TxGraphImpl& operator=(TxGraphImpl&&) = delete;\n+\n+    // Simple helper functions.\n+\n+    /** Swap the Entrys referred to by a and b. */\n+    void SwapIndexes(GraphIndex a, GraphIndex b) noexcept;\n+    /** Extract a Cluster. */\n+    std::unique_ptr<Cluster> ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept;\n+    /** Delete a Cluster. */\n+    void DeleteCluster(Cluster& cluster) noexcept;\n+    /** Insert a Cluster. */\n+    ClusterSetIndex InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept;\n+    /** Change the QualityLevel of a Cluster (identified by old_quality and old_index). */\n+    void SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept;\n+\n+    // Functions for handling Refs.\n+\n+    /** Only called by Ref's move constructor/assignment to update Ref locations. */\n+    void UpdateRef(GraphIndex idx, Ref& new_location) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = &new_location;\n+    }\n+\n+    /** Only called by Ref::~Ref to unlink Refs, and Ref's move assignment. */\n+    void UnlinkRef(GraphIndex idx) noexcept final\n+    {\n+        auto& entry = m_entries[idx];\n+        Assume(entry.m_ref != nullptr);\n+        entry.m_ref = nullptr;\n+        m_unlinked.push_back(idx);\n+        Compact();\n+    }\n+\n+    // Functions related to various normalization/application steps.\n+    /** Get rid of unlinked Entry objects in m_entries, if possible (this changes the GraphIndex\n+     *  values for remaining Entrys, so this only does something when no to-be-applied operations\n+     *  referring to GraphIndexes remain). */\n+    void Compact() noexcept;\n+    /** Apply all removals queued up in m_to_remove to the relevant Clusters (which get a\n+     *  NEEDS_SPLIT* QualityLevel). */\n+    void ApplyRemovals() noexcept;\n+    /** Split an individual cluster. */\n+    void Split(Cluster& cluster) noexcept;\n+    /** Split all clusters that need splitting. */\n+    void SplitAll() noexcept;\n+    /** Populate m_group_data based on m_deps_to_add. */\n+    void GroupClusters() noexcept;\n+    /** Merge the specified clusters. */\n+    void Merge(std::span<Cluster*> to_merge) noexcept;\n+    /** Apply all m_deps_to_add to the relevant Clusters. */\n+    void ApplyDependencies() noexcept;\n+    /** Make a specified Cluster have quality ACCEPTABLE or OPTIMAL. */\n+    void MakeAcceptable(Cluster& cluster) noexcept;\n+\n+    // Implementations for the public TxGraph interface.\n+\n+    Ref AddTransaction(const FeePerWeight& feerate) noexcept final;\n+    void RemoveTransaction(const Ref& arg) noexcept final;\n+    void AddDependency(const Ref& parent, const Ref& child) noexcept final;\n+    void SetTransactionFee(const Ref&, int64_t fee) noexcept final;\n+\n+    bool Exists(const Ref& arg) noexcept final;\n+    FeePerWeight GetChunkFeerate(const Ref& arg) noexcept final;\n+    FeePerWeight GetIndividualFeerate(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetCluster(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetAncestors(const Ref& arg) noexcept final;\n+    std::vector<Ref*> GetDescendants(const Ref& arg) noexcept final;\n+    GraphIndex GetTransactionCount() noexcept final;\n+};\n+\n+void Cluster::Updated(TxGraphImpl& graph) noexcept\n+{\n+    // Update all the Locators for this Cluster's Entrys.\n+    for (DepGraphIndex idx : m_linearization) {\n+        auto& entry = graph.m_entries[m_mapping[idx]];\n+        entry.m_locator.SetPresent(this, idx);\n+    }\n+\n+    // Compute its chunking and store its information in the Entry's m_chunk_feerate.\n+    LinearizationChunking chunking(m_depgraph, m_linearization);\n+    LinearizationIndex lin_idx{0};\n+    // Iterate over the chunks.\n+    for (unsigned chunk_idx = 0; chunk_idx < chunking.NumChunksLeft(); ++chunk_idx) {\n+        auto chunk = chunking.GetChunk(chunk_idx);\n+        Assume(chunk.transactions.Any());\n+        // Iterate over the transactions in the linearization, which must match those in chunk.\n+        do {\n+            DepGraphIndex idx = m_linearization[lin_idx++];\n+            GraphIndex graph_idx = m_mapping[idx];\n+            auto& entry = graph.m_entries[graph_idx];\n+            entry.m_chunk_feerate = FeePerWeight::FromFeeFrac(chunk.feerate);\n+            Assume(chunk.transactions[idx]);\n+            chunk.transactions.Reset(idx);\n+        } while(chunk.transactions.Any());\n+    }\n+}\n+\n+void Cluster::ApplyRemovals(TxGraphImpl& graph, std::span<GraphIndex>& to_remove) noexcept\n+{\n+    // Iterate over the prefix of to_remove that applies to this cluster.\n+    Assume(!to_remove.empty());\n+    SetType todo;\n+    do {\n+        GraphIndex idx = to_remove.front();\n+        Assume(idx < graph.m_entries.size());\n+        auto& entry = graph.m_entries[idx];\n+        auto& locator = entry.m_locator;\n+        // Stop once we hit an entry that applies to another Cluster.\n+        if (locator.cluster != this) break;\n+        // - Remember it in a set of to-remove DepGraphIndexes.\n+        todo.Set(locator.index);\n+        // - Remove from m_mapping. This isn't strictly necessary as unused positions in m_mapping\n+        //   are just never accessed, but set it to -1 here to increase the ability to detect a bug\n+        //   that causes it to be accessed regardless.\n+        m_mapping[locator.index] = GraphIndex(-1);\n+        // - Mark it as removed in the Entry's locator.\n+        locator.SetMissing();\n+        to_remove = to_remove.subspan(1);\n+        --graph.m_txcount;\n+    } while(!to_remove.empty());\n+\n+    Assume(todo.Any());\n+    // Wipe from the Cluster's DepGraph (this is O(n) regardless of the number of entries\n+    // removed, so we benefit from batching all the removals).\n+    m_depgraph.RemoveTransactions(todo);\n+    m_mapping.resize(m_depgraph.PositionRange());\n+\n+    // Filter removals out of m_linearization.\n+    m_linearization.erase(std::remove_if(\n+        m_linearization.begin(),\n+        m_linearization.end(),\n+        [&](auto pos) { return todo[pos]; }), m_linearization.end());\n+\n+    graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_SPLIT);\n+    Updated(graph);\n+}\n+\n+bool Cluster::Split(TxGraphImpl& graph) noexcept\n+{\n+    // This function can only be called when the Cluster needs splitting.\n+    Assume(NeedsSplitting());\n+    /** Which positions are still left in this Cluster. */\n+    auto todo = m_depgraph.Positions();\n+    /** Mapping from transaction positions in this Cluster to the Cluster where it ends up, and\n+     *  its position therein. */\n+    std::vector<std::pair<Cluster*, DepGraphIndex>> remap(m_depgraph.PositionRange());\n+    std::vector<Cluster*> new_clusters;\n+    bool first{true};\n+    // Iterate over the connected components of this Cluster's m_depgraph.\n+    while (todo.Any()) {\n+        auto component = m_depgraph.FindConnectedComponent(todo);\n+        if (first && component == todo) {\n+            // The existing Cluster is an entire component. Leave it be, but update its quality.\n+            Assume(todo == m_depgraph.Positions());\n+            graph.SetClusterQuality(m_quality, m_setindex, QualityLevel::NEEDS_RELINEARIZE);\n+            // We need to recompute and cache its chunking.\n+            Updated(graph);\n+            return false;\n+        }\n+        first = false;\n+        // Construct a new Cluster to hold the found component.\n+        auto new_cluster = std::make_unique<Cluster>();\n+        new_clusters.push_back(new_cluster.get());\n+        // Remember that all the component's transactions go to this new Cluster. The positions\n+        // will be determined below, so use -1 for now.\n+        for (auto i : component) {\n+            remap[i] = {new_cluster.get(), DepGraphIndex(-1)};\n+        }\n+        graph.InsertCluster(std::move(new_cluster), QualityLevel::NEEDS_RELINEARIZE);\n+        todo -= component;\n+    }\n+    // Redistribute the transactions.\n+    for (auto i : m_linearization) {\n+        /** The cluster which transaction originally in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy the transaction to the new cluster's depgraph, and remember the position.\n+        remap[i].second = new_cluster->m_depgraph.AddTransaction(m_depgraph.FeeRate(i));\n+        // Create new mapping entry.\n+        new_cluster->m_mapping.push_back(m_mapping[i]);\n+        // Create a new linearization entry. As we're only appending transactions, they equal the\n+        // DepGraphIndex.\n+        new_cluster->m_linearization.push_back(remap[i].second);\n+    }\n+    // Redistribute the dependencies.\n+    for (auto i : m_linearization) {\n+        /** The cluster transaction in position i is moved to. */\n+        Cluster* new_cluster = remap[i].first;\n+        // Copy its parents, translating positions.\n+        SetType new_parents;\n+        for (auto par : m_depgraph.GetReducedParents(i)) new_parents.Set(remap[par].second);\n+        new_cluster->m_depgraph.AddDependencies(new_parents, remap[i].second);\n+    }\n+    // Update all the Locators of moved transactions.\n+    for (Cluster* new_cluster : new_clusters) {\n+        new_cluster->Updated(graph);\n+    }\n+    // Wipe this Cluster, and return that it needs to be deleted.\n+    m_depgraph = DepGraph<SetType>{};\n+    m_mapping.clear();\n+    m_linearization.clear();\n+    return true;\n+}\n+\n+void Cluster::Merge(TxGraphImpl& graph, Cluster& other) noexcept\n+{\n+    /** Vector to store the positions in this Cluster for each position in other. */\n+    std::vector<DepGraphIndex> remap(other.m_depgraph.PositionRange());\n+    // Iterate over all transactions in the other Cluster (the one being absorbed).\n+    for (auto pos : other.m_linearization) {\n+        auto idx = other.m_mapping[pos];\n+        // Copy the transaction into this Cluster, and remember its position.\n+        auto new_pos = m_depgraph.AddTransaction(other.m_depgraph.FeeRate(pos));\n+        remap[pos] = new_pos;\n+        if (new_pos == m_mapping.size()) {\n+            m_mapping.push_back(idx);\n+        } else {\n+            m_mapping[new_pos] = idx;\n+        }\n+        m_linearization.push_back(new_pos);\n+        // Copy the transaction's dependencies, translating them using remap. Note that since\n+        // pos iterates over other.m_linearization, which is in topological order, all parents\n+        // of pos should already be in remap.\n+        SetType parents;\n+        for (auto par : other.m_depgraph.GetReducedParents(pos)) {\n+            parents.Set(remap[par]);\n+        }\n+        m_depgraph.AddDependencies(parents, remap[pos]);\n+        // Update the transaction's Locator. There is no need to call Updated() to update chunk\n+        // feerates, as Updated() will be invoked by Cluster::ApplyDependencies on the resulting\n+        // merged Cluster later anyway).\n+        graph.m_entries[idx].m_locator.SetPresent(this, new_pos);\n+    }\n+    // Purge the other Cluster, now that everything has been moved.\n+    other.m_depgraph = DepGraph<SetType>{};\n+    other.m_linearization.clear();\n+    other.m_mapping.clear();\n+}\n+\n+void Cluster::ApplyDependencies(TxGraphImpl& graph, std::span<std::pair<GraphIndex, GraphIndex>> to_apply) noexcept\n+{\n+    // This function is invoked by TxGraphImpl::ApplyDependencies after merging groups of Clusters\n+    // between which dependencies are added, which simply concatenates their linearizations. Invoke\n+    // PostLinearize, which has the effect that the linearization becomes a merge-sort of the\n+    // constituent linearizations. Do this here rather than in Cluster::Merge, because this\n+    // function is only invoked once per merged Cluster, rather than once per constituent one.\n+    // This concatenation + post-linearization could be replaced with an explicit merge-sort.\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Sort the list of dependencies to apply by child, so those can be applied in batch.\n+    std::sort(to_apply.begin(), to_apply.end(), [](auto& a, auto& b) { return a.second < b.second; });\n+    // Iterate over groups of to-be-added dependencies with the same child.\n+    auto it = to_apply.begin();\n+    while (it != to_apply.end()) {\n+        auto& first_child = graph.m_entries[it->second].m_locator;\n+        const auto child_idx = first_child.index;\n+        // Iterate over all to-be-added dependencies within that same child, gather the relevant\n+        // parents.\n+        SetType parents;\n+        while (it != to_apply.end()) {\n+            auto& child = graph.m_entries[it->second].m_locator;\n+            auto& parent = graph.m_entries[it->first].m_locator;\n+            Assume(child.cluster == this && parent.cluster == this);\n+            if (child.index != child_idx) break;\n+            parents.Set(parent.index);\n+            ++it;\n+        }\n+        // Push all dependencies to the underlying DepGraph. Note that this is O(N) in the size of\n+        // the cluster, regardless of the number of parents being added, so batching them together\n+        // has a performance benefit.\n+        m_depgraph.AddDependencies(parents, child_idx);\n+    }\n+\n+    // Finally fix the linearization, as the new dependencies may have invalidated the\n+    // linearization, and post-linearize it to fix up the worst problems with it.\n+    FixLinearization(m_depgraph, m_linearization);\n+    PostLinearize(m_depgraph, m_linearization);\n+\n+    // Finally push the changes to graph.m_entries.\n+    Updated(graph);\n+}\n+\n+std::unique_ptr<Cluster> TxGraphImpl::ExtractCluster(QualityLevel quality, ClusterSetIndex setindex) noexcept\n+{\n+    Assume(quality != QualityLevel::NONE);\n+\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    Assume(setindex < quality_clusters.size());\n+\n+    // Extract the Cluster-owning unique_ptr.\n+    std::unique_ptr<Cluster> ret = std::move(quality_clusters[setindex]);\n+    ret->m_quality = QualityLevel::NONE;\n+    ret->m_setindex = ClusterSetIndex(-1);\n+\n+    // Clean up space in quality_cluster.\n+    auto max_setindex = quality_clusters.size() - 1;\n+    if (setindex != max_setindex) {\n+        // If the cluster was not the last element of quality_clusters, move that to take its place.\n+        quality_clusters.back()->m_setindex = setindex;\n+        quality_clusters[setindex] = std::move(quality_clusters.back());\n+    }\n+    // The last element of quality_clusters is now unused; drop it.\n+    quality_clusters.pop_back();\n+\n+    return ret;\n+}\n+\n+ClusterSetIndex TxGraphImpl::InsertCluster(std::unique_ptr<Cluster>&& cluster, QualityLevel quality) noexcept\n+{\n+    // Cannot insert with quality level NONE (as that would mean not inserted).\n+    Assume(quality != QualityLevel::NONE);\n+    // The passed-in Cluster must not currently be in the TxGraphImpl.\n+    Assume(cluster->m_quality == QualityLevel::NONE);\n+\n+    // Append it at the end of the relevant TxGraphImpl::m_cluster.\n+    auto& quality_clusters = m_clusters[int(quality)];\n+    ClusterSetIndex ret = quality_clusters.size();\n+    cluster->m_quality = quality;\n+    cluster->m_setindex = ret;\n+    quality_clusters.push_back(std::move(cluster));\n+    return ret;\n+}\n+\n+void TxGraphImpl::SetClusterQuality(QualityLevel old_quality, ClusterSetIndex old_index, QualityLevel new_quality) noexcept\n+{\n+    Assume(new_quality != QualityLevel::NONE);\n+\n+    // Don't do anything if the quality did not change.\n+    if (old_quality == new_quality) return;\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(old_quality, old_index);\n+    // And re-insert it where it belongs.\n+    InsertCluster(std::move(cluster_ptr), new_quality);\n+}\n+\n+void TxGraphImpl::DeleteCluster(Cluster& cluster) noexcept\n+{\n+    // Extract the cluster from where it currently resides.\n+    auto cluster_ptr = ExtractCluster(cluster.m_quality, cluster.m_setindex);\n+    // And throw it away.\n+    cluster_ptr.reset();\n+}\n+\n+void TxGraphImpl::ApplyRemovals() noexcept\n+{\n+    auto& to_remove = m_to_remove;\n+    // Skip if there is nothing to remove.\n+    if (to_remove.empty()) return;\n+    // Group the set of to-be-removed entries by Cluster*.\n+    std::sort(m_to_remove.begin(), m_to_remove.end(), [&](GraphIndex a, GraphIndex b) noexcept {\n+        return std::less{}(m_entries[a].m_locator.cluster, m_entries[b].m_locator.cluster);\n+    });\n+    // Process per Cluster.\n+    std::span to_remove_span{m_to_remove};\n+    while (!to_remove_span.empty()) {\n+        Cluster* cluster = m_entries[to_remove_span.front()].m_locator.cluster;\n+        if (cluster != nullptr) {\n+            // If the first to_remove_span entry's Cluster exists, hand to_remove_span to it, so it\n+            // can pop off whatever applies to it.\n+            cluster->ApplyRemovals(*this, to_remove_span);\n+        } else {\n+            // Otherwise, skip this already-removed entry. This may happen when RemoveTransaction\n+            // was called twice on the same Ref.\n+            to_remove_span = to_remove_span.subspan(1);\n+        }\n+    }\n+    m_to_remove.clear();\n+    Compact();\n+}\n+\n+void TxGraphImpl::SwapIndexes(GraphIndex a, GraphIndex b) noexcept\n+{\n+    Assume(a < m_entries.size());\n+    Assume(b < m_entries.size());\n+    // Swap the Entry objects.\n+    std::swap(m_entries[a], m_entries[b]);\n+    // Iterate over both objects.\n+    for (int i = 0; i < 2; ++i) {\n+        GraphIndex idx = i ? b : a;\n+        Entry& entry = m_entries[idx];\n+        // Update linked Ref.\n+        if (entry.m_ref) GetRefIndex(*entry.m_ref) = idx;\n+        // Update the locator. The rest of the Entry information will not change, so no need to\n+        // invoke Cluster::Updated().\n+        Locator& locator = entry.m_locator;\n+        if (locator.IsPresent()) {\n+            locator.cluster->UpdateMapping(locator.index, idx);\n+        }\n+    }\n+}\n+\n+void TxGraphImpl::Compact() noexcept\n+{\n+    // We cannot compact while any to-be-applied operations remain, as we'd need to rewrite them.\n+    // It is easier to delay the compaction until they have been applied.\n+    if (!m_deps_to_add.empty()) return;\n+    if (!m_to_remove.empty()) return;\n+\n+    // Sort the GraphIndexes that need to be cleaned up. They are sorted in reverse, so the last\n+    // ones get processed first. This means earlier-processed GraphIndexes will not cause moving of\n+    // later-processed ones during the \"swap with end of m_entries\" step below (which might\n+    // invalidate them).\n+    std::sort(m_unlinked.begin(), m_unlinked.end(), std::greater{});\n+\n+    auto last = GraphIndex(-1);\n+    for (GraphIndex idx : m_unlinked) {\n+        // m_unlinked should never contain the same GraphIndex twice (the code below would fail\n+        // if so, because GraphIndexes get invalidated by removing them).\n+        Assume(idx != last);\n+        last = idx;\n+\n+        // Make sure the entry is unlinked.\n+        Entry& entry = m_entries[idx];\n+        Assume(entry.m_ref == nullptr);\n+        // Make sure the entry does not occur in the graph.\n+        Assume(!entry.m_locator.IsPresent());\n+\n+        // Move the entry to the end.\n+        if (idx != m_entries.size() - 1) SwapIndexes(idx, m_entries.size() - 1);\n+        // Drop the entry for idx, now that it is at the end.\n+        m_entries.pop_back();\n+    }\n+    m_unlinked.clear();\n+}\n+\n+void TxGraphImpl::Split(Cluster& cluster) noexcept\n+{\n+    // To split a Cluster, first make sure all removals are applied (as we might need to split\n+    // again afterwards otherwise).\n+    ApplyRemovals();\n+    bool del = cluster.Split(*this);\n+    if (del) {\n+        // Cluster::Split reports whether the Cluster is to be deleted.\n+        DeleteCluster(cluster);\n+    }\n+}\n+\n+void TxGraphImpl::SplitAll() noexcept\n+{\n+    // Before splitting all Cluster, first make sure all removals are applied.\n+    ApplyRemovals();\n+    auto& queue = m_clusters[int(QualityLevel::NEEDS_SPLIT)];\n+    while (!queue.empty()) {\n+        Split(*queue.back().get());\n+    }\n+}\n+\n+void TxGraphImpl::GroupClusters() noexcept\n+{\n+    // If the groupings have been computed already, nothing is left to be done.\n+    if (m_group_data.has_value()) return;\n+\n+    // Before computing which Clusters need to be merged together, first apply all removals and\n+    // split the Clusters into connected components. If we would group first, we might end up\n+    // with inefficient Clusters which just end up being split again anyway.\n+    SplitAll();\n+\n+    /** Annotated clusters: an entry for each Cluster, together with the representative for the\n+     *  partition it is in if known, or with nullptr if not yet known. */\n+    std::vector<std::pair<Cluster*, Cluster*>> an_clusters;\n+    /** Annotated dependencies: an entry for each m_deps_to_add entry (excluding ones that apply\n+     *  to removed transactions), together with the representative root of the partition of\n+     *  Clusters it applies to. */\n+    std::vector<std::pair<std::pair<GraphIndex, GraphIndex>, Cluster*>> an_deps;\n+\n+    // Construct a an_clusters entry for every parent and child in the to-be-applied dependencies.\n+    for (const auto& [par, chl] : m_deps_to_add) {\n+        auto par_cluster = m_entries[par].m_locator.cluster;\n+        auto chl_cluster = m_entries[chl].m_locator.cluster;\n+        // Skip dependencies for which the parent or child transaction is removed.\n+        if (par_cluster == nullptr || chl_cluster == nullptr) continue;\n+        an_clusters.emplace_back(par_cluster, nullptr);\n+        // Do not include a duplicate when parent and child are identical, as it'll be removed\n+        // below anyway.\n+        if (chl_cluster != par_cluster) an_clusters.emplace_back(chl_cluster, nullptr);\n+    }\n+    // Sort and deduplicate an_clusters, so we end up with a sorted list of all involved Clusters\n+    // to which dependencies apply.\n+    std::sort(an_clusters.begin(), an_clusters.end());\n+    an_clusters.erase(std::unique(an_clusters.begin(), an_clusters.end()), an_clusters.end());\n+\n+    // Run the union-find algorithm to to find partitions of the input Clusters which need to be\n+    // grouped together. See https://en.wikipedia.org/wiki/Disjoint-set_data_structure.\n+    {",
      "path": "src/txgraph.cpp",
      "position": 1120,
      "original_position": 706,
      "commit_id": "41b4434fed169570ce0976c6e58db0d4a9614aaa",
      "original_commit_id": "e22a0b21f83691527c4a391681142f51a2be14ba",
      "in_reply_to_id": 1997570195,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I tried to encapsulate it in its own class, but it's hard to give it the same performance (which is relevant in the context of huge reorgs) without making the interface rather involved (needs a \"representative\" type that contains a pointer to the `PartitionData` object, separate from the element data type), and even then, the union-find version in `Trim()` in 31553 would need its own separate implementation still.\r\n\r\nGoing to leave it for now, we can think about cleanups later.",
      "created_at": "2025-03-23T18:16:02Z",
      "updated_at": "2025-03-23T18:16:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/31363#discussion_r2009189848",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2009189848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/31363"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1120,
      "original_line": 1120,
      "side": "RIGHT"
    }
  ]
}