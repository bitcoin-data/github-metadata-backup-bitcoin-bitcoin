{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689",
    "id": 2940741002,
    "node_id": "PR_kwDOABII586vSCWK",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/33689",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/33689.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/33689.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/38fd85c676a072ebf256e806beda9d7533790baa",
    "number": 33689,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "http: replace WorkQueue and single threads handling for ThreadPool",
    "user": {
      "login": "furszy",
      "id": 5377650,
      "node_id": "MDQ6VXNlcjUzNzc2NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/furszy",
      "html_url": "https://github.com/furszy",
      "followers_url": "https://api.github.com/users/furszy/followers",
      "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
      "organizations_url": "https://api.github.com/users/furszy/orgs",
      "repos_url": "https://api.github.com/users/furszy/repos",
      "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/furszy/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "body": "This has been a recent discovery; the general thread pool class created for #26966, cleanly \r\nintegrates into the HTTP server. It simplifies init, shutdown and requests execution logic.\r\nReplacing code that was never unit tested for code that is properly unit and fuzz tested.\r\nAlthough our functional test framework extensively uses this RPC interface (that’s how\r\nwe’ve been ensuring its correct behavior so far - which is not the best).\r\n\r\nThis clearly separates the responsibilities:\r\nThe HTTP server now focuses solely on receiving and dispatching requests, while ThreadPool handles\r\nconcurrency, queuing, and execution.\r\n\r\nThis will also allows us to experiment with further performance improvements at the task queuing and\r\nexecution level, such as a lock-free structure or task prioritization or any other implementation detail\r\nlike coroutines in the future, without having to deal with HTTP code that lives on a different layer.\r\n\r\nNote:\r\nThe rationale behind introducing the ThreadPool first is to be able to easily cherry-pick it across different\r\nworking paths. Some of the ones that are benefited from it are #26966 for the parallelization of the indexes\r\ninitial sync, #31132 for the parallelization of the inputs fetching procedure, #32061 for the libevent replacement,\r\nthe kernel API #30595 (https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2413702370) to avoid blocking validation among others use cases not publicly available.\r\n\r\nNote 2:\r\nI could have created a wrapper around the existing code and replaced the `WorkQueue` in a subsequent\r\ncommit, but it didn’t seem worth the extra commits and review effort. The `ThreadPool` implements\r\nessentially the same functionality in a more modern and cleaner way.",
    "labels": [
      {
        "id": 98279177,
        "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
        "name": "RPC/REST/ZMQ",
        "color": "0052cc",
        "default": false
      }
    ],
    "created_at": "2025-10-23T14:36:44Z",
    "updated_at": "2026-02-12T16:15:44Z",
    "closed_at": "2026-02-11T17:04:50Z",
    "mergeable_state": "unknown",
    "merged": true,
    "merged_at": "2026-02-11T17:04:50Z",
    "merged_by": {
      "login": "sedited",
      "id": 8421793,
      "node_id": "MDQ6VXNlcjg0MjE3OTM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sedited",
      "html_url": "https://github.com/sedited",
      "followers_url": "https://api.github.com/users/sedited/followers",
      "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
      "organizations_url": "https://api.github.com/users/sedited/orgs",
      "repos_url": "https://api.github.com/users/sedited/repos",
      "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sedited/received_events",
      "type": "User",
      "site_admin": false,
      "name": null,
      "patch_url": null
    },
    "merge_commit_sha": "4a05825a3f3993b8e402a7c18e2bc04f6d287e96",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "head": {
      "label": "furszy:2025_threadpool_http_server",
      "ref": "2025_threadpool_http_server",
      "sha": "38fd85c676a072ebf256e806beda9d7533790baa",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 143624913,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDM2MjQ5MTM=",
        "name": "bitcoin-core",
        "full_name": "furszy/bitcoin-core",
        "owner": {
          "login": "furszy",
          "id": 5377650,
          "node_id": "MDQ6VXNlcjUzNzc2NTA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/furszy",
          "html_url": "https://github.com/furszy",
          "followers_url": "https://api.github.com/users/furszy/followers",
          "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
          "organizations_url": "https://api.github.com/users/furszy/orgs",
          "repos_url": "https://api.github.com/users/furszy/repos",
          "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/furszy/received_events",
          "type": "User",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/furszy/bitcoin-core",
        "description": "Bitcoin-Core",
        "fork": true,
        "url": "https://api.github.com/repos/furszy/bitcoin-core",
        "archive_url": "https://api.github.com/repos/furszy/bitcoin-core/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/furszy/bitcoin-core/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/furszy/bitcoin-core/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/furszy/bitcoin-core/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/furszy/bitcoin-core/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/furszy/bitcoin-core/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/furszy/bitcoin-core/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/furszy/bitcoin-core/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/furszy/bitcoin-core/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/furszy/bitcoin-core/contributors",
        "deployments_url": "https://api.github.com/repos/furszy/bitcoin-core/deployments",
        "downloads_url": "https://api.github.com/repos/furszy/bitcoin-core/downloads",
        "events_url": "https://api.github.com/repos/furszy/bitcoin-core/events",
        "forks_url": "https://api.github.com/repos/furszy/bitcoin-core/forks",
        "git_commits_url": "https://api.github.com/repos/furszy/bitcoin-core/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/furszy/bitcoin-core/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/furszy/bitcoin-core/git/tags%7B/sha%7D",
        "git_url": "git://github.com/furszy/bitcoin-core.git",
        "issue_comment_url": "https://api.github.com/repos/furszy/bitcoin-core/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/furszy/bitcoin-core/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/furszy/bitcoin-core/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/furszy/bitcoin-core/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/furszy/bitcoin-core/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/furszy/bitcoin-core/languages",
        "merges_url": "https://api.github.com/repos/furszy/bitcoin-core/merges",
        "milestones_url": "https://api.github.com/repos/furszy/bitcoin-core/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/furszy/bitcoin-core/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/furszy/bitcoin-core/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/furszy/bitcoin-core/releases%7B/id%7D",
        "ssh_url": "git@github.com:furszy/bitcoin-core.git",
        "stargazers_url": "https://api.github.com/repos/furszy/bitcoin-core/stargazers",
        "statuses_url": "https://api.github.com/repos/furszy/bitcoin-core/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/furszy/bitcoin-core/subscribers",
        "subscription_url": "https://api.github.com/repos/furszy/bitcoin-core/subscription",
        "tags_url": "https://api.github.com/repos/furszy/bitcoin-core/tags",
        "teams_url": "https://api.github.com/repos/furszy/bitcoin-core/teams",
        "trees_url": "https://api.github.com/repos/furszy/bitcoin-core/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/furszy/bitcoin-core.git",
        "hooks_url": "https://api.github.com/repos/furszy/bitcoin-core/hooks",
        "svn_url": "https://github.com/furszy/bitcoin-core",
        "homepage": "",
        "language": "C++",
        "forks_count": 3,
        "stargazers_count": 6,
        "watchers_count": 6,
        "size": 447670,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-11T17:48:16Z",
        "created_at": "2018-08-05T15:28:43Z",
        "updated_at": "2026-02-07T21:37:50Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "01651324f4e540f6b96cff31e89752c3f9417293",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "name": null,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38906,
        "stargazers_count": 88089,
        "watchers_count": 88089,
        "size": 303642,
        "default_branch": "master",
        "open_issues_count": 731,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2026-02-12T09:43:32Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2026-02-12T16:36:14Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 694,
    "deletions": 120,
    "changed_files": 8,
    "commits": 5,
    "review_comments": 160,
    "comments": 20
  },
  "events": [
    {
      "event": "labeled",
      "id": 20456160660,
      "node_id": "LE_lADOABII587TTDKpzwAAAATDSD2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20456160660",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:36:49Z",
      "label": {
        "name": "RPC/REST/ZMQ",
        "color": "0052cc"
      }
    },
    {
      "event": "commented",
      "id": 3437382621,
      "node_id": "IC_kwDOABII587M4kvd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437382621",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:36:51Z",
      "updated_at": "2026-02-10T18:23:29Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33689.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [Eunovo](https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3835015865), [sedited](https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3769661717), [pinheadmz](https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3774273771) |\n| Stale ACK | [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3593444540) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#34411](https://github.com/bitcoin/bitcoin/pull/34411) ([POC] Full Libevent removal by fanquake)\n* [#34400](https://github.com/bitcoin/bitcoin/pull/34400) (wallet: parallel fast rescan (approx 5x speed up with 16 threads) by Eunovo)\n* [#32061](https://github.com/bitcoin/bitcoin/pull/32061) (Replace libevent with our own HTTP and socket-handling implementation by pinheadmz)\n* [#26966](https://github.com/bitcoin/bitcoin/pull/26966) (index: initial sync speedup, parallelize process by furszy)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->\n### LLM Linter (✨ experimental)\n\n\n\nPossible typos and grammar issues:\n\n- servers responses -> server responses or servers' responses [possessive is missing; \"servers responses\" is ungrammatical]\n\n\n\n<sup>2026-01-30 21:18:09</sup>\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437382621",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3437391085,
      "node_id": "IC_kwDOABII587M4mzt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437391085",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:38:28Z",
      "updated_at": "2025-10-23T14:38:28Z",
      "author_association": "MEMBER",
      "body": "concept ACK :-) will be reviewing this",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437391085",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "review_requested",
      "id": 20456472339,
      "node_id": "RRE_lADOABII587TTDKpzwAAAATDTP8T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20456472339",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:49:34Z",
      "requested_reviewer": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 3437452461,
      "node_id": "IC_kwDOABII587M41yt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437452461",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:50:33Z",
      "updated_at": "2025-10-23T14:50:33Z",
      "author_association": "MEMBER",
      "body": "Adding myself as i wrote the original shitty code.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437452461",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3442252872,
      "node_id": "IC_kwDOABII587NLJxI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3442252872",
      "actor": {
        "login": "Raimo33",
        "id": 104778891,
        "node_id": "U_kgDOBj7Miw",
        "avatar_url": "https://avatars.githubusercontent.com/u/104778891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Raimo33",
        "html_url": "https://github.com/Raimo33",
        "followers_url": "https://api.github.com/users/Raimo33/followers",
        "following_url": "https://api.github.com/users/Raimo33/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Raimo33/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Raimo33/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Raimo33/subscriptions",
        "organizations_url": "https://api.github.com/users/Raimo33/orgs",
        "repos_url": "https://api.github.com/users/Raimo33/repos",
        "events_url": "https://api.github.com/users/Raimo33/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Raimo33/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-24T09:54:44Z",
      "updated_at": "2025-10-24T09:55:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "Can't we use an already existing open source library instead of reinventing the wheel?",
      "user": {
        "login": "Raimo33",
        "id": 104778891,
        "node_id": "U_kgDOBj7Miw",
        "avatar_url": "https://avatars.githubusercontent.com/u/104778891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Raimo33",
        "html_url": "https://github.com/Raimo33",
        "followers_url": "https://api.github.com/users/Raimo33/followers",
        "following_url": "https://api.github.com/users/Raimo33/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Raimo33/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Raimo33/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Raimo33/subscriptions",
        "organizations_url": "https://api.github.com/users/Raimo33/orgs",
        "repos_url": "https://api.github.com/users/Raimo33/repos",
        "events_url": "https://api.github.com/users/Raimo33/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Raimo33/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3442252872",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3444568607,
      "node_id": "IC_kwDOABII587NT_If",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3444568607",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-24T19:17:48Z",
      "updated_at": "2025-10-24T19:17:48Z",
      "author_association": "MEMBER",
      "body": "> Can't we use an already existing open source library instead of reinventing the wheel?\r\n\r\nThat's a good question. It's usually where we all start.\r\nGenerally, the project consensus is to avoid introducing new external dependencies (unless they’re maintained by us) to minimize potential attack vectors. This doesn’t mean we should reinvent everything, just that we need to be very careful about what we decide to include.\r\n\r\nThat being said, for the changes introduced in this PR, can argue that we’re encapsulating, documenting, and unit + fuzz testing code that wasn’t covered before, while also improving separation of responsibilities. We’re not adding anything more complex or that behaves radically differently from what we currently have.\r\nThe nice property of this PR is that it will let us experiment with more complex approaches in the future without having to deal with application-specific code (like the HTTP server code). This also includes learning from other open source libraries for sure.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3444568607",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3453541325,
      "node_id": "IC_kwDOABII587N2NvN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3453541325",
      "actor": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-27T22:17:47Z",
      "updated_at": "2025-10-27T22:17:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK",
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3453541325",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "reviewed",
      "id": 3389146181,
      "node_id": "PRR_kwDOABII587KAkRF",
      "url": null,
      "actor": null,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T14:51:59Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3389146181",
      "submitted_at": "2025-10-28T14:51:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "reviewed",
      "id": 3389972243,
      "node_id": "PRR_kwDOABII587KDt8T",
      "url": null,
      "actor": null,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T17:26:24Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3389972243",
      "submitted_at": "2025-10-28T17:26:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20562303395,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATJm9mj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20562303395",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/195a96258f970c384ce180d57e73616904ef5fa1",
      "created_at": "2025-10-28T19:08:59Z"
    },
    {
      "event": "reviewed",
      "id": 3390482262,
      "node_id": "PRR_kwDOABII587KFqdW",
      "url": null,
      "actor": null,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T19:29:51Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, thanks for the seperation from the initial index PR.",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3390482262",
      "submitted_at": "2025-10-28T19:29:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "reviewed",
      "id": 3385232782,
      "node_id": "PRR_kwDOABII587Jxo2O",
      "url": null,
      "actor": null,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-29T15:28:32Z",
      "author_association": "MEMBER",
      "body": "ACK 195a96258f970c384ce180d57e73616904ef5fa1\n\nBuilt and tested on macos/arm64 and debian/x86. Reviewed each commit and left a few comments.\n\nI also tested the branch against other popular software that consumes the HTTP interface by running their CI:\n- [bitcoinjs-lib](https://github.com/pinheadmz/bitcoinjs-lib/pull/2)\n- [rpc-bitcoin](https://github.com/pinheadmz/rpc-bitcoin/pull/2)\n- [eclair](https://github.com/pinheadmz/eclair/pull/2)\n- [lnd](https://github.com/pinheadmz/lnd/pull/2/)\n- [electrs](https://github.com/pinheadmz/electrs/pull/2)\n\n\nThe http worker threads are clearly labeled and visible in htop!\n\n<img width=\"559\" height=\"304\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/d27aedd8-0ac1-4659-8fa9-6389e49b0b8f\" />\n\n\n\n\n<details><summary>Show Signature</summary>\n\n```\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nACK 195a96258f970c384ce180d57e73616904ef5fa1\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmkCMdwACgkQ5+KYS2KJ\nyTriXA//RRnzezUHdmzRlKmoSDA+ZBHz0RY3z2LGk63izb/YdYaJY9JBZL2Y9BA8\nK2nyexdSDC/DFOm4H56ddEe6ChlB7w+uZc92SgFSLSvavInpZ80KEJRk07vgoIL7\nhwuyyevWyOOU32iz1NE3q316TMaJmzVsPhRGwbdmTXNwJLtUX6g4czfh28ajW1DC\nY9ULKwT36rFHRcKwC1YZYuBJUNBZWQgVBcydcmS1UEykY4mBnCW9knrATwn/29b7\n2AYPV+yuaiy9OpDEOJ8iKtZOPGR36NrIUleMUqruq4Sy2/TnJtm3AKNK0336/Fxu\nMqVyPKSyusg7kBA6f2h/2+NHpbyLoboYhjZew+HvED/aFfi+Jla+nxybkUYXfciL\npzbND22TTuRGB1fKU7AwPD0TO9JwOTU385iEdpoGq8rbT3EpgPr31N4TeDQDJx5t\njPzzWZYj43JMuIc3bm/K5S2HYSdFZUEDQC81kbND+jOLF6YkJwS9794anLO38tvi\nfip/eLK8Nw4pmWnW63/9lc+Y/1gLpgLDMxxhA1NKJyytk7z2IRo7vJKck6TqAjcZ\nnU8Wv9/ful5ndDJfLIKuYT9jqRk9ORohVwv+P+ppuO8jhFjhuswxPlFJKkMXTeZn\nhGi8QCrAUuibvVuLfLKVExJqSmmeUAkTVKp5ZTWLwNB7IkZrSoo=\n=hZYm\n-----END PGP SIGNATURE-----\n```\n\npinheadmz's public key is [on openpgp.org](https://keys.openpgp.org/vks/v1/by-fingerprint/E61773CD6E01040E2F1BD78CE7E2984B6289C93A)\n</details>\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3385232782",
      "submitted_at": "2025-10-29T15:28:32Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "review_requested",
      "id": 20583424463,
      "node_id": "RRE_lADOABII587TTDKpzwAAAATK3iHP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20583424463",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:28:37Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 20583424830,
      "node_id": "RRE_lADOABII587TTDKpzwAAAATK3iM-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20583424830",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:28:38Z",
      "requested_reviewer": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20584251694,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATK6sEu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20584251694",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "created_at": "2025-10-29T15:55:01Z"
    },
    {
      "event": "commented",
      "id": 3462430016,
      "node_id": "IC_kwDOABII587OYH1A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3462430016",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:56:44Z",
      "updated_at": "2025-10-29T15:56:44Z",
      "author_association": "MEMBER",
      "body": "Oh, awesome extensive test and review @pinheadmz! you rock!",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3462430016",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "mentioned",
      "id": 20584303883,
      "node_id": "MEE_lADOABII587TTDKpzwAAAATK640L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20584303883",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:56:46Z"
    },
    {
      "event": "subscribed",
      "id": 20584303920,
      "node_id": "SE_lADOABII587TTDKpzwAAAATK640w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20584303920",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:56:46Z"
    },
    {
      "event": "reviewed",
      "id": 3395201777,
      "node_id": "PRR_kwDOABII587KXqrx",
      "url": null,
      "actor": null,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-29T18:20:50Z",
      "author_association": "MEMBER",
      "body": "ACK f5eca8d5252a68f0fbc8b5efec021c75744555b6\n\nminor changes since last ack\n\n<details><summary>Show Signature</summary>\n\n```\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nACK f5eca8d5252a68f0fbc8b5efec021c75744555b6\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmkCWuYACgkQ5+KYS2KJ\nyTpb9RAAgxNlDQlqkVfnIK2Xt8BQmRsiG+1KHQGJA2d3RHoxjFg2129fj47y5i+t\nGlatlcsXEcibI2D0F22sKSzY1u0LWy4GYLI1d12JAIewA99n/lRr1ktDk3v64pp8\nkldvYpd8UBs7DCHSJhPs4HbOPgwIILPASdSbQTb+6m48X5jg+cu+yMBuANVq3sbB\n9I8rUlbUgRva5voy3EGRkXsGTuwcaCoLDNHnnjrqQkJMYTym47rMF/xTZJJ11isF\nQrpzFu+P2tFy1oj0bGd4e5EhqNk++qfRCuw9sGLgLL6YEHzC/ihVH/L5NAxoeJX4\nL0yX09BG5wDrbUQvZn4w1uaQz39Uor5mb8+tZyDUyRmO9MrG5AHomUtfdbiYLwSO\n007bLD+WX4Hxode47xCdhUhqflXqbHD2mhkf5ESyUgGu3smSHSQQosuzIJiVmTn9\nb2UJG6see/tckFvart6YLn1AIu9uCyUMmB+hZIcSasZv95oEHv1YB3E5dcKUmq0d\nA1cUHIhNvU4i/hNy2xgijgSjDdpVQMFbLYUt9y4ZnzpJXFd7mnbpHVUVM1P+Onvp\nScAtgvosXfbd5PjnAQWsMWgSmVHUtSc4t9GPjGlRYaVpHFkEbqWpWeKrYqMkU3id\n9YiFP9BueWNbNV7OBlB0LcfCpwO2WbvfJOW93/jxDovc0tgohbU=\n=c8aD\n-----END PGP SIGNATURE-----\n```\n\npinheadmz's public key is [on openpgp.org](https://keys.openpgp.org/vks/v1/by-fingerprint/E61773CD6E01040E2F1BD78CE7E2984B6289C93A)\n</details>\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3395201777",
      "submitted_at": "2025-10-29T18:20:49Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "reviewed",
      "id": 3396350580,
      "node_id": "PRR_kwDOABII587KcDJ0",
      "url": null,
      "actor": null,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-29T21:26:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK f5eca8d5252a68f0fbc8b5efec021c75744555b6\n\nI have fuzzed the thread pool for some time again, and did not find any new issues. Also the previously observed memory leak during fuzzing was not observed anymore. The changes to the http workers look sane to me.\n\nCan you run the commits through `clang-format-diff.py`? There are a bunch of formatting issues in the first two commits.",
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3396350580",
      "submitted_at": "2025-10-29T21:26:19Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20596043513,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATLnq75",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20596043513",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "created_at": "2025-10-30T01:21:07Z"
    },
    {
      "event": "commented",
      "id": 3465766818,
      "node_id": "IC_kwDOABII587Ok2ei",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3465766818",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T01:22:58Z",
      "updated_at": "2025-10-30T01:22:58Z",
      "author_association": "MEMBER",
      "body": "> Can you run the commits through clang-format-diff.py? There are a bunch of formatting issues in the first two commits.\r\n\r\nPushed.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3465766818",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "reviewed",
      "id": 3377790750,
      "node_id": "PRR_kwDOABII587JVP8e",
      "url": null,
      "actor": null,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-30T16:05:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "I have started reviewing this PR but have only finished the first commit (e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a).\r\n\r\nThe depth of tests gives me hope that this transition will be smooth, the tests cover most of the functionality, even a few corner cases I haven't thought of!\r\n\r\nIt seemed, however, that I had more to say about that than anticipated. I didn't even get to reviewing the threadpool properly, just most of the tests.\r\n\r\nI know receiving this amount of feedback can be daunting, but we both want this to succeed. I have spent a lot of time meticulously going through the details. I hope you will take it as I meant it: to make absolutely sure this won't cause any problems and that our test suite is rock solid.\r\nI will continue the review, but wanted to make sure you're aware of the progress and thought we can synchronize more often this way (pun intended).\r\n\r\nIn general I think adding a threadpool can untangle complicated code as such, but we have to find a balance between IO and CPU bound tasks. I found that oversubscription is usually a smaller problem, so we can likely solve the IO/CPU contention problem by creating dedicated `ThreadPools` for each major task (http, script verification, input fetcher, compaction, etc). This way it won't be a general resource guardian (which can be a ThreadPool's main purpose), just a tool to avoid the overhead of starting/stopping threads.\r\n\r\nAs hinted in the original thread, I find the current structure to be harder to follow, I would appreciate if you would consider doing the extraction in smaller steps:\r\n* first step would be to use the new `ThreadPool`'s structure, but extract the old logic into it;\r\n* add the tests (unit and fuzz, no need to split it) against the old impl in a separate commit;\r\n* in a last step swap it out with the new logic, keeping the same structure and tests.\r\n\r\nThis way we could debug and understand the old code before we jump into the new one - and the tests would guide us in guaranteeing that the behavior stayed basically the same.\r\nI understand that's extra work, but I'm of course willing to help in whatever you need to be able to do a less risky transition.\r\n\r\nI glanced quickly to the actual `ThreadPool` implementation, looks okay, but I want to investigate as part of my next wave of reviews why we need so much locking here and why we're relying on old primitives here instead of the C++20 concurrency tools (such as latches and barriers) and whether we can create and destroy the pool via RAII instead of manual start/stops.\r\n\r\nNote that I have done an IBD before and after this change to see if everything was still working and I didn't see any regression!\r\n\r\n<details>\r\n<summary>here are all the changes I did locally while reviewing the change</summary>\r\n\r\n```patch\r\ndiff --git a/src/test/threadpool_tests.cpp b/src/test/threadpool_tests.cpp\r\nindex e8200533cd..052784db37 100644\r\n--- a/src/test/threadpool_tests.cpp\r\n+++ b/src/test/threadpool_tests.cpp\r\n@@ -2,270 +2,208 @@\r\n // Distributed under the MIT software license, see the accompanying\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n+#include <common/system.h>\r\n+#include <test/util/setup_common.h>\r\n #include <util/string.h>\r\n #include <util/threadpool.h>\r\n+#include <util/time.h>\r\n \r\n #include <boost/test/unit_test.hpp>\r\n \r\n-BOOST_AUTO_TEST_SUITE(threadpool_tests)\r\n+#include <latch>\r\n+#include <semaphore>\r\n \r\n-constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\r\n+using namespace std::chrono;\r\n+constexpr auto TIMEOUT = seconds(120);\r\n \r\n-template <typename T>\r\n-void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\r\n+void WaitFor(std::span<const std::future<void>> futures)\r\n {\r\n-    for (size_t i = 0; i < futures.size(); ++i) {\r\n-        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\r\n-            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\r\n-        }\r\n+    for (const auto& f : futures) {\r\n+        BOOST_REQUIRE(f.wait_for(TIMEOUT) == std::future_status::ready);\r\n     }\r\n }\r\n \r\n // Block a number of worker threads by submitting tasks that wait on `blocker_future`.\r\n // Returns the futures of the blocking tasks, ensuring all have started and are waiting.\r\n-std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\r\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::counting_semaphore<>& release_sem, size_t num_of_threads_to_block)\r\n {\r\n-    // Per-thread ready promises to ensure all workers are actually blocked\r\n-    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\r\n-    std::vector<std::future<void>> ready_futures;\r\n-    ready_futures.reserve(num_of_threads_to_block);\r\n-    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\r\n-\r\n-    // Fill all workers with blocking tasks\r\n-    std::vector<std::future<void>> blocking_tasks;\r\n-    for (int i = 0; i < num_of_threads_to_block; i++) {\r\n-        std::promise<void>& ready = ready_promises[i];\r\n-        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\r\n-            ready.set_value();\r\n-            blocker_future.wait();\r\n-        }));\r\n-    }\r\n+    assert(threadPool.WorkersCount() >= num_of_threads_to_block);\r\n+    std::latch ready{std::ptrdiff_t(num_of_threads_to_block)};\r\n \r\n-    // Wait until all threads are actually blocked\r\n-    WaitFor(ready_futures, context);\r\n+    std::vector<std::future<void>> blocking_tasks(num_of_threads_to_block);\r\n+    for (auto& f : blocking_tasks) f = threadPool.Submit([&] {\r\n+        ready.count_down();\r\n+        release_sem.acquire();\r\n+    });\r\n+\r\n+    ready.wait();\r\n     return blocking_tasks;\r\n }\r\n \r\n-BOOST_AUTO_TEST_CASE(threadpool_basic)\r\n+BOOST_FIXTURE_TEST_SUITE(threadpool_tests, BasicTestingSetup)\r\n+\r\n+const size_t NUM_WORKERS_DEFAULT{size_t(GetNumCores()) + 1}; // we need to make sure there's *some* contention\r\n+\r\n+BOOST_AUTO_TEST_CASE(submit_to_non_started_pool_throws)\r\n {\r\n-    // Test Cases\r\n-    // 0) Submit task to a non-started pool.\r\n-    // 1) Submit tasks and verify completion.\r\n-    // 2) Maintain all threads busy except one.\r\n-    // 3) Wait for work to finish.\r\n-    // 4) Wait for result object.\r\n-    // 5) The task throws an exception, catch must be done in the consumer side.\r\n-    // 6) Busy workers, help them by processing tasks from outside.\r\n-    // 7) Recursive submission of tasks.\r\n-    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\r\n-\r\n-    const int NUM_WORKERS_DEFAULT = 3;\r\n-    const std::string POOL_NAME = \"test\";\r\n-\r\n-    // Test case 0, submit task to a non-started pool\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        bool err = false;\r\n-        try {\r\n-            threadPool.Submit([]() { return false; });\r\n-        } catch (const std::runtime_error&) {\r\n-            err = true;\r\n-        }\r\n-        BOOST_CHECK(err);\r\n+    ThreadPool threadPool{\"not_started\"};\r\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([] { return 0; }), std::runtime_error, HasReason{\"No active workers\"});\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(submit_and_verify_completion)\r\n+{\r\n+    ThreadPool threadPool{\"completion\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+\r\n+    const auto num_tasks{1 + m_rng.randrange<size_t>(50)};\r\n+    std::atomic_size_t counter{0};\r\n+\r\n+    std::vector<std::future<void>> futures(num_tasks);\r\n+    for (size_t i{0}; i < num_tasks; ++i) {\r\n+        futures[i] = threadPool.Submit([&counter, i] { counter.fetch_add(i, std::memory_order_relaxed); });\r\n     }\r\n \r\n-    // Test case 1, submit tasks and verify completion.\r\n-    {\r\n-        int num_tasks = 50;\r\n+    WaitFor(futures);\r\n+    BOOST_CHECK_EQUAL(counter.load(std::memory_order_relaxed), (num_tasks - 1) * num_tasks / 2);\r\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n+}\r\n \r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-        std::atomic<int> counter = 0;\r\n+BOOST_AUTO_TEST_CASE(limited_free_workers_processes_all_task)\r\n+{\r\n+    ThreadPool threadPool{\"block_counts\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n \r\n-        // Store futures to ensure completion before checking counter.\r\n-        std::vector<std::future<void>> futures;\r\n-        futures.reserve(num_tasks);\r\n+    for (size_t free{1}; free < NUM_WORKERS_DEFAULT; ++free) {\r\n+        BOOST_TEST_MESSAGE(\"Testing with \" << free << \" available workers\");\r\n+        std::counting_semaphore sem{0};\r\n+        const auto blocking_tasks{BlockWorkers(threadPool, sem, free)};\r\n \r\n-        for (int i = 1; i <= num_tasks; i++) {\r\n-            futures.emplace_back(threadPool.Submit([&counter, i]() {\r\n-                counter.fetch_add(i);\r\n-            }));\r\n-        }\r\n+        size_t counter{0};\r\n+        std::vector<std::future<void>> futures(num_tasks);\r\n+        for (auto& f : futures) f = threadPool.Submit([&counter] { ++counter; });\r\n \r\n-        // Wait for all tasks to finish\r\n-        WaitFor(futures, /*context=*/\"test1 task\");\r\n-        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\r\n-        BOOST_CHECK_EQUAL(counter.load(), expected_value);\r\n+        WaitFor(futures);\r\n         BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n-    }\r\n \r\n-    // Test case 2, maintain all threads busy except one.\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-        // Single blocking future for all threads\r\n-        std::promise<void> blocker;\r\n-        std::shared_future<void> blocker_future(blocker.get_future());\r\n-        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\r\n-\r\n-        // Now execute tasks on the single available worker\r\n-        // and check that all the tasks are executed.\r\n-        int num_tasks = 15;\r\n-        int counter = 0;\r\n-\r\n-        // Store futures to wait on\r\n-        std::vector<std::future<void>> futures;\r\n-        futures.reserve(num_tasks);\r\n-        for (int i = 0; i < num_tasks; i++) {\r\n-            futures.emplace_back(threadPool.Submit([&counter]() {\r\n-                counter += 1;\r\n-            }));\r\n+        if (free == 1) {\r\n+            BOOST_CHECK_EQUAL(counter, num_tasks);\r\n+        } else {\r\n+            BOOST_CHECK_LE(counter, num_tasks); // unsynchronized update from multiple threads doesn't guarantee consistency\r\n         }\r\n \r\n-        WaitFor(futures, /*context=*/\"test2 tasks\");\r\n-        BOOST_CHECK_EQUAL(counter, num_tasks);\r\n-\r\n-        blocker.set_value();\r\n-        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\r\n-        threadPool.Stop();\r\n-        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\r\n+        sem.release(free);\r\n+        WaitFor(blocking_tasks);\r\n     }\r\n \r\n-    // Test case 3, wait for work to finish.\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-        std::atomic<bool> flag = false;\r\n-        std::future<void> future = threadPool.Submit([&flag]() {\r\n-            std::this_thread::sleep_for(std::chrono::milliseconds{200});\r\n-            flag.store(true);\r\n-        });\r\n-        future.wait();\r\n-        BOOST_CHECK(flag.load());\r\n-    }\r\n+    threadPool.Stop();\r\n+}\r\n \r\n-    // Test case 4, obtain result object.\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-        std::future<bool> future_bool = threadPool.Submit([]() {\r\n-            return true;\r\n-        });\r\n-        BOOST_CHECK(future_bool.get());\r\n+BOOST_AUTO_TEST_CASE(future_wait_blocks_until_task_completes)\r\n+{\r\n+    ThreadPool threadPool{\"wait_test\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n \r\n-        std::future<std::string> future_str = threadPool.Submit([]() {\r\n-            return std::string(\"true\");\r\n-        });\r\n-        std::string result = future_str.get();\r\n-        BOOST_CHECK_EQUAL(result, \"true\");\r\n+    const auto start{steady_clock::now()};\r\n+\r\n+    std::vector<std::future<void>> futures(num_tasks + 1);\r\n+    for (size_t i{0}; i <= num_tasks; ++i) {\r\n+        futures[i] = threadPool.Submit([i] { UninterruptibleSleep(milliseconds{i}); });\r\n     }\r\n+    WaitFor(futures);\r\n \r\n-    // Test case 5, throw exception and catch it on the consumer side.\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-\r\n-        int ROUNDS = 5;\r\n-        std::string err_msg{\"something wrong happened\"};\r\n-        std::vector<std::future<void>> futures;\r\n-        futures.reserve(ROUNDS);\r\n-        for (int i = 0; i < ROUNDS; i++) {\r\n-            futures.emplace_back(threadPool.Submit([err_msg, i]() {\r\n-                throw std::runtime_error(err_msg + util::ToString(i));\r\n-            }));\r\n-        }\r\n+    const size_t elapsed_ms{size_t(duration_cast<milliseconds>(steady_clock::now() - start).count())};\r\n+    BOOST_CHECK(elapsed_ms >= num_tasks);\r\n+}\r\n \r\n-        for (int i = 0; i < ROUNDS; i++) {\r\n-            try {\r\n-                futures.at(i).get();\r\n-                BOOST_FAIL(\"Expected exception not thrown\");\r\n-            } catch (const std::runtime_error& e) {\r\n-                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\r\n-            }\r\n-        }\r\n-    }\r\n+BOOST_AUTO_TEST_CASE(future_get_returns_task_result)\r\n+{\r\n+    ThreadPool threadPool{\"result_test\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n \r\n-    // Test case 6, all workers are busy, help them by processing tasks from outside.\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-\r\n-        std::promise<void> blocker;\r\n-        std::shared_future<void> blocker_future(blocker.get_future());\r\n-        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\r\n-\r\n-        // Now submit tasks and check that none of them are executed.\r\n-        int num_tasks = 20;\r\n-        std::atomic<int> counter = 0;\r\n-        for (int i = 0; i < num_tasks; i++) {\r\n-            threadPool.Submit([&counter]() {\r\n-                counter.fetch_add(1);\r\n-            });\r\n-        }\r\n-        std::this_thread::sleep_for(std::chrono::milliseconds{100});\r\n-        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);\r\n+    BOOST_CHECK_EQUAL(threadPool.Submit([] { return true; }).get(), true);\r\n+    BOOST_CHECK_EQUAL(threadPool.Submit([] { return 42; }).get(), 42);\r\n+    BOOST_CHECK_EQUAL(threadPool.Submit([] { return std::string{\"true\"}; }).get(), \"true\");\r\n+}\r\n \r\n-        // Now process manually\r\n-        for (int i = 0; i < num_tasks; i++) {\r\n-            threadPool.ProcessTask();\r\n-        }\r\n-        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\r\n-        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n-        blocker.set_value();\r\n-        threadPool.Stop();\r\n-        WaitFor(blocking_tasks, \"Failure waiting for test6 blocking task futures\");\r\n+BOOST_AUTO_TEST_CASE(task_exception_propagated_to_future)\r\n+{\r\n+    ThreadPool threadPool{\"exception_test\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+\r\n+    const auto err{[&](size_t n) { return strprintf(\"error on thread #%s\", n); }};\r\n+\r\n+    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n+    for (size_t i{0}; i < num_tasks; ++i) {\r\n+        BOOST_CHECK_EXCEPTION(threadPool.Submit([&] { throw std::runtime_error(err(i)); }).get(), std::runtime_error, HasReason{err(i)});\r\n     }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(process_task_manually_when_workers_busy)\r\n+{\r\n+    ThreadPool threadPool{\"manual_process\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n \r\n-    // Test case 7, recursive submission of tasks.\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+    std::counting_semaphore sem{0};\r\n+    const auto blocking_tasks{BlockWorkers(threadPool, sem, NUM_WORKERS_DEFAULT)};\r\n \r\n-        std::promise<void> signal;\r\n-        threadPool.Submit([&]() {\r\n-            threadPool.Submit([&]() {\r\n-                signal.set_value();\r\n-            });\r\n-        });\r\n+    std::atomic_size_t counter{0};\r\n+    std::vector<std::future<void>> futures(num_tasks);\r\n+    for (auto& f : futures) f = threadPool.Submit([&counter] { counter.fetch_add(1, std::memory_order_relaxed); });\r\n \r\n-        signal.get_future().wait();\r\n-        threadPool.Stop();\r\n-    }\r\n+    UninterruptibleSleep(milliseconds{100});\r\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), num_tasks);\r\n \r\n-    // Test case 8, submit a task when all threads are busy and then stop the pool.\r\n-    {\r\n-        ThreadPool threadPool(POOL_NAME);\r\n-        threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+    for (size_t i{0}; i < num_tasks; ++i) {\r\n+        threadPool.ProcessTask();\r\n+    }\r\n \r\n-        std::promise<void> blocker;\r\n-        std::shared_future<void> blocker_future(blocker.get_future());\r\n-        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test8 blocking tasks enabled\");\r\n+    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\r\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n \r\n-        // Submit an extra task that should execute once a worker is free\r\n-        std::future<bool> future = threadPool.Submit([]() { return true; });\r\n+    sem.release(NUM_WORKERS_DEFAULT);\r\n+    WaitFor(blocking_tasks);\r\n+}\r\n \r\n-        // At this point, all workers are blocked, and the extra task is queued\r\n-        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\r\n+BOOST_AUTO_TEST_CASE(recursive_task_submission)\r\n+{\r\n+    ThreadPool threadPool{\"recursive\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n \r\n-        // Wait a short moment before unblocking the threads to mimic a concurrent shutdown\r\n-        std::thread thread_unblocker([&blocker]() {\r\n-            std::this_thread::sleep_for(std::chrono::milliseconds{300});\r\n-            blocker.set_value();\r\n+    std::promise<void> signal;\r\n+    threadPool.Submit([&threadPool, &signal] {\r\n+        threadPool.Submit([&signal] {\r\n+            signal.set_value();\r\n         });\r\n+    });\r\n \r\n-        // Stop the pool while the workers are still blocked\r\n-        threadPool.Stop();\r\n+    signal.get_future().wait();\r\n+}\r\n \r\n-        // Expect the submitted task to complete\r\n-        BOOST_CHECK(future.get());\r\n-        thread_unblocker.join();\r\n+BOOST_AUTO_TEST_CASE(stop_completes_queued_tasks_gracefully)\r\n+{\r\n+    ThreadPool threadPool{\"graceful_stop\"};\r\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n \r\n-        // Obviously all the previously blocking tasks should be completed at this point too\r\n-        WaitFor(blocking_tasks, \"Failure waiting for test8 blocking task futures\");\r\n+    std::counting_semaphore sem{0};\r\n+    const auto blocking_tasks{BlockWorkers(threadPool, sem, NUM_WORKERS_DEFAULT)};\r\n \r\n-        // Pool should be stopped and no workers remaining\r\n-        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\r\n-    }\r\n+    auto future{threadPool.Submit([] { return true; })};\r\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\r\n+\r\n+    std::thread thread_unblocker{[&sem] {\r\n+        std::this_thread::sleep_for(milliseconds{300});\r\n+        sem.release(NUM_WORKERS_DEFAULT);\r\n+    }};\r\n+\r\n+    threadPool.Stop();\r\n+\r\n+    BOOST_CHECK(future.get());\r\n+    thread_unblocker.join();\r\n+    WaitFor(blocking_tasks);\r\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\r\n }\r\n \r\n BOOST_AUTO_TEST_SUITE_END()\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\nindex 5d9884086e..c89fda37c2 100644\r\n--- a/src/util/threadpool.h\r\n+++ b/src/util/threadpool.h\r\n@@ -24,6 +24,8 @@\r\n #include <utility>\r\n #include <vector>\r\n \r\n+#include <tinyformat.h>\r\n+\r\n /**\r\n  * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\r\n  *\r\n@@ -62,16 +64,9 @@ private:\r\n         for (;;) {\r\n             std::packaged_task<void()> task;\r\n             {\r\n-                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\r\n-                if (!m_interrupt && m_work_queue.empty()) {\r\n-                    // Block until the pool is interrupted or a task is available.\r\n-                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\r\n-                }\r\n-\r\n-                // If stopped and no work left, exit worker\r\n-                if (m_interrupt && m_work_queue.empty()) {\r\n-                    return;\r\n-                }\r\n+                // Block until the pool is interrupted or a task is available.\r\n+                m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\r\n+                if (m_interrupt && m_work_queue.empty()) return;\r\n \r\n                 task = std::move(m_work_queue.front());\r\n                 m_work_queue.pop();\r\n@@ -101,17 +96,16 @@ public:\r\n      *\r\n      * Must be called from a controller (non-worker) thread.\r\n      */\r\n-    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n+    void Start(size_t num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         assert(num_workers > 0);\r\n         LOCK(m_mutex);\r\n         if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\r\n         m_interrupt = false; // Reset\r\n \r\n-        // Create workers\r\n         m_workers.reserve(num_workers);\r\n-        for (int i = 0; i < num_workers; i++) {\r\n-            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\r\n+        for (size_t i{0}; i < num_workers; i++) {\r\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\r\n         }\r\n     }\r\n \r\n@@ -179,12 +173,6 @@ public:\r\n         task();\r\n     }\r\n \r\n-    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n-    {\r\n-        WITH_LOCK(m_mutex, m_interrupt = true);\r\n-        m_cv.notify_all();\r\n-    }\r\n-\r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         return WITH_LOCK(m_mutex, return m_work_queue.size());\r\n```\r\n\r\n</details>\r\n",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3377790750",
      "submitted_at": "2025-10-30T16:05:25Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "commented",
      "id": 3469642268,
      "node_id": "IC_kwDOABII587Ozooc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3469642268",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-30T19:03:08Z",
      "updated_at": "2025-10-30T19:44:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "I've been playing around with the fuzz test and wanted to update here, even if it's still a bit inconclusive. \r\n\r\nI'm running into non-reproducible timeouts when using `fork` with libFuzzer. I'm overusing my cores by a lot (`fork=25` plus the 3 workers each), and I'm not yet sure if these timeouts would happen eventually when using less cores.\r\n\r\nI have \"fixed\" this by changing `notify_one` in `Submit` to `notify_all`, although I can't say I'm exactly sure why this works. It almost seems like some of the workers aren't being woken up at all when only one is being notified. Maybe the same one somehow ends up being reused over and over, so it gets stuck waiting? But then with `notify_all` all idle workers are woken up with every task, so the thread pool is able to handle the cpu overload more effectively.\r\n\r\nedit: This should be reproducible in the sense that if you run with `fork` close to the number of total cores on your machine and set `-timeout=30` you should get timeouts in less than an hour of fuzzing.",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3469642268",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "reviewed",
      "id": 3403702771,
      "node_id": "PRR_kwDOABII587K4GHz",
      "url": null,
      "actor": null,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-31T12:48:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK https://github.com/bitcoin/bitcoin/pull/33689/commits/435e8b5a55033fbfc6428a612b9826713b3cf57a\r\n\r\nThe PR looks good already, but I think we can block users from calling `Threadpool::Start()` and `Threadpool::Stop()` inside Worker threads; We can use a thread local variable to identify worker threads and reject the operation.",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3403702771",
      "submitted_at": "2025-10-31T12:48:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20989526359,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATjEsFX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20989526359",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/adb891184ee341e5107ece8f592939ead81d7a99",
      "created_at": "2025-11-17T14:58:00Z"
    },
    {
      "event": "reviewed",
      "id": 3473454632,
      "node_id": "PRR_kwDOABII587PCLYo",
      "url": null,
      "actor": null,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-17T17:00:57Z",
      "author_association": "CONTRIBUTOR",
      "body": "Left a few more comments to help with moving this forward.\nI like the new structure more and after the tests and the restructuring are finished, I would like to spend some more time reviewing the `ThreadPool` as well - but I want to make sure we have a solid foundation first.",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3473454632",
      "submitted_at": "2025-11-17T17:00:57Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21025070971,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATlMR97",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21025070971",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "created_at": "2025-11-18T19:35:58Z"
    },
    {
      "event": "commented",
      "id": 3549372484,
      "node_id": "IC_kwDOABII587TjyBE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3549372484",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-18T20:04:20Z",
      "updated_at": "2025-11-18T20:04:41Z",
      "author_association": "MEMBER",
      "body": "> I've been playing around with the fuzz test and wanted to update here, even if it's still a bit inconclusive.\r\n> \r\n> I'm running into non-reproducible timeouts when using `fork` with libFuzzer. I'm overusing my cores by a lot (`fork=25` plus the 3 workers each), and I'm not yet sure if these timeouts would happen eventually when using less cores.\r\n> \r\n> I have \"fixed\" this by changing `notify_one` in `Submit` to `notify_all`, although I can't say I'm exactly sure why this works. It almost seems like some of the workers aren't being woken up at all when only one is being notified. Maybe the same one somehow ends up being reused over and over, so it gets stuck waiting? But then with `notify_all` all idle workers are woken up with every task, so the thread pool is able to handle the cpu overload more effectively.\r\n> \r\n> edit: This should be reproducible in the sense that if you run with `fork` close to the number of total cores on your machine and set `-timeout=30` you should get timeouts in less than an hour of fuzzing.\r\n\r\n@marcofleon I don’t think this is an issue. You’re just massively oversubscribing the CPU and lowering the timeout to the point where all the context switching triggers it. Switching to `notify_all()` only forces all workers awake on every submission, which masks the OS scheduler starvation you get in this kind of extreme setup.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3549372484",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "mentioned",
      "id": 21025706482,
      "node_id": "MEE_lADOABII587TTDKpzwAAAATlOtHy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21025706482",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-18T20:05:01Z"
    },
    {
      "event": "subscribed",
      "id": 21025706513,
      "node_id": "SE_lADOABII587TTDKpzwAAAATlOtIR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21025706513",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-11-18T20:05:01Z"
    },
    {
      "event": "reviewed",
      "id": 3482342931,
      "node_id": "PRR_kwDOABII587PkFYT",
      "url": null,
      "actor": null,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-11-19T18:03:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "After the tests, I have reviewed the `ThreadPool` as well now - first iteration, have a few questions, I expect a few more rounds of review.\r\nI left some modernization suggestions and fine-grained commit requests to make the change easily reviewable.\r\n\r\nI still share many of @andrewtoth's concerns regarding RAII vs Start/Stop/Interrupt and I think we can modernize the pool from `std::condition_variable` with locks to C++20 `std::counting_semaphore`. Besides my suggestions below I think we should merge `Stop/Interrupt` maybe via a `bool join = true` parameter.\r\n\r\nThere's also some duplication between `WorkerThread` and `ProcessTask` that we can likely avoid (the test are passing, we can either simplify or improve our testing).\r\nThere are also a few remaining inconsistencies (I have mentioned a few, repeating a some of them here for visibility).\r\nSimilarly to before, I have tracked my suggestions locally, here's the patch to simplify checking my suggestions against your local copy:\r\n\r\n<details>\r\n<summary>Threadpool & tests</summary>\r\n\r\n```patch\r\ndiff --git a/src/httpserver.cpp b/src/httpserver.cpp\r\nindex 6069062abd..c5033462ac 100644\r\n--- a/src/httpserver.cpp\r\n+++ b/src/httpserver.cpp\r\n@@ -253,7 +253,7 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\r\n     // Dispatch to worker thread\r\n     if (i != iend) {\r\n         if ((int)g_threadpool_http.WorkQueueSize() < g_max_queue_depth) {\r\n-            g_threadpool_http.Submit([req = std::move(hreq), in_path = std::move(path), fn = i->handler]() {\r\n+            (void)g_threadpool_http.Enqueue([req = std::move(hreq), in_path = std::move(path), fn = i->handler] {\r\n                 fn(req.get(), in_path);\r\n             });\r\n         } else {\r\ndiff --git a/src/test/threadpool_tests.cpp b/src/test/threadpool_tests.cpp\r\nindex 8cbaf89ddf..56e4fc27e0 100644\r\n--- a/src/test/threadpool_tests.cpp\r\n+++ b/src/test/threadpool_tests.cpp\r\n@@ -3,30 +3,18 @@\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n #include <common/system.h>\r\n-#include <util/string.h>\r\n+#include <test/util/setup_common.h>\r\n #include <util/threadpool.h>\r\n #include <util/time.h>\r\n \r\n #include <boost/test/unit_test.hpp>\r\n \r\n-// Test Cases Overview\r\n-// 0) Submit task to a non-started pool.\r\n-// 1) Submit tasks and verify completion.\r\n-// 2) Maintain all threads busy except one.\r\n-// 3) Wait for work to finish.\r\n-// 4) Wait for result object.\r\n-// 5) The task throws an exception, catch must be done in the consumer side.\r\n-// 6) Busy workers, help them by processing tasks externally.\r\n-// 7) Recursive submission of tasks.\r\n-// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\r\n-// 9) Congestion test; create more workers than available cores.\r\n-// 10) Ensure Interrupt() prevents further submissions.\r\n-BOOST_AUTO_TEST_SUITE(threadpool_tests)\r\n-\r\n-// General test values\r\n-constexpr int NUM_WORKERS_DEFAULT = 3;\r\n-constexpr char POOL_NAME[] = \"test\";\r\n-constexpr auto WAIT_TIMEOUT = 120s;\r\n+#include <latch>\r\n+#include <semaphore>\r\n+\r\n+using namespace std::chrono;\r\n+\r\n+constexpr auto WAIT_TIMEOUT{120s};\r\n \r\n #define WAIT_FOR(futures)                                                         \\\r\n     do {                                                                          \\\r\n@@ -37,259 +25,233 @@ constexpr auto WAIT_TIMEOUT = 120s;\r\n \r\n // Block a number of worker threads by submitting tasks that wait on `blocker_future`.\r\n // Returns the futures of the blocking tasks, ensuring all have started and are waiting.\r\n-std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block)\r\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::counting_semaphore<>& release_sem, size_t num_of_threads_to_block)\r\n {\r\n-    // Per-thread ready promises to ensure all workers are actually blocked\r\n-    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\r\n-    std::vector<std::future<void>> ready_futures;\r\n-    ready_futures.reserve(num_of_threads_to_block);\r\n-    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\r\n-\r\n-    // Fill all workers with blocking tasks\r\n-    std::vector<std::future<void>> blocking_tasks;\r\n-    for (int i = 0; i < num_of_threads_to_block; i++) {\r\n-        std::promise<void>& ready = ready_promises[i];\r\n-        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\r\n-            ready.set_value();\r\n-            blocker_future.wait();\r\n-        }));\r\n-    }\r\n-\r\n-    // Wait until all threads are actually blocked\r\n-    WAIT_FOR(ready_futures);\r\n+    assert(threadPool.WorkersCount() >= num_of_threads_to_block);\r\n+    std::latch ready{std::ptrdiff_t(num_of_threads_to_block)};\r\n+    std::vector<std::future<void>> blocking_tasks(num_of_threads_to_block);\r\n+    for (auto& f : blocking_tasks) f = threadPool.Enqueue([&] {\r\n+        ready.count_down();\r\n+        release_sem.acquire();\r\n+    });\r\n+    ready.wait();\r\n     return blocking_tasks;\r\n }\r\n \r\n-// Test 0, submit task to a non-started pool\r\n+BOOST_FIXTURE_TEST_SUITE(threadpool_tests, BasicTestingSetup)\r\n+\r\n+// Submit task to a non-started pool\r\n BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\r\n-        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\r\n-        return true;\r\n-    });\r\n+    ThreadPool threadPool{\"not_started\"};\r\n+    BOOST_CHECK_EXCEPTION((void)threadPool.Enqueue([] { return 0; }), std::runtime_error, HasReason{\"No active workers\"});\r\n }\r\n \r\n-// Test 1, submit tasks and verify completion\r\n+// Submit tasks and verify completion\r\n BOOST_AUTO_TEST_CASE(submit_tasks_complete_successfully)\r\n {\r\n-    int num_tasks = 50;\r\n-\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-    std::atomic<int> counter = 0;\r\n-\r\n-    // Store futures to ensure completion before checking counter.\r\n-    std::vector<std::future<void>> futures;\r\n-    futures.reserve(num_tasks);\r\n-    for (int i = 1; i <= num_tasks; i++) {\r\n-        futures.emplace_back(threadPool.Submit([&counter, i]() {\r\n-            counter.fetch_add(i, std::memory_order_relaxed);\r\n-        }));\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"completion\"};\r\n+    threadPool.Start(num_workers);\r\n+\r\n+    const auto num_tasks{1 + m_rng.randrange<size_t>(50)};\r\n+    std::atomic_size_t counter{0};\r\n+\r\n+    std::vector<std::future<void>> futures(num_tasks);\r\n+    for (size_t i{0}; i < num_tasks; ++i) {\r\n+        futures[i] = threadPool.Enqueue([&counter, i] { counter.fetch_add(i, std::memory_order_relaxed); });\r\n     }\r\n \r\n-    // Wait for all tasks to finish\r\n     WAIT_FOR(futures);\r\n-    int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\r\n-    BOOST_CHECK_EQUAL(counter.load(), expected_value);\r\n+    BOOST_CHECK_EQUAL(counter.load(std::memory_order_relaxed), (num_tasks - 1) * num_tasks / 2);\r\n     BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n }\r\n \r\n-// Test 2, maintain all threads busy except one\r\n-BOOST_AUTO_TEST_CASE(single_available_worker_executes_all_tasks)\r\n+// Block varying numbers of workers and verify remaining workers process all tasks\r\n+BOOST_AUTO_TEST_CASE(limited_free_workers_processes_all_tasks)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-    // Single blocking future for all threads\r\n-    std::promise<void> blocker;\r\n-    std::shared_future<void> blocker_future(blocker.get_future());\r\n-    const auto blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1);\r\n-\r\n-    // Now execute tasks on the single available worker\r\n-    // and check that all the tasks are executed.\r\n-    int num_tasks = 15;\r\n-    int counter = 0;\r\n-\r\n-    // Store futures to wait on\r\n-    std::vector<std::future<void>> futures(num_tasks);\r\n-    for (auto& f : futures) f = threadPool.Submit([&counter]{ counter++; });\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"limited_workers\"};\r\n+    threadPool.Start(num_workers);\r\n \r\n-    WAIT_FOR(futures);\r\n-    BOOST_CHECK_EQUAL(counter, num_tasks);\r\n+    const auto num_tasks{5 + m_rng.randrange<size_t>(20)};\r\n+\r\n+    for (size_t free{1}; free < num_workers; ++free) {\r\n+        BOOST_TEST_MESSAGE(\"Testing with \" << free << \" available workers\");\r\n+        std::counting_semaphore sem{0};\r\n+        const auto blocking_tasks{BlockWorkers(threadPool, sem, num_workers - free)};\r\n+\r\n+        size_t counter{0};\r\n+        std::vector<std::future<void>> futures(num_tasks);\r\n+        for (auto& f : futures) f = threadPool.Enqueue([&counter] { ++counter; });\r\n+\r\n+        WAIT_FOR(futures);\r\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n+\r\n+        if (free == 1) {\r\n+            BOOST_CHECK_EQUAL(counter, num_tasks);\r\n+        } else {\r\n+            BOOST_CHECK_LE(counter, num_tasks); // unsynchronized update from multiple threads doesn't guarantee consistency\r\n+        }\r\n+\r\n+        sem.release(num_workers - free);\r\n+        WAIT_FOR(blocking_tasks);\r\n+    }\r\n \r\n-    blocker.set_value();\r\n-    WAIT_FOR(blocking_tasks);\r\n     threadPool.Stop();\r\n     BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\r\n }\r\n \r\n-// Test 3, wait for work to finish\r\n+// Wait for work to finish\r\n BOOST_AUTO_TEST_CASE(wait_for_task_to_finish)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-    std::atomic<bool> flag = false;\r\n-    std::future<void> future = threadPool.Submit([&flag]() {\r\n-        UninterruptibleSleep(std::chrono::milliseconds{200});\r\n-        flag.store(true, std::memory_order_release);\r\n-    });\r\n-    BOOST_CHECK(future.wait_for(WAIT_TIMEOUT) == std::future_status::ready);\r\n-    BOOST_CHECK(flag.load(std::memory_order_acquire));\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"wait_test\"};\r\n+    threadPool.Start(num_workers);\r\n+\r\n+    const auto num_tasks{1 + m_rng.randrange<size_t>(10)};\r\n+    const auto start{SteadyClock::now()};\r\n+\r\n+    std::vector<std::future<void>> futures(num_tasks + 1);\r\n+    for (size_t i{0}; i <= num_tasks; ++i) {\r\n+        futures[i] = threadPool.Enqueue([i] { UninterruptibleSleep(milliseconds{i}); });\r\n+    }\r\n+\r\n+    WAIT_FOR(futures);\r\n+    const size_t elapsed_ms{size_t(duration_cast<milliseconds>(steady_clock::now() - start).count())};\r\n+    BOOST_CHECK(elapsed_ms >= num_tasks);\r\n }\r\n \r\n-// Test 4, obtain result object\r\n+// Obtain result object\r\n BOOST_AUTO_TEST_CASE(get_result_from_completed_task)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-    std::future<bool> future_bool = threadPool.Submit([]() { return true; });\r\n-    BOOST_CHECK(future_bool.get());\r\n-\r\n-    std::future<std::string> future_str = threadPool.Submit([]() { return std::string(\"true\"); });\r\n-    std::string result = future_str.get();\r\n-    BOOST_CHECK_EQUAL(result, \"true\");\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"result_test\"};\r\n+    threadPool.Start(num_workers);\r\n+\r\n+    BOOST_CHECK_EQUAL(threadPool.Enqueue([] { return true; }).get(), true);\r\n+    BOOST_CHECK_EQUAL(threadPool.Enqueue([] { return 42; }).get(), 42);\r\n+    BOOST_CHECK_EQUAL(threadPool.Enqueue([] { return std::string{\"true\"}; }).get(), \"true\");\r\n }\r\n \r\n-// Test 5, throw exception and catch it on the consumer side\r\n+// Throw exception and catch it on the consumer side\r\n BOOST_AUTO_TEST_CASE(task_exception_propagates_to_future)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-\r\n-    int num_tasks = 5;\r\n-    std::string err_msg{\"something wrong happened\"};\r\n-    std::vector<std::future<void>> futures;\r\n-    futures.reserve(num_tasks);\r\n-    for (int i = 0; i < num_tasks; i++) {\r\n-        futures.emplace_back(threadPool.Submit([err_msg, i]() {\r\n-            throw std::runtime_error(err_msg + util::ToString(i));\r\n-        }));\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"exception_test\"};\r\n+    threadPool.Start(num_workers);\r\n+\r\n+    const auto make_err{[](size_t n) { return strprintf(\"error on thread #%s\", n); }};\r\n+    const auto num_tasks{5 + m_rng.randrange<size_t>(15)};\r\n+\r\n+    std::vector<std::future<void>> futures(num_tasks);\r\n+    for (size_t i{0}; i < num_tasks; ++i) {\r\n+        futures[i] = threadPool.Enqueue([&make_err, i] { throw std::runtime_error(make_err(i)); });\r\n     }\r\n \r\n-    for (int i = 0; i < num_tasks; i++) {\r\n-        BOOST_CHECK_EXCEPTION(futures.at(i).get(), std::runtime_error, [&](const std::runtime_error& e) {\r\n-            BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\r\n-            return true;\r\n-        });\r\n+    for (size_t i{0}; i < num_tasks; ++i) {\r\n+        BOOST_CHECK_EXCEPTION(futures[i].get(), std::runtime_error, HasReason{make_err(i)});\r\n     }\r\n }\r\n \r\n-// Test 6, all workers are busy, help them by processing tasks from outside\r\n+// All workers are busy, help them by processing tasks from outside\r\n BOOST_AUTO_TEST_CASE(process_tasks_manually_when_workers_busy)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-\r\n-    std::promise<void> blocker;\r\n-    std::shared_future<void> blocker_future(blocker.get_future());\r\n-    const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT);\r\n-\r\n-    // Now submit tasks and check that none of them are executed.\r\n-    int num_tasks = 20;\r\n-    std::atomic<int> counter = 0;\r\n-    for (int i = 0; i < num_tasks; i++) {\r\n-        threadPool.Submit([&counter]() {\r\n-            counter.fetch_add(1, std::memory_order_relaxed);\r\n-        });\r\n-    }\r\n-    UninterruptibleSleep(std::chrono::milliseconds{100});\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"manual_process\"};\r\n+    threadPool.Start(num_workers);\r\n+\r\n+    std::counting_semaphore sem{0};\r\n+    const auto blocking_tasks{BlockWorkers(threadPool, sem, num_workers)};\r\n+\r\n+    const auto num_tasks{10 + m_rng.randrange<size_t>(30)};\r\n+    std::atomic_size_t counter{0};\r\n+\r\n+    std::vector<std::future<void>> futures(num_tasks);\r\n+    for (auto& f : futures) f = threadPool.Enqueue([&counter] { counter.fetch_add(1, std::memory_order_relaxed); });\r\n+\r\n+    UninterruptibleSleep(100ms);\r\n     BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), num_tasks);\r\n \r\n-    // Now process manually\r\n-    for (int i = 0; i < num_tasks; i++) {\r\n-        threadPool.ProcessTask();\r\n-    }\r\n-    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\r\n+    for (size_t i{0}; i < num_tasks; ++i) threadPool.ProcessTask();\r\n+\r\n+    BOOST_CHECK_EQUAL(counter.load(std::memory_order_relaxed), num_tasks);\r\n     BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n-    blocker.set_value();\r\n+\r\n+    WAIT_FOR(futures);\r\n+\r\n+    sem.release(num_workers);\r\n     threadPool.Stop();\r\n     WAIT_FOR(blocking_tasks);\r\n }\r\n \r\n-// Test 7, submit tasks from other tasks\r\n+// Submit tasks from other tasks\r\n BOOST_AUTO_TEST_CASE(recursive_task_submission)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"recursive\"};\r\n+    threadPool.Start(num_workers);\r\n \r\n     std::promise<void> signal;\r\n-    threadPool.Submit([&]() {\r\n-        threadPool.Submit([&]() {\r\n-            signal.set_value();\r\n-        });\r\n-    });\r\n+    (void)threadPool.Enqueue([&] { (void)threadPool.Enqueue([&] { signal.set_value(); }); });\r\n \r\n     signal.get_future().wait();\r\n     threadPool.Stop();\r\n }\r\n \r\n-// Test 8, submit task when all threads are busy and then stop the pool\r\n+// Submit task when all threads are busy and then stop the pool\r\n BOOST_AUTO_TEST_CASE(task_submitted_while_busy_completes)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n-\r\n-    std::promise<void> blocker;\r\n-    std::shared_future<void> blocker_future(blocker.get_future());\r\n-    const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT);\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"graceful_stop\"};\r\n+    threadPool.Start(num_workers);\r\n \r\n-    // Submit an extra task that should execute once a worker is free\r\n-    std::future<bool> future = threadPool.Submit([]() { return true; });\r\n+    std::counting_semaphore sem{0};\r\n+    const auto blocking_tasks{BlockWorkers(threadPool, sem, num_workers)};\r\n \r\n-    // At this point, all workers are blocked, and the extra task is queued\r\n+    std::future<bool> future{threadPool.Enqueue([] { return true; })};\r\n     BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\r\n \r\n-    // Wait a short moment before unblocking the threads to mimic a concurrent shutdown\r\n-    std::thread thread_unblocker([&blocker]() {\r\n-        UninterruptibleSleep(std::chrono::milliseconds{300});\r\n-        blocker.set_value();\r\n-    });\r\n+    std::thread thread_unblocker{[&sem, num_workers] {\r\n+        UninterruptibleSleep(300ms);\r\n+        sem.release(num_workers);\r\n+    }};\r\n \r\n-    // Stop the pool while the workers are still blocked\r\n     threadPool.Stop();\r\n \r\n-    // Expect the submitted task to complete\r\n     BOOST_CHECK(future.get());\r\n     thread_unblocker.join();\r\n-\r\n-    // Obviously all the previously blocking tasks should be completed at this point too\r\n     WAIT_FOR(blocking_tasks);\r\n-\r\n-    // Pool should be stopped and no workers remaining\r\n     BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\r\n }\r\n \r\n-// Test 9, more workers than available cores (congestion test)\r\n+// More workers than available cores (congestion test)\r\n BOOST_AUTO_TEST_CASE(congestion_more_workers_than_cores)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(std::max(1, GetNumCores() * 2)); // Oversubscribe by 2×\r\n-\r\n-    int num_tasks = 200;\r\n-    std::atomic<int> counter{0};\r\n-\r\n-    std::vector<std::future<void>> futures;\r\n-    futures.reserve(num_tasks);\r\n-    for (int i = 0; i < num_tasks; i++) {\r\n-        futures.emplace_back(threadPool.Submit([&counter] {\r\n-            counter.fetch_add(1, std::memory_order_relaxed);\r\n-        }));\r\n+    const auto oversubscribe_factor{2 + m_rng.randrange<int>(3)};\r\n+    ThreadPool threadPool{\"congestion\"};\r\n+    threadPool.Start(std::max(1, GetNumCores() * oversubscribe_factor));\r\n+\r\n+    const auto num_tasks{100 + m_rng.randrange<size_t>(200)};\r\n+    std::atomic_size_t counter{0};\r\n+\r\n+    std::vector<std::future<void>> futures(num_tasks);\r\n+    for (auto& f : futures) {\r\n+        f = threadPool.Enqueue([&counter] { counter.fetch_add(1, std::memory_order_relaxed); });\r\n     }\r\n \r\n     WAIT_FOR(futures);\r\n-    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\r\n+    BOOST_CHECK_EQUAL(counter.load(std::memory_order_relaxed), num_tasks);\r\n }\r\n \r\n-// Test 10, Interrupt() prevents further submissions\r\n+// Interrupt() prevents further submissions\r\n BOOST_AUTO_TEST_CASE(interrupt_blocks_new_submissions)\r\n {\r\n-    ThreadPool threadPool(POOL_NAME);\r\n-    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n+    const auto num_workers{3 + m_rng.randrange<size_t>(5)};\r\n+    ThreadPool threadPool{\"interrupt\"};\r\n+    threadPool.Start(num_workers);\r\n     threadPool.Interrupt();\r\n-    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{}), std::runtime_error, [&](const std::runtime_error& e) {\r\n-        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\r\n-        return true;\r\n-    });\r\n+    BOOST_CHECK_EXCEPTION((void)threadPool.Enqueue([] {}), std::runtime_error, HasReason{\"No active workers\"});\r\n }\r\n \r\n BOOST_AUTO_TEST_SUITE_END()\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\nindex b489e34c2f..f224c81b55 100644\r\n--- a/src/util/threadpool.h\r\n+++ b/src/util/threadpool.h\r\n@@ -8,19 +8,13 @@\r\n #include <sync.h>\r\n #include <tinyformat.h>\r\n #include <util/check.h>\r\n-#include <util/string.h>\r\n #include <util/thread.h>\r\n-#include <util/threadinterrupt.h>\r\n \r\n-#include <algorithm>\r\n-#include <atomic>\r\n-#include <condition_variable>\r\n-#include <cstddef>\r\n-#include <functional>\r\n+#include <deque>\r\n #include <future>\r\n-#include <memory>\r\n-#include <queue>\r\n+#include <semaphore>\r\n #include <stdexcept>\r\n+#include <string>\r\n #include <thread>\r\n #include <utility>\r\n #include <vector>\r\n@@ -46,53 +40,26 @@\r\n  */\r\n class ThreadPool\r\n {\r\n-private:\r\n     std::string m_name;\r\n     Mutex m_mutex;\r\n-    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\r\n-    std::condition_variable m_cv;\r\n-    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\r\n-    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\r\n-    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\r\n+    std::deque<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\r\n     bool m_interrupt GUARDED_BY(m_mutex){false};\r\n     std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\r\n \r\n+    std::counting_semaphore<> m_sem{0};\r\n+\r\n     void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n-        WAIT_LOCK(m_mutex, wait_lock);\r\n         for (;;) {\r\n-            std::packaged_task<void()> task;\r\n-            {\r\n-                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\r\n-                if (!m_interrupt && m_work_queue.empty()) {\r\n-                    // Block until the pool is interrupted or a task is available.\r\n-                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\r\n-                }\r\n-\r\n-                // If stopped and no work left, exit worker\r\n-                if (m_interrupt && m_work_queue.empty()) {\r\n-                    return;\r\n-                }\r\n-\r\n-                task = std::move(m_work_queue.front());\r\n-                m_work_queue.pop();\r\n-            }\r\n-\r\n-            {\r\n-                // Execute the task without the lock\r\n-                REVERSE_LOCK(wait_lock, m_mutex);\r\n-                task();\r\n-            }\r\n+            m_sem.acquire();\r\n+            if (!ProcessTask()) return;\r\n         }\r\n     }\r\n \r\n public:\r\n     explicit ThreadPool(const std::string& name) : m_name(name) {}\r\n \r\n-    ~ThreadPool()\r\n-    {\r\n-        Stop(); // In case it hasn't been stopped.\r\n-    }\r\n+    ~ThreadPool() { Stop(); }\r\n \r\n     /**\r\n      * @brief Start worker threads.\r\n@@ -109,7 +76,6 @@ public:\r\n         if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\r\n         m_interrupt = false; // Reset\r\n \r\n-        // Create workers\r\n         m_workers.reserve(num_workers);\r\n         for (int i = 0; i < num_workers; i++) {\r\n             m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\r\n@@ -130,14 +96,15 @@ public:\r\n         std::vector<std::thread> threads_to_join;\r\n         {\r\n             LOCK(m_mutex);\r\n-            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\r\n-            auto id = std::this_thread::get_id();\r\n+            // Ensure `Stop()` isn't called from any worker thread to avoid deadlocks\r\n+            const auto id{std::this_thread::get_id()};\r\n             for (const auto& worker : m_workers) assert(worker.get_id() != id);\r\n-            // Early shutdown to return right away on any concurrent 'Submit()' call\r\n+            // Early shutdown to return right away on any concurrent `Submit()` call\r\n             m_interrupt = true;\r\n             threads_to_join.swap(m_workers);\r\n         }\r\n-        m_cv.notify_all();\r\n+        m_sem.release(threads_to_join.size());\r\n+\r\n         for (auto& worker : threads_to_join) worker.join();\r\n         // Since we currently wait for tasks completion, sanity-check empty queue\r\n         WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\r\n@@ -147,13 +114,13 @@ public:\r\n     /**\r\n      * @brief Enqueues a new task for asynchronous execution.\r\n      *\r\n-     * Returns a `std::future` that provides the task’s result or propagates\r\n+     * Returns a `std::future` that provides the task's result or propagates\r\n      * any exception it throws.\r\n      * Note: Ignoring the returned future requires guarding the task against\r\n      * uncaught exceptions, as they would otherwise be silently discarded.\r\n      */\r\n-    template <class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n-    auto Submit(F&& fn)\r\n+    template <class F>\r\n+    [[nodiscard]] EXCLUSIVE_LOCKS_REQUIRED(!m_mutex) auto Enqueue(F&& fn)\r\n     {\r\n         std::packaged_task task{std::forward<F>(fn)};\r\n         auto future{task.get_future()};\r\n@@ -162,34 +129,34 @@ public:\r\n             if (m_interrupt || m_workers.empty()) {\r\n                 throw std::runtime_error(\"No active workers; cannot accept new tasks\");\r\n             }\r\n-            m_work_queue.emplace(std::move(task));\r\n+            m_work_queue.emplace_back(std::move(task));\r\n         }\r\n-        m_cv.notify_one();\r\n+        m_sem.release();\r\n         return future;\r\n     }\r\n \r\n     /**\r\n      * @brief Execute a single queued task synchronously.\r\n      * Removes one task from the queue and executes it on the calling thread.\r\n+     * @return true if a task was executed, false if queue was empty\r\n      */\r\n-    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n+    bool ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         std::packaged_task<void()> task;\r\n         {\r\n             LOCK(m_mutex);\r\n-            if (m_work_queue.empty()) return;\r\n-\r\n-            // Pop the task\r\n+            if (m_work_queue.empty()) return false;\r\n             task = std::move(m_work_queue.front());\r\n-            m_work_queue.pop();\r\n+            m_work_queue.pop_front();\r\n         }\r\n         task();\r\n+        return true;\r\n     }\r\n \r\n     void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         WITH_LOCK(m_mutex, m_interrupt = true);\r\n-        m_cv.notify_all();\r\n+        m_sem.release(WorkersCount());\r\n     }\r\n \r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n\r\n```\r\n\r\n</details>",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3482342931",
      "submitted_at": "2025-11-19T18:03:20Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "labeled",
      "id": 21308148780,
      "node_id": "LE_lADOABII587TTDKpzwAAAAT2EIws",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21308148780",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-02T14:50:42Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3608532244,
      "node_id": "IC_kwDOABII587XFdUU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3608532244",
      "actor": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-03T19:39:56Z",
      "updated_at": "2025-12-03T19:39:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I don’t think this is an issue. You’re just massively oversubscribing the CPU and lowering the timeout to the point where all the context switching triggers it. Switching to notify_all() only forces all workers awake on every submission, which masks the OS scheduler starvation you get in this kind of extreme setup.\r\n\r\nI've been playing with the fuzz test and found that this fixes it for me:\r\n\r\n```c++\r\nThreadPool g_pool{\"fuzz\"};\r\nsize_t g_num_workers = 3;\r\nstd::atomic<bool> g_pool_started{false};\r\n\r\nstatic void setup_threadpool_test()\r\n{\r\n    LogInstance().DisableLogging();\r\n\r\n}\r\n\r\nFUZZ_TARGET(threadpool, .init = setup_threadpool_test)\r\n{\r\n    if (!g_pool_started.exchange(true)) {\r\n        g_pool.Start(g_num_workers);\r\n    }\r\n    \r\n    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\r\n ```\r\n \r\n Oversubscribed by a lot and left it running for a long time with `-timeout=10` and it's good to go, no timeouts. This is with `notify_one` as well.\r\n \r\nThere's two changes here. The first is to start the thread pool inside of the first iteration. This fixes a problem I was having with the [LibAFL](https://github.com/AFLplusplus/LibAFL/tree/main/crates/libafl_libfuzzer) version of libfuzzer. It would hang immediately because LibAFL calls `fork()` after calling the init function, and so the child processes would end up only having one thread active (the main calling thread) and no workers.\r\n\r\nThe second change is just switching from `call_once` to a global that we check every iteration. This fixes the original non-reproducible timeout issue I had with libFuzzer. I don't really know why, but I'm guessing `call_once` is more complicated than the simpler check.\r\n \r\nOverall, I've learned that multi core fuzzing and multiple threads in a fuzz test don't mix well it seems. It leads to issues that are hard to reproduce and debug. For the purposes of testing the threadpool under heavy load, I think it's fine to use work arounds like this to get it done.",
      "user": {
        "login": "marcofleon",
        "id": 95179662,
        "node_id": "U_kgDOBaxTjg",
        "avatar_url": "https://avatars.githubusercontent.com/u/95179662?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/marcofleon",
        "html_url": "https://github.com/marcofleon",
        "followers_url": "https://api.github.com/users/marcofleon/followers",
        "following_url": "https://api.github.com/users/marcofleon/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/marcofleon/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/marcofleon/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/marcofleon/subscriptions",
        "organizations_url": "https://api.github.com/users/marcofleon/orgs",
        "repos_url": "https://api.github.com/users/marcofleon/repos",
        "events_url": "https://api.github.com/users/marcofleon/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/marcofleon/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3608532244",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3631535266,
      "node_id": "IC_kwDOABII587YdNSi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3631535266",
      "actor": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T10:41:05Z",
      "updated_at": "2025-12-09T10:41:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "@furszy, are you still working on this?",
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3631535266",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "mentioned",
      "id": 21450004169,
      "node_id": "MEE_lADOABII587TTDKpzwAAAAT-hRbJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21450004169",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T10:41:06Z"
    },
    {
      "event": "subscribed",
      "id": 21450004203,
      "node_id": "SE_lADOABII587TTDKpzwAAAAT-hRbr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21450004203",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T10:41:06Z"
    },
    {
      "event": "commented",
      "id": 3632659243,
      "node_id": "IC_kwDOABII587Yhfsr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3632659243",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T14:48:26Z",
      "updated_at": "2025-12-09T14:48:26Z",
      "author_association": "MEMBER",
      "body": "> @furszy, are you still working on this?\r\n\r\nyes.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3632659243",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "mentioned",
      "id": 21455763285,
      "node_id": "MEE_lADOABII587TTDKpzwAAAAT-3PdV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21455763285",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T14:48:28Z"
    },
    {
      "event": "subscribed",
      "id": 21455763323,
      "node_id": "SE_lADOABII587TTDKpzwAAAAT-3Pd7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21455763323",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-09T14:48:28Z"
    },
    {
      "event": "reviewed",
      "id": 3593444540,
      "node_id": "PRR_kwDOABII587WL5y8",
      "url": null,
      "actor": null,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-12-18T15:35:00Z",
      "author_association": "MEMBER",
      "body": "Code review ACK 2de0ce5cd85e1b99e318883964df318ffb615fe4 👾 \n\n",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3593444540",
      "submitted_at": "2025-12-18T15:35:00Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "review_requested",
      "id": 21646852082,
      "node_id": "RRE_lADOABII587TTDKpzwAAAAUKQL_y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21646852082",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:35:06Z",
      "requested_reviewer": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 21646852410,
      "node_id": "RRE_lADOABII587TTDKpzwAAAAUKQME6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21646852410",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:35:07Z",
      "requested_reviewer": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 21646852734,
      "node_id": "RRE_lADOABII587TTDKpzwAAAAUKQMJ-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21646852734",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:35:08Z",
      "requested_reviewer": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 3670973117,
      "node_id": "IC_kwDOABII587azpq9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3670973117",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-18T15:58:22Z",
      "updated_at": "2025-12-18T15:58:22Z",
      "author_association": "MEMBER",
      "body": "The rebase is trivial it seems https://github.com/bitcoin/bitcoin/compare/master...ismaelsadeeq:bitcoin:12-2025-threadpool ",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3670973117",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 21770935988,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAAURph60",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21770935988",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "created_at": "2025-12-28T18:10:22Z"
    },
    {
      "event": "commented",
      "id": 3694933455,
      "node_id": "IC_kwDOABII587cPDXP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3694933455",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-28T18:12:52Z",
      "updated_at": "2025-12-28T18:12:52Z",
      "author_association": "MEMBER",
      "body": "thanks @ismaelsadeeq, rebased. Will tackle the remaining comments and update accordingly soon.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3694933455",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "mentioned",
      "id": 21770945300,
      "node_id": "MEE_lADOABII587TTDKpzwAAAAURpkMU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21770945300",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-28T18:12:53Z"
    },
    {
      "event": "subscribed",
      "id": 21770945306,
      "node_id": "SE_lADOABII587TTDKpzwAAAAURpkMa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21770945306",
      "actor": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-28T18:12:53Z"
    },
    {
      "event": "unlabeled",
      "id": 21771128785,
      "node_id": "UNLE_lADOABII587TTDKpzwAAAAURqQ_R",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/21771128785",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-12-28T19:06:09Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 22189396098,
      "node_id": "LE_lADOABII587TTDKpzwAAAAUql1CC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22189396098",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-21T14:16:07Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3808540044,
      "node_id": "IC_kwDOABII587jAbWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3808540044",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-28T02:05:14Z",
      "updated_at": "2026-01-28T02:05:14Z",
      "author_association": "MEMBER",
      "body": "working on the update now, almost there.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3808540044",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ1OTMwYTc5NDEyZGM0NWY5ZDM5MWNkNzY4OWQwMjlmYTRmMDE4OWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45930a79412dc45f9d391cd7689d029fa4f0189e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/45930a79412dc45f9d391cd7689d029fa4f0189e",
      "tree": {
        "sha": "7f4c30bdc6056f61c6a83821eb3c860cd84f24ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7f4c30bdc6056f61c6a83821eb3c860cd84f24ae"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 7f4c30bdc6056f61c6a83821eb3c860cd84f24ae\nparent c0e6556e4f51b454c3f6e9069044761c34e99f81\nauthor furszy <matiasfurszyfer@protonmail.com> 1769622002 -0500\ncommitter furszy <matiasfurszyfer@protonmail.com> 1769645012 -0500\n\nhttp-server: guard against crashes from unhandled exceptions\n\nCurrently, if an exception is thrown at the top-level HTTP request\nhandler (prior to invoking the command), the program crashes.\n\nIdeally, each handler should catch all exceptions internally and\nbe responsible for sanitizing them and crafting the client response.\nThis is because only the handler knows the correct response format,\nwhich differs per server type. However, because this cannot always\nbe guaranteed, it is safer to also catch exceptions in the top-level\nserver code, log the unexpected error, and disconnect the socket.\n\nThis both guards against crashes caused by uncaught exceptions and\nprevents the client from hanging indefinitely while waiting for a\nresponse that will never arrive.\n\nThe following diff can be used to trigger the crash in master\n(just run single node functional tests like feature_shutdown.py):\n```\ndiff --git a/src/httprpc.cpp b/src/httprpc.cpp\n--- a/src/httprpc.cpp\n+++ b/src/httprpc.cpp\n@@ -103,6 +103,9 @@\n\n static bool HTTPReq_JSONRPC(const std::any& context, HTTPRequest* req)\n {\n+    static int i = 0; // skip initial requests as they are used in the RPC warmup phase.\n+    if (i++ > 3) throw std::runtime_error(\"error from json rpc handler\");\n+\n     // JSONRPC handles only POST\n     if (req->GetRequestMethod() != HTTPRequest::POST) {\n         req->WriteReply(HTTP_BAD_METHOD, \"JSONRPC server handles only POST requests\");\n\n```\n\nNote:\nThis leaves a TODO in the code because error responses should eventually\nbe specialized per server type. REST clients expect plain text responses,\nwhile JSON-RPC clients expect a JSON error object.\nThe TODO is there because this is not consistently enforced everywhere\nin the current codebase, and we should tackle them all at once.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAml6o9QACgkQXdI8zGhq\npiNYHw//W/tzDTym0VdCuM8+ShpT5uXx7R9Fnf4+HWVeA4wNvw8u12YeeLspdczs\nyqE+o/dgWDI5xO0L+J3bpOjFwQDmNebnJt3IJ13GlG1UFXGExZhIIAYZIHLnIUNy\n55B1C3bV4QnlRDpNkg5K1MHUCUC3COmYhNWifl3QyL7DYTOD5/YDrf/ELidNWOEB\nC4hLcj7y5/9dkdBFotiHtA63tXlxC581h7GRCEKSNMS4UQOm7/9EOsjDa8blPyTV\naVNrXGbNlUCiNaRkS5L4Qd2Tk3m65o2wFgkNVOTc8GHVaZZ7LiPgb88Mg7xMSssE\nDLN+tVSAKIhSksboGArbGmlM/ZnDLVyHjWaTiXdpqQZ3Cm9EbF2nthBUiMxT9tAG\nnCEGyTu/0B3G3G24/wOahPYksJb09KmocVKxSgdTgmeLyrG9fhdS4+3nNwCwxHLl\nq/r5oD4/Q+eGyQKGYEE3nXLca54gJeTNzQ3PFSaaxTIK8RKz68LeS6jSxC0jSH4o\nxnauqIsyeInpUjGG/xBCySpEnU33GATPpfZDP3q3DAyUK5+rq0jKyLZiYnnPrqcg\ngfmwTEKVQhKBzET7XhOMxuTa/gzVfzjkqEUWjRWIGZftjqP7zFBHToctNteDsoBU\ngrmmYHE5W25mxq2BjqhD3ZOmu4W32EeQrVNZzdDYPcTE56IGKM4=\n=OvMg\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c0e6556e4f51b454c3f6e9069044761c34e99f81",
          "sha": "c0e6556e4f51b454c3f6e9069044761c34e99f81",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c0e6556e4f51b454c3f6e9069044761c34e99f81"
        }
      ],
      "message": "http-server: guard against crashes from unhandled exceptions\n\nCurrently, if an exception is thrown at the top-level HTTP request\nhandler (prior to invoking the command), the program crashes.\n\nIdeally, each handler should catch all exceptions internally and\nbe responsible for sanitizing them and crafting the client response.\nThis is because only the handler knows the correct response format,\nwhich differs per server type. However, because this cannot always\nbe guaranteed, it is safer to also catch exceptions in the top-level\nserver code, log the unexpected error, and disconnect the socket.\n\nThis both guards against crashes caused by uncaught exceptions and\nprevents the client from hanging indefinitely while waiting for a\nresponse that will never arrive.\n\nThe following diff can be used to trigger the crash in master\n(just run single node functional tests like feature_shutdown.py):\n```\ndiff --git a/src/httprpc.cpp b/src/httprpc.cpp\n--- a/src/httprpc.cpp\n+++ b/src/httprpc.cpp\n@@ -103,6 +103,9 @@\n\n static bool HTTPReq_JSONRPC(const std::any& context, HTTPRequest* req)\n {\n+    static int i = 0; // skip initial requests as they are used in the RPC warmup phase.\n+    if (i++ > 3) throw std::runtime_error(\"error from json rpc handler\");\n+\n     // JSONRPC handles only POST\n     if (req->GetRequestMethod() != HTTPRequest::POST) {\n         req->WriteReply(HTTP_BAD_METHOD, \"JSONRPC server handles only POST requests\");\n\n```\n\nNote:\nThis leaves a TODO in the code because error responses should eventually\nbe specialized per server type. REST clients expect plain text responses,\nwhile JSON-RPC clients expect a JSON error object.\nThe TODO is there because this is not consistently enforced everywhere\nin the current codebase, and we should tackle them all at once.",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-29T00:03:32Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-28T17:40:02Z"
      },
      "sha": "45930a79412dc45f9d391cd7689d029fa4f0189e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDYzNTRiNGZkN2ZlODE5ZWIxMzI3NGIyMTJlNDI2YTdkMTBjYTc1ZDM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6354b4fd7fe819eb13274b212e426a7d10ca75d3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6354b4fd7fe819eb13274b212e426a7d10ca75d3",
      "tree": {
        "sha": "fa2d6ef41f0440736c955031bf0d68e25a75d75d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fa2d6ef41f0440736c955031bf0d68e25a75d75d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree fa2d6ef41f0440736c955031bf0d68e25a75d75d\nparent 45930a79412dc45f9d391cd7689d029fa4f0189e\nauthor furszy <matiasfurszyfer@protonmail.com> 1769565573 -0500\ncommitter furszy <matiasfurszyfer@protonmail.com> 1769645013 -0500\n\ntests: log node JSON-RPC errors during test setup\n\nCurrently, if the node replies to any command with an error during\nthe test framework's setup(), we log the generic and not really useful\n\"Unexpected exception\" from the BaseException catch, with no further\ninformation.\nThis isn't helpful for diagnosing the issue. Fix it by explicitly handling\nJSONRPCException and logging the response error message and http status\ncode.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAml6o9UACgkQXdI8zGhq\npiNGyhAAq6ZZFXLNwGKb3FJZrhDWapxqgS5eLfuFcRppldFLja1+dXEfUHsjFYoM\n8VlFJ+T1CyLeYEY7HvZRjg5wV7SoPpl3Eb/e/tIFY1YKZLhEBRWJfHQGkmj4ks+d\nQG4TKer2aRnep0w/80uvt3NMUJ5ySbGuUBrsBktzaDEoX2up6o8D07y8w1dwJgfZ\ntWxa4xT8U4IhfSGDrDg12lilfBYUZQ0KK1/slWkWVwXf+sxGKNabvpqkVRqHSgvx\n3Q5W6E+5ZCIooeucMxJOx9NQqeWMStHITBjlhNrae4dQYnLO1a3jKmQckdsR33L+\n7kanBu0vbiOtqdwvyqnUY1M8EMCscb8ThnpZH6Z1Fxw4Vy32ujn8wE+d5XtoBzzZ\nJzBeT8MCEu1perRl3OqidJfps7STR3/7XEqjWZhOoZrmoU1QTDRKM+bQeKC5DjFm\nUg3UQuoX/FqaKMm+Z0+6Qig7kETgiT+dHwOEbl7ummg4iBs+w4rlj2UYVzFg+usP\nKSodUWFhkiTTSti2hLIew7G2LORM0gOac7Xf07ugNXj8lottM+hT039DpjPzs/Fc\nozKonhyGNzJv28dAzHarqdoXgIC90iy0lEjmeXykn2PRwAP7ZP7XnjSDjB8hFzCK\n3W0ceuGoVQpcDvGIhXyrEPcx7ai9yYHowEWwodM0jYAv6CKcOJA=\n=B6KM\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/45930a79412dc45f9d391cd7689d029fa4f0189e",
          "sha": "45930a79412dc45f9d391cd7689d029fa4f0189e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/45930a79412dc45f9d391cd7689d029fa4f0189e"
        }
      ],
      "message": "tests: log node JSON-RPC errors during test setup\n\nCurrently, if the node replies to any command with an error during\nthe test framework's setup(), we log the generic and not really useful\n\"Unexpected exception\" from the BaseException catch, with no further\ninformation.\nThis isn't helpful for diagnosing the issue. Fix it by explicitly handling\nJSONRPCException and logging the response error message and http status\ncode.",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-29T00:03:33Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-28T01:59:33Z"
      },
      "sha": "6354b4fd7fe819eb13274b212e426a7d10ca75d3"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22361273976,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAAU01fZ4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22361273976",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "57d9bbcad66dfe932edc80cfc177354e59dab22c",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/57d9bbcad66dfe932edc80cfc177354e59dab22c",
      "created_at": "2026-01-29T00:05:01Z"
    },
    {
      "event": "commented",
      "id": 3814670791,
      "node_id": "IC_kwDOABII587jX0HH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3814670791",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-29T00:34:53Z",
      "updated_at": "2026-01-29T00:34:53Z",
      "author_association": "MEMBER",
      "body": "Updated per feedback. Thanks everyone!\r\n\r\nUnit tests updated with most of l0rinc's feedback. And updated the fuzz test to accommodate to\r\nhttps://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3608532244 which seems very deep. Thanks marcofleon for the thorough investigation!\r\n\r\nAlso, just to highlight the main change of the last push:\r\n\r\nOn **master**, I was able to crash the server by throwing an exception from the top-level handler,\r\nbut in this branch, the same scenario no longer causes a crash, which is great.\r\nYet, to make the fix and the scenario explicit, I separated it into its own standalone commit.\r\nThe diff to reproduce it on master is also in the commit description.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3814670791",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "unlabeled",
      "id": 22363365044,
      "node_id": "UNLE_lADOABII587TTDKpzwAAAAU09d60",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22363365044",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-29T02:09:49Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 3729838460,
      "node_id": "PRR_kwDOABII587eUNF8",
      "url": null,
      "actor": null,
      "commit_id": "57d9bbcad66dfe932edc80cfc177354e59dab22c",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-02T12:51:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "ACK https://github.com/bitcoin/bitcoin/commit/57d9bbcad66dfe932edc80cfc177354e59dab22c\r\n\r\nLeft some minor comments.",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3729838460",
      "submitted_at": "2026-01-30T20:15:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22417839619,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAAU4NRYD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22417839619",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "ad8fb89ac7464c39e3c715e1c0390bbdb680a848",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/ad8fb89ac7464c39e3c715e1c0390bbdb680a848",
      "created_at": "2026-01-30T21:16:09Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGM1MjhkZDVmOGNjYzM5NTViMDBiZGJhODY5ZjBhNzc0ZWZhOTdmZTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "tree": {
        "sha": "bd0d3f4d96e35d7ba0872268a3cc69a77ca327a7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd0d3f4d96e35d7ba0872268a3cc69a77ca327a7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree bd0d3f4d96e35d7ba0872268a3cc69a77ca327a7\nparent 6354b4fd7fe819eb13274b212e426a7d10ca75d3\nauthor furszy <matiasfurszyfer@protonmail.com> 1676560833 -0300\ncommitter furszy <matiasfurszyfer@protonmail.com> 1769807832 -0500\n\nutil: introduce general purpose thread pool\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAml9H9gACgkQXdI8zGhq\npiPP3A/8C4Xf8g5eXkcHuVkCHJFoztCffRFqxR4iV1xC5RAZySigebAlZg8Pk1Fw\n/54ChoP8YQYLufaLJhYAAQ1ZLNQM+3jbLx6wFkJt4rZmkyKtTqPNlZZIrZvbeFdp\nZGBMtv4fNwdrLbs++86vfT1Ur2+zV9tZyurvdqoQUHr4KJ6bYo3ub1Be2+Os6hhq\nCJPvDvxT75oR5//Cd/weDuskxYL/pJapOsY2aZZnz/XifZc8ukdSNeyk9DLSTLgE\nExSjxAPliYC78o2HtCS+PUaAqu4TYSySxaLhE4DCzyUjw3DecrZKXX5f86oPo0Ny\n9IRw7041LKygwe1Za9rkRotxuE368YaglVjeR7zWUrl3U4vkBE07uSwUbM9M1jCb\nrbBABDiEwpW/tOI3mjSJ4qP3ra/fGNbkc/+097Si/gSLI2sumhl0rWOTuWcLfdRJ\nc6gnnZdEY+w3w8BIwgqrmZXIar5nA+ugaYv8JXfZxsWTSsA5s90PHxsBRA4RY6zU\nTcJDoaLf2x3McvIjVHoTYIRhkMpooR54JBOBCE0HxB9BJ2fStqd4sE8xTzdmBjaw\ntlC3QhN+w1u4YFQFjCzTbhISegEA/U6u8CjyyiogLkniYUZ1Xx/VZkEzD9JWgpRM\no03+HxmoTWEpLwFFdQNhNW0hiZkehiM8hbPgsWcPaUee/5r7ceo=\n=pPe2\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6354b4fd7fe819eb13274b212e426a7d10ca75d3",
          "sha": "6354b4fd7fe819eb13274b212e426a7d10ca75d3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6354b4fd7fe819eb13274b212e426a7d10ca75d3"
        }
      ],
      "message": "util: introduce general purpose thread pool",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-30T21:17:12Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2023-02-16T15:20:33Z"
      },
      "sha": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGMzMjNmODgyZWQzODQxNDAxZWRlZTkwYWI1MjYxZDY4MjE1YWIzMTY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c323f882ed3841401edee90ab5261d68215ab316",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/c323f882ed3841401edee90ab5261d68215ab316",
      "tree": {
        "sha": "8e4cff6551edc692182f3e1ab542ff2db858cc03",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8e4cff6551edc692182f3e1ab542ff2db858cc03"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 8e4cff6551edc692182f3e1ab542ff2db858cc03\nparent c528dd5f8ccc3955b00bdba869f0a774efa97fe1\nauthor TheCharlatan <seb.kung@gmail.com> 1758561710 -0400\ncommitter furszy <matiasfurszyfer@protonmail.com> 1769807832 -0500\n\nfuzz: add test case for threadpool\n\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAml9H9gACgkQXdI8zGhq\npiMjfRAAtA2QqjhRwFjNJm/sv1nyHIyz1mm2q7C0oJR4zKVMpYjEtW9asYY4Um7z\nyU3KvdN5/SQF8XTcbIhzBUEaPCy/+UxeHS1NqS/SfrtXMVz8Lk8wndqMnCJWYahk\nqTJbRI0HDjlg7iz47Woul5CI6EYJ7tR7lKd6ZP81wlgiImQu80duGwd+Opyaxd+i\nbYpZyqdSoq450V6U3jt/LLD4tz4hf7H4snggbuTG0thryqQsySMPYCT4uGvHy4/Z\nU23vMD0n775piOP/nQ1Dcwqm29CK2mrFlbSos6+LbxGTRLv9pj73SOA0o6Iddg2Z\nkK8gsmvMACeKiIvV/B3GNDqkA7ulZr7UUgve6fyOypNj9PfN6FHhqcvA/FuGvyda\nMNxkwMb+aItaXEBnlZl4a9EtV8t9k0rBa15WYv3fr5WtX8x203sy8AyKoIazFIMP\nuMDKxRtBzbCUtnm3ErgdTQYEGUBSGPVThfp4MNpnQFgJ7vlnknGTMjE6EFbxWeI8\n2J9LFsM+3byA0V0YJZF2KcnUgkxhkq/BbjZKFxWRdwZhNg5LDKYBpA1YVM37Zo9I\nQ5qpvUPSu6p/Is5rvSOrWRStKuMGuRjCmMpmx4639mrhjDqFJyr3ibgIklqwY9tP\n0FLanpTke6DZpsB881piIiOtFh1l0HKFxcNGToP7/n/XSXOD9wQ=\n=0l+1\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
          "sha": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c528dd5f8ccc3955b00bdba869f0a774efa97fe1"
        }
      ],
      "message": "fuzz: add test case for threadpool\n\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-30T21:17:12Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-22T17:21:50Z"
      },
      "sha": "c323f882ed3841401edee90ab5261d68215ab316"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDM4ZmQ4NWM2NzZhMDcyZWJmMjU2ZTgwNmJlZGE5ZDc1MzM3OTBiYWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38fd85c676a072ebf256e806beda9d7533790baa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/38fd85c676a072ebf256e806beda9d7533790baa",
      "tree": {
        "sha": "86db76000a78a51217368712a14dbc4e605bfb34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/86db76000a78a51217368712a14dbc4e605bfb34"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 86db76000a78a51217368712a14dbc4e605bfb34\nparent c323f882ed3841401edee90ab5261d68215ab316\nauthor furszy <matiasfurszyfer@protonmail.com> 1769630881 -0500\ncommitter furszy <matiasfurszyfer@protonmail.com> 1769807832 -0500\n\nhttp: replace WorkQueue and threads handling for ThreadPool\n\nReplace the HTTP server's WorkQueue implementation and single threads\nhandling code with ThreadPool for processing HTTP requests. The\nThreadPool class encapsulates all this functionality on a reusable\nclass, properly unit and fuzz tested (the previous code was not\nunit nor fuzz tested at all).\n\nThis cleanly separates responsibilities:\nThe HTTP server now focuses solely on receiving and dispatching requests,\nwhile ThreadPool handles concurrency, queuing, and execution.\nIt simplifies init, shutdown and requests tracking.\n\nThis also allows us to experiment with further performance improvements at\nthe task queuing and execution level, such as a lock-free structure, task\nprioritization or any other performance improvement in the future, without\nhaving to deal with HTTP code that lives on a different layer.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAml9H9gACgkQXdI8zGhq\npiPgQw/6A9xXXMyctM5K1TQsY2M3SC6WVrshdekCNj9LdySz+gE6K49ygA232tKi\nedgfnbWHAHiHkAkyEGMPpnYJoWKStF68VxlvhG26Io6JVxsSRZTAQhdXFavLrJBB\nOAPR8VTvad2EIq4CNTxaabjkFpcUiZrDf7cEdb0VthQC923fsPi6LiTOGHMA0b6U\nGXfDt2JsmfLME6ktlufkB1mDuTL9HTMBzMU4oPnq1NonjIJjdO1P+LhCpS6rKNju\nUyimSmoF6LShwJVdT5dS+JBMqEeQlFwZy+LW8qHlCa3iybxXqaiWfTKy0AVQShSy\nvZ56k076uZcaJo803yIszHHvH/aleGkx4fGuY0RNtdMW6XoD7NM7AcD+Wg5xz4YM\nfxk92156iZO/7DRe9N1s501W9nRKf7do3M/z4R1ic5tfHFOwzhsjxic+1MXzYI5S\n86qB+56nPuZrfhFlRb+LcpcRTOD5G70sormjlrUaBC60aiIR8qN1aTV05oB9f/TC\nU+Y8NpLiD3hEtU9ExqqIXk581HPGBt+uUFrzJncJPMio/zcWSye65gk0zJmUZypG\nvp4VuzCugq8Pd3hUMFA4SnZakYMOMMFvf50QBeuncH4SyALDrg9KSjndLfW5VjWe\nVhzBs1aGpanhmljDtmiMWXsbcI5J4o6TzJTPowdW1BrKXQHgg8k=\n=CnxC\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c323f882ed3841401edee90ab5261d68215ab316",
          "sha": "c323f882ed3841401edee90ab5261d68215ab316",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/c323f882ed3841401edee90ab5261d68215ab316"
        }
      ],
      "message": "http: replace WorkQueue and threads handling for ThreadPool\n\nReplace the HTTP server's WorkQueue implementation and single threads\nhandling code with ThreadPool for processing HTTP requests. The\nThreadPool class encapsulates all this functionality on a reusable\nclass, properly unit and fuzz tested (the previous code was not\nunit nor fuzz tested at all).\n\nThis cleanly separates responsibilities:\nThe HTTP server now focuses solely on receiving and dispatching requests,\nwhile ThreadPool handles concurrency, queuing, and execution.\nIt simplifies init, shutdown and requests tracking.\n\nThis also allows us to experiment with further performance improvements at\nthe task queuing and execution level, such as a lock-free structure, task\nprioritization or any other performance improvement in the future, without\nhaving to deal with HTTP code that lives on a different layer.",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-30T21:17:12Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2026-01-28T20:08:01Z"
      },
      "sha": "38fd85c676a072ebf256e806beda9d7533790baa"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 22417864337,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAAU4NXaR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22417864337",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/38fd85c676a072ebf256e806beda9d7533790baa",
      "created_at": "2026-01-30T21:17:28Z"
    },
    {
      "event": "commented",
      "id": 3825789348,
      "node_id": "IC_kwDOABII587kCOmk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3825789348",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T21:17:47Z",
      "updated_at": "2026-01-30T21:17:47Z",
      "author_association": "MEMBER",
      "body": "Updated per feedback. Thanks Eunovo.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3825789348",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "labeled",
      "id": 22417879251,
      "node_id": "LE_lADOABII587TTDKpzwAAAAU4NbDT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22417879251",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T21:18:19Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "unlabeled",
      "id": 22418877316,
      "node_id": "UNLE_lADOABII587TTDKpzwAAAAU4ROuE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22418877316",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-01-30T22:13:20Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 3835015865,
      "node_id": "IC_kwDOABII587klbK5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3835015865",
      "actor": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-02T13:06:56Z",
      "updated_at": "2026-02-02T13:06:56Z",
      "author_association": "CONTRIBUTOR",
      "body": "ReACK https://github.com/bitcoin/bitcoin/pull/33689/commits/38fd85c676a072ebf256e806beda9d7533790baa\r\n\r\nReviewed with git diff 57d9bbc 38fd85c",
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3835015865",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "review_requested",
      "id": 22465051669,
      "node_id": "RRE_lADOABII587TTDKpzwAAAAU7BXwV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22465051669",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-02T13:07:04Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      }
    },
    {
      "event": "reviewed",
      "id": 3769661717,
      "node_id": "PRR_kwDOABII587gsHkV",
      "url": null,
      "actor": null,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-08T11:41:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "Re-ACK 38fd85c676a072ebf256e806beda9d7533790baa",
      "user": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3769661717",
      "submitted_at": "2026-02-08T11:41:46Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "reviewed",
      "id": 3774273771,
      "node_id": "PRR_kwDOABII587g9tjr",
      "url": null,
      "actor": null,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2026-02-10T18:23:22Z",
      "author_association": "MEMBER",
      "body": "ACK 38fd85c676a072ebf256e806beda9d7533790baa\n\nRe-reviewed all commits since a lot has changed since last review. Built and tested on arm64/macos and x86/debian.\n\nTried breaking it with stuff like `-rpcthreads=9000` (expect init failure).\nAlso tried `-rpcthreads=1` with RPC-pummeling scripts.\n\nI roughly rebased #32061 on this branch and tested. Conflicts were extremely minimal.\n\nI'm excited to use this feature to parallelize other tasks in bitcoin!\n\nSeveral questions below, mostly just about style. No blockers there. RFM 🚀 \n\n```\n\n /home/zip/bitcoin/build/bin/bitcoind -regtest -rpcthreads=1000\n ├─ b-scheduler\n ├─ b-http_pool_0\n ├─ b-http_pool_1\n ├─ b-http_pool_2\n ├─ b-http_pool_3\n ├─ b-http_pool_4\n ├─ b-http_pool_5\n...\n```\n\n<details><summary>Show Signature</summary>\n\n```\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nACK 38fd85c676a072ebf256e806beda9d7533790baa\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmmLdj0ACgkQ5+KYS2KJ\nyTpkNQ//Z8464/u6+Zw6tfIBEtcNCWLi2m3pk2xnJE8q2HIzk2GT6NUzu5f6yRsV\nfkB1AJqxwO9aKf+tmF85c+f6PoKhjyBDeA1nFa39ms8Madkn32W3su6fPcfqjeCy\nROS3T18QueM7MkH4qezCWZ4TkYYeZu/yEMQdfZzhLJF14DX/8HdL+/fanqyB0CHc\nV8mckYkX9vszKmQz4HZqSSxL9RUvv/ipbLKSU7BgO+EOWHkLAHNr5V27UwySM/9s\nuDDDQGDCsnQqtkajRGE+gg230Xq70Fwp12+japQ5yvpn17HjkkDnCsvoLK01BHAO\nWHASMt6m+RSZGlIwv7WXd0vM2gqIAcrJwkS3VzoDlkVI0fLdcsyacPn2zKL0cOBg\nj7OjaW8KV+MjS1KvRuJR0CAE5akOPTgO9aCi5Aly+LZyyLPoDoQOZYTGDq4TJB3n\nREgN6LuvjBoctWQGYM3HTTMDTchQqd+WWTaF7aKoCM8VTsffN8d00c/Y4ADIQ4Fd\nxRv6jC0QBw434Nb023h15OHNYVgMNr/xqulfGizZUzXOcrcfEuBNYTyK7zBi4njm\ngjEmI2rEoIrCzrgRcwinAF0XpVMca9YyGao4bBtpYY5lmc+LeU7lz2ac1wk3kLGf\nSXfHL6jqetA1QWSVuEZ7ZuFJJSxRRqwjuNOl0YtoJ1kHTH8tiSc=\n=dFzb\n-----END PGP SIGNATURE-----\n```\n\npinheadmz's public key is [on openpgp.org](https://keys.openpgp.org/vks/v1/by-fingerprint/E61773CD6E01040E2F1BD78CE7E2984B6289C93A)\n</details>\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3774273771",
      "submitted_at": "2026-02-10T18:23:22Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "merged",
      "id": 22710252856,
      "node_id": "ME_lADOABII587TTDKpzwAAAAVJovU4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22710252856",
      "actor": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": "4a05825a3f3993b8e402a7c18e2bc04f6d287e96",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4a05825a3f3993b8e402a7c18e2bc04f6d287e96",
      "created_at": "2026-02-11T17:04:50Z"
    },
    {
      "event": "closed",
      "id": 22710252998,
      "node_id": "CE_lADOABII587TTDKpzwAAAAVJovXG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22710252998",
      "actor": {
        "login": "sedited",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sedited",
        "html_url": "https://github.com/sedited",
        "followers_url": "https://api.github.com/users/sedited/followers",
        "following_url": "https://api.github.com/users/sedited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sedited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sedited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sedited/subscriptions",
        "organizations_url": "https://api.github.com/users/sedited/orgs",
        "repos_url": "https://api.github.com/users/sedited/repos",
        "events_url": "https://api.github.com/users/sedited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sedited/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T17:04:50Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 22711181492,
      "node_id": "HRDE_lADOABII587TTDKpzwAAAAVJsSC0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/22711181492",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-11T17:39:30Z"
    },
    {
      "event": "commented",
      "id": 3890397530,
      "node_id": "IC_kwDOABII587n4sFa",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3890397530",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2026-02-12T11:35:30Z",
      "updated_at": "2026-02-12T11:35:38Z",
      "author_association": "MEMBER",
      "body": "This seems to have introduced a bug: #34573.",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3890397530",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2461223410",
      "pull_request_review_id": 3377790750,
      "id": 2461223410,
      "node_id": "PRRC_kwDOABII586Ss0ny",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }\n+};\n+\n+// Waits for a future to complete. Increments 'fail_counter' if the expected exception is thrown.\n+static void GetFuture(std::future<void>& future, uint32_t& fail_counter)\n+{\n+    try {\n+        future.get();\n+    } catch (const ExpectedException&) {\n+        fail_counter++;\n+    } catch (...) {\n+        assert(false && \"Unexpected exception type\");\n+    }\n+}\n+\n+// Global thread pool for fuzzing. Persisting it across iterations prevents\n+// the excessive thread creation/destruction overhead that can lead to\n+// instability in the fuzzing environment.\n+// This is also how we use it in the app's lifecycle.\n+ThreadPool g_pool{\"fuzz\"};\n+// Global to verify we always have the same number of threads.\n+size_t g_num_workers = 3;\n+\n+static void setup_threadpool_test()\n+{\n+    // Disable logging entirely. It seems to cause memory leaks.",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 59,
      "original_position": 53,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can we investigate that?",
      "created_at": "2025-10-24T16:31:57Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2461223410",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2461223410"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 59,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2466909255",
      "pull_request_review_id": 3385232782,
      "id": 2466909255,
      "node_id": "PRRC_kwDOABII586TCgxH",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\nnit: don't bother with the year any more... (applies to all new files)",
      "created_at": "2025-10-27T19:55:45Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2466909255",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2466909255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469840049",
      "pull_request_review_id": 3389146181,
      "id": 2469840049,
      "node_id": "PRRC_kwDOABII586TNsSx",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Isn't this comment already implied by `GUARDED_BY(m_mutex)`? Also it's written by the control thread and read by worker threads, so of course it must only be modified while holding the mutex. This comment doesn't add anything IMO.\r\n",
      "created_at": "2025-10-28T14:38:48Z",
      "updated_at": "2025-10-28T14:51:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469840049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469840049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469885604",
      "pull_request_review_id": 3389146181,
      "id": 2469885604,
      "node_id": "PRRC_kwDOABII586TN3ak",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm unclear what the purpose of this function is. It interrupts the workers, like `Stop`, but doesn't join them or wait for them to finish.\r\nIf the idea is to clear the workqueue and park the threads without being able to add more tasks, it does not accomplish that since the threads will exit their loops as well and not be parked on the cv.",
      "created_at": "2025-10-28T14:51:52Z",
      "updated_at": "2025-10-28T14:52:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469885604",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469885604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469913117",
      "pull_request_review_id": 3385232782,
      "id": 2469913117,
      "node_id": "PRRC_kwDOABII586TN-Id",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\nI was wondering if there's any way to assert that the unblocked tasks are all executing on one single remaining worker... would it be insane to use a non-atomic `int` here?",
      "created_at": "2025-10-28T14:58:40Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469913117",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469913117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469957844",
      "pull_request_review_id": 3385232782,
      "id": 2469957844,
      "node_id": "PRRC_kwDOABII586TOJDU",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 202,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\n[As mentioned before](https://github.com/bitcoin/bitcoin/pull/26966#discussion_r2228839630), not a blocker but i feel like sleeps like this are test-flakiness waiting to happen ...",
      "created_at": "2025-10-28T15:11:05Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469957844",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469957844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469965455",
      "pull_request_review_id": 3385232782,
      "id": 2469965455,
      "node_id": "PRRC_kwDOABII586TOK6P",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);\n+\n+        // Now process manually\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.ProcessTask();\n+        }\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 209,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\nbelt-and-suspenders, could \r\n`BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);`\r\nI just like the symmetry in a test since you assert the value is `20` before taking action.",
      "created_at": "2025-10-28T15:13:17Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469965455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469965455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469981199",
      "pull_request_review_id": 3389342066,
      "id": 2469981199,
      "node_id": "PRRC_kwDOABII586TOOwP",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Isn't this comment already implied by `GUARDED_BY(m_mutex)`? Also it's written by the control thread and read by worker threads, so of course it must only be modified while holding the mutex. This comment doesn't add anything IMO.\r\n\r\nWhat I meant there is that the variable shouldn’t be an atomic bool alone (in case someone propose to change it in the future). It must share the same mutex as the condition variable; otherwise, workers might not see the update. This is stated in the `std::condition_variable` ref.\r\nI mention it because it is very tempting to avoid locking the mutex during task submission in this way, and might seen like a harmless optimization, but it turns out to cause very subtle issues.\r\n\r\nMaybe you have a better way to state this? Happy to change it if it is not being understood as supposed.",
      "created_at": "2025-10-28T15:18:19Z",
      "updated_at": "2025-10-28T15:45:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469981199",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469981199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470045034",
      "pull_request_review_id": 3389433909,
      "id": 2470045034,
      "node_id": "PRRC_kwDOABII586TOeVq",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> I'm unclear what the purpose of this function is. It interrupts the workers, like `Stop`, but doesn't join them or wait for them to finish.\r\n> If the idea is to clear the workqueue and park the threads without being able to add more tasks, it does not accomplish that since the threads will exit their loops as well and not be parked on the cv.\r\n\r\nActually, the goal is to keep the current shutdown semantics unchanged. The process already follows two stages: first, we stop accepting new requests and events (e.g. unregistering the libevent callback to stop incoming requests); then, once no new work can be queued, we call `Stop()` and wait for the remaining tasks to finish before tearing down the objects.\r\n\r\n`Interrupt()` belongs to the first stage. It basically block new task submissions during shutdown to avoid queue growth. It’s not intended to clear the queue or park the threads. It is there just to avoid pilling up new tasks during shutdown.",
      "created_at": "2025-10-28T15:35:33Z",
      "updated_at": "2025-10-28T15:36:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470045034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470045034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470109463",
      "pull_request_review_id": 3389526506,
      "id": 2470109463,
      "node_id": "PRRC_kwDOABII586TOuEX",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I see, so the goal is to stop the thread pool but in a non-blocking way. Could the same be done via a bool parameter to `Stop` to skip joining? Then `Stop` will be called without that bool set in the destructor to join the threads, if this behavior is desired (like it is in the http server).\r\nAlso, could we modify `Start` in that case to not assert on number of threads if `m_interrupt` is true, and instead join them if we stilll have outstanding threads?",
      "created_at": "2025-10-28T15:52:39Z",
      "updated_at": "2025-10-28T16:22:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470109463",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470109463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470161972",
      "pull_request_review_id": 3389600535,
      "id": 2470161972,
      "node_id": "PRRC_kwDOABII586TO640",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I see. Then perhaps more directly:\r\n```suggestion\r\n    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\r\n```",
      "created_at": "2025-10-28T16:04:23Z",
      "updated_at": "2025-10-28T16:04:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470161972",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470161972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470424759",
      "pull_request_review_id": 3389972243,
      "id": 2470424759,
      "node_id": "PRRC_kwDOABII586TP7C3",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Maybe we should relax this atomic operation so that it doesn't hide any issues by synchronizing them for us.\r\n```suggestion\r\n    void operator()() const { m_counter.fetch_add(1, std::memory_order_relaxed); }\r\n```",
      "created_at": "2025-10-28T17:26:23Z",
      "updated_at": "2025-10-28T17:26:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470424759",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470424759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470732607",
      "pull_request_review_id": 3390383679,
      "id": 2470732607,
      "node_id": "PRRC_kwDOABII586TRGM_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Could the same be done via a bool parameter to Stop to skip joining?\r\n\r\nIf we do that, the threads wouldn't remain in the `m_workers` vector anymore. They'd be swapped out on the first call. That means we wouldn't be able to wait for them to finish later on, which would be quite bad since we’d lose track of when all requests are fulfilled before destroying the backend objects (that's basically what joining the threads mean for us right now). And this could lead to requests accessing null pointers if we proceed with the shutdown without waiting on the threads to join, etc.\r\n\r\n> Also, could we modify Start in that case to not assert on number of threads, and instead join them if m_interrupt is true and we still have outstanding threads?\r\n\r\nWe could also help them process task by calling `ProcessTask()` if something like that happens.\r\nBut I'm not sure that's the best design. We would be integrating `Stop()` inside `Start()`, which would make callers less careful on when to call `Stop()`, which should be part of their code design.\r\n\r\nStill, I don't think we should worry nor overthink this now. The current code starts and stops the thread pool only once during the entire app's lifecycle.",
      "created_at": "2025-10-28T19:01:57Z",
      "updated_at": "2025-10-28T19:03:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470732607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470732607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470743689",
      "pull_request_review_id": 3390398684,
      "id": 2470743689,
      "node_id": "PRRC_kwDOABII586TRI6J",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "sounds good, taken. thanks!",
      "created_at": "2025-10-28T19:07:04Z",
      "updated_at": "2025-10-28T19:07:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470743689",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470743689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470749427",
      "pull_request_review_id": 3390405551,
      "id": 2470749427,
      "node_id": "PRRC_kwDOABII586TRKTz",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": 2470424759,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sure, pushed. Thanks!",
      "created_at": "2025-10-28T19:09:07Z",
      "updated_at": "2025-10-28T19:09:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470749427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470749427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470750271",
      "pull_request_review_id": 3390406684,
      "id": 2470750271,
      "node_id": "PRRC_kwDOABII586TRKg_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I was thinking like this\r\n```diff\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\nindex 94409facd5..dc1a218abd 100644\r\n--- a/src/util/threadpool.h\r\n+++ b/src/util/threadpool.h\r\n@@ -123,19 +123,19 @@ public:\r\n      *\r\n      * Must be called from a controller (non-worker) thread.\r\n      */\r\n-    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n+    void Stop(bool join_threads = true) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         // Notify workers and join them.\r\n         std::vector<std::thread> threads_to_join;\r\n         {\r\n             LOCK(m_mutex);\r\n             m_interrupt = true;\r\n-            threads_to_join.swap(m_workers);\r\n+            if (join_threads) threads_to_join.swap(m_workers);\r\n         }\r\n         m_cv.notify_all();\r\n         for (auto& worker : threads_to_join) worker.join();\r\n         // Since we currently wait for tasks completion, sanity-check empty queue\r\n-        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\r\n+         if (join_threads) WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\r\n         // Note: m_interrupt is left true until next Start()\r\n     }\r\n \r\n@@ -179,12 +179,6 @@ public:\r\n         task();\r\n     }\r\n \r\n-    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n-    {\r\n-        WITH_LOCK(m_mutex, m_interrupt = true);\r\n-        m_cv.notify_all();\r\n-    }\r\n-\r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         return WITH_LOCK(m_mutex, return m_work_queue.size());\r\n```\r\n\r\n> Still, I don't think we should worry nor overthink this now. The current code starts and stops the thread pool only once during the entire app's lifecycle.\r\n\r\nErr, then why not have threads start during construction? Otherwise there's no need for `Start`.",
      "created_at": "2025-10-28T19:09:28Z",
      "updated_at": "2025-10-28T19:09:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470750271",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470750271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470765839",
      "pull_request_review_id": 3390429167,
      "id": 2470765839,
      "node_id": "PRRC_kwDOABII586TROUP",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "You know, we could call `ProcessTask()` during `Stop()` too, which would be a strict improvement over the current locking-wait behavior in master (since we would shut down faster by actively processing pending requests on the shutdown thread as well). This is something that hasn’t been possible until now.\r\nStill, this is material for a follow-up; would say that it is better to keep this PR as contained as possible so all other PRs and working paths that depend on this structure can actually make use of it.",
      "created_at": "2025-10-28T19:15:43Z",
      "updated_at": "2025-10-28T19:17:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470765839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470765839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470784762",
      "pull_request_review_id": 3390460118,
      "id": 2470784762,
      "node_id": "PRRC_kwDOABII586TRS76",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "That is a good idea, but not related to my suggestion here :). Yes, that would be a good followup.\r\nI don't think we should have a method that would cause the node to crash if `Start` is called more than once. I disagree and think just calling `Stop` at the beginning of `Start` would be safer than the current implementation.",
      "created_at": "2025-10-28T19:22:53Z",
      "updated_at": "2025-10-28T19:22:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470784762",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470784762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470824383",
      "pull_request_review_id": 3390512679,
      "id": 2470824383,
      "node_id": "PRRC_kwDOABII586TRcm_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "hehe, it seems we sent a message at a similar time and missed yours.\r\n\r\nre `Interrupt()` removal suggestion:\r\n\r\nI find it harder to reason about the current two stages shutdown procedure if we have to call to the same `Stop()` method twice. At that point it would be simpler to just wait for all tasks to finish on the first call and remove the second one. But that seems suboptimal as there is no rush to wait for them at that point of the shutdown sequence.\r\n\r\nAlso, a benefit of keeping `Interrupt()` is that we can build on top of it and have a faster and non-locking way of checking if the thread pool is enabled. \r\nSo callers would be able to call something like `pool.IsRunning()` to see if they can submit tasks without have to worry locking the main mutex and slowing down the workers processing. Something like:\r\n\r\n```diff\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\n--- a/src/util/threadpool.h\t(revision e0ec3232daf2c311471a1da149821bed18853fcc)\r\n+++ b/src/util/threadpool.h\t(date 1761158485938)\r\n@@ -55,6 +55,9 @@\r\n     // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\r\n     bool m_interrupt GUARDED_BY(m_mutex){false};\r\n     std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\r\n+    // Enabled only after Start and disabled early on Stop/Interrupt.\r\n+    // This lets us do non-blocking 'IsRunning' checks.\r\n+    std::atomic<bool> m_running{false};\r\n \r\n     void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n@@ -109,9 +112,11 @@\r\n         m_interrupt = false; // Reset\r\n \r\n         // Create workers\r\n         m_workers.reserve(num_workers);\r\n         for (int i = 0; i < num_workers; i++) {\r\n             m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\r\n         }\r\n+        m_running.store(true, std::memory_order_release);\r\n     }\r\n \r\n     /**\r\n@@ -124,7 +129,9 @@\r\n      */\r\n     void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n-        // Notify workers and join them.\r\n+        // Mark as no longer accepting new tasks\r\n+        m_running.store(false, std::memory_order_release);\r\n+        // Notify workers and join them\r\n         std::vector<std::thread> threads_to_join;\r\n         {\r\n             LOCK(m_mutex);\r\n@@ -147,11 +154,16 @@\r\n     template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     auto Submit(F&& fn)\r\n     {\r\n+        // Quick rejection based on Start/Stop/Interrupt before locking\r\n+        if (!m_running.load(std::memory_order_acquire)) {\r\n+            throw std::runtime_error(\"ThreadPool not running\");\r\n+        }\r\n+\r\n         std::packaged_task task{std::forward<F>(fn)};\r\n         auto future{task.get_future()};\r\n         {\r\n             LOCK(m_mutex);\r\n             if (m_workers.empty() || m_interrupt) {\r\n                 throw std::runtime_error(\"No active workers; cannot accept new tasks\");\r\n             }\r\n             m_work_queue.emplace(std::move(task));\r\n@@ -180,7 +192,9 @@\r\n \r\n     void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n+        m_running.store(false, std::memory_order_release);\r\n         WITH_LOCK(m_mutex, m_interrupt = true);\r\n         m_cv.notify_all();\r\n     }\r\n \r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n@@ -192,6 +206,11 @@\r\n     {\r\n         return WITH_LOCK(m_mutex, return m_workers.size());\r\n     }\r\n+\r\n+    bool IsRunning() const noexcept\r\n+    {\r\n+        return m_running.load(std::memory_order_acquire);\r\n+    }\r\n };\r\n \r\n #endif // BITCOIN_UTIL_THREADPOOL_H\r\n```\r\n\r\n(this is not needed here because we are disconnecting the http callback prior to interrupting the pool but it seems useful in general).",
      "created_at": "2025-10-28T19:37:46Z",
      "updated_at": "2025-10-28T19:50:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470824383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470824383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470845344",
      "pull_request_review_id": 3390538651,
      "id": 2470845344,
      "node_id": "PRRC_kwDOABII586TRhug",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> I don't think we should have a method that would cause the node to crash if Start is called more than once. I disagree and think just calling Stop at the beginning of Start would be safer than the current implementation.\r\n\r\nWouldn't you agree that if your code calls `Start()` twice, you have a design issue? Thread pools are typically started once, maintained for the entire app’s lifecycle, and reused across modules. Mainly because creating and destroying threads isn’t cheap. I think it’s fair to expect an exception in that case, as it would indicate poorly structured code.\r\n\r\nI also don’t think anyone would expect `Start()` to wait for all existing threads to shut down and then spawn new ones. That would be a surprising behavior to me. Why would you spawn new ones if you already have threads available?",
      "created_at": "2025-10-28T19:46:09Z",
      "updated_at": "2025-10-28T19:47:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470845344",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470845344"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470851529",
      "pull_request_review_id": 3390546152,
      "id": 2470851529,
      "node_id": "PRRC_kwDOABII586TRjPJ",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "So why have `Start` and `Stop` then? Just start threads in constructor and join in destructor? Use `Interrupt` to stop new tasks from being added. This follows RAII principles.",
      "created_at": "2025-10-28T19:48:41Z",
      "updated_at": "2025-10-28T19:49:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470851529",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470851529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470902222",
      "pull_request_review_id": 3390612876,
      "id": 2470902222,
      "node_id": "PRRC_kwDOABII586TRvnO",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> So why have `Start` and `Stop` then? Just start threads in constructor and join in destructor? Use `Interrupt` to stop new tasks from being added. This follows RAII principles.\r\n\r\nGood question. We could easily build an RAII wrapper on top of this. The approaches aren’t conflicting; it would just be an additional layer over the current code.\r\nYet, I think the current design smoothly integrates with our existing workflows. We already use the `start`, `interrupt`, and `stop` terms throughout the codebase (check `init.cpp` and all our components), so following that general convention makes it easier to reason about these components globally. Even without deep knowledge of the http server workflow, anyone familiar with this convention can quickly hook up new functionality.\r\n\r\nAlso, I suspect we’ll find opportunities for improvements (or smarter shutdown behaviors) along the way that might require customizing `Stop()` with some inputs, so might be better not to enforce RAII too early.",
      "created_at": "2025-10-28T20:11:38Z",
      "updated_at": "2025-10-28T20:13:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470902222",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470902222"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2471097523",
      "pull_request_review_id": 3390873847,
      "id": 2471097523,
      "node_id": "PRRC_kwDOABII586TSfSz",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Follow-up to this convo after some great back-and-forth via DM with Andrew.\r\nUsually, RAII works best when we don’t care exactly when an object gets destroyed. In this case, though, we actually do care about that moment (or, in our terms, when it’s stopped), since it marks the point where there are no pending tasks and it’s safe to tear down the backend handlers.\r\nIf we don’t enforce that explicitly, the shutdown procedure could continue while workers are still active, leading them to access null pointers, etc.\r\nThis is something we can’t guarantee if we just let the object be destroyed whenever the program releases it using RAII. So even using RAII, we would be forced to destroy the object manually anyway. Which kinda defeats the purpose of it.",
      "created_at": "2025-10-28T21:29:59Z",
      "updated_at": "2025-10-28T21:30:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2471097523",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2471097523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473904846",
      "pull_request_review_id": 3394420645,
      "id": 2473904846,
      "node_id": "PRRC_kwDOABII586TdMrO",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> [c219b93](https://github.com/bitcoin/bitcoin/commit/c219b93c3b043de202bdf3c65b433fd17af2da89)\r\n> \r\n> I was wondering if there's any way to assert that the unblocked tasks are all executing on one single remaining worker... would it be insane to use a non-atomic `int` here?\r\n\r\nhmm, even if the non-atomic int works, that doesn't really guarantee that the increment was done in the same thread.\r\nIf we want to be 100% correct, we should store the ids of the threads that processed the tasks on a synchronized structure. Then check that only one id is there.",
      "created_at": "2025-10-29T15:43:28Z",
      "updated_at": "2025-10-29T15:43:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473904846",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473904846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473946974",
      "pull_request_review_id": 3394471642,
      "id": 2473946974,
      "node_id": "PRRC_kwDOABII586TdW9e",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 202,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469957844,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> [c219b93](https://github.com/bitcoin/bitcoin/commit/c219b93c3b043de202bdf3c65b433fd17af2da89)\r\n> \r\n> [As mentioned before](https://github.com/bitcoin/bitcoin/pull/26966#discussion_r2228839630), not a blocker but i feel like sleeps like this are test-flakiness waiting to happen ...\r\n\r\nThis is one of those \"wait and see if something happens\" scenarios (if any task gets processed). We expect no activity here since all workers are busy.\r\nI'm not sure there is another way of doing this, but if it fails (even if it is not deterministic), that’s still a useful signal because it means something unexpected happened.",
      "created_at": "2025-10-29T15:49:47Z",
      "updated_at": "2025-10-29T15:50:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473946974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473946974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473982880",
      "pull_request_review_id": 3394514584,
      "id": 2473982880,
      "node_id": "PRRC_kwDOABII586Tdfug",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);\n+\n+        // Now process manually\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.ProcessTask();\n+        }\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 209,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469965455,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sounds good. Done as suggested. Thanks",
      "created_at": "2025-10-29T15:55:12Z",
      "updated_at": "2025-10-29T15:55:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473982880",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473982880"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473984516",
      "pull_request_review_id": 3394516281,
      "id": 2473984516,
      "node_id": "PRRC_kwDOABII586TdgIE",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2466909255,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sure. Done as suggested.",
      "created_at": "2025-10-29T15:55:23Z",
      "updated_at": "2025-10-29T15:55:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473984516",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473984516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474000255",
      "pull_request_review_id": 3394534398,
      "id": 2474000255,
      "node_id": "PRRC_kwDOABII586Tdj9_",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "thread sanitizer would likely pick up on it though if you made it non-atomic.",
      "created_at": "2025-10-29T15:57:41Z",
      "updated_at": "2025-10-29T15:57:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474000255",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474000255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474671206",
      "pull_request_review_id": 3395333045,
      "id": 2474671206,
      "node_id": "PRRC_kwDOABII586TgHxm",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "true. Closing this.",
      "created_at": "2025-10-29T18:37:02Z",
      "updated_at": "2025-10-29T18:37:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474671206",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474671206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474735112",
      "pull_request_review_id": 3395398503,
      "id": 2474735112,
      "node_id": "PRRC_kwDOABII586TgXYI",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I mean pick up that it's being written by multiple threads if something breaks the assumptions in this test. It seems like an ok idea. Or am I wrong?",
      "created_at": "2025-10-29T18:44:45Z",
      "updated_at": "2025-10-29T18:44:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474735112",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474735112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474919127",
      "pull_request_review_id": 3395577438,
      "id": 2474919127,
      "node_id": "PRRC_kwDOABII586ThETX",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> I mean pick up that it's being written by multiple threads if something breaks the assumptions in this test. It seems like an ok idea. Or am I wrong?\r\n\r\nI don't think there is any broken assumption. `BlockWorkers()` ensure that all threads except one are blocked. We could go further and check that all tasks submitted post the `BlockWorkers` call are executed by the same thread too, but that seems to be an overkill to me. We are basically ensuring that in another way.",
      "created_at": "2025-10-29T19:05:24Z",
      "updated_at": "2025-10-29T19:05:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474919127",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474919127"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475135383",
      "pull_request_review_id": 3395828960,
      "id": 2475135383,
      "node_id": "PRRC_kwDOABII586Th5GX",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sorry for being unclear. I don't think there is any broken assumption either.\r\nHowever, if we made this a non-atomic as suggested, then *if* something in the future were to break this assumption and run these tasks on multiple threads the unit test would break. Thus it would act as a regression test.",
      "created_at": "2025-10-29T19:46:12Z",
      "updated_at": "2025-10-29T19:46:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2475135383",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475135383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475307568",
      "pull_request_review_id": 3396044287,
      "id": 2475307568,
      "node_id": "PRRC_kwDOABII586TijIw",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Sorry for being unclear. I don't think there is any broken assumption either.\r\n> However, if we made this a non-atomic as suggested, then _if_ something in the future were to break this assumption and run these tasks on multiple threads the unit test would break. Thus it would act as a regression test.\r\n\r\nBut as you said, the thread sanitizer would likely complain about that. We’re accessing the same variable from different threads (main and worker). The main issue, however, will probably be related to thread visibility; changes made in one thread aren’t guaranteed to be visible to another. So that approach seems fragile to me.\r\n\r\nAlso, going back to my initial comment: even if we switch to a non-atomic variable, the test could still pass. If we want it to be fully deterministic, we should store the IDs of the threads that processed the tasks in a synchronized structure, and then check that only one ID is present at the end. That seems to be the most secure approach to me.\r\n\r\nI could push this if have to re-touch. But it doesn't seem to be a blocking feature (at least to me). We do ensure all threads except one are blocked in the test, and we fail if not.",
      "created_at": "2025-10-29T20:28:05Z",
      "updated_at": "2025-10-29T20:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2475307568",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475307568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475738139",
      "pull_request_review_id": 3396566505,
      "id": 2475738139,
      "node_id": "PRRC_kwDOABII586TkMQb",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> But as you said, the thread sanitizer would likely complain about that. We’re accessing the same variable from different threads (main and worker).\r\n\r\nIt won't complain if we synchronize access to the same non-atomic variable, which we do here because we lock when calling `Submit`.\r\n\r\n> The main issue, however, will probably be related to thread visibility; changes made in one thread aren’t guaranteed to be visible to another.\r\n\r\nI don't think this is the main issue. If a future change breaks the ThreadPool such that in this test more than 1 thread will write to this non-atomic variable, then the thread sanitizer will cause the test to fail due to a data race.",
      "created_at": "2025-10-29T22:16:37Z",
      "updated_at": "2025-10-29T22:16:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2475738139",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475738139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2476143122",
      "pull_request_review_id": 3397101995,
      "id": 2476143122,
      "node_id": "PRRC_kwDOABII586TlvIS",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Pushed.",
      "created_at": "2025-10-30T01:23:17Z",
      "updated_at": "2025-10-30T01:23:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2476143122",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2476143122"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477334363",
      "pull_request_review_id": 3377790750,
      "id": 2477334363,
      "node_id": "PRRC_kwDOABII586TqR9b",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 12,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: we don't need to include the type here:\r\n```suggestion\r\nconstexpr auto TIMEOUT{std::chrono::seconds(120)};\r\n```\r\nhttps://github.com/bitcoin/bitcoin/pull/26966#discussion_r2423291668",
      "created_at": "2025-10-30T10:17:16Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477334363",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477334363"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477395665",
      "pull_request_review_id": 3377790750,
      "id": 2477395665,
      "node_id": "PRRC_kwDOABII586Tqg7R",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 114,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: we could use `strprintf` in a few more places:\r\n```suggestion\r\n            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\r\n```",
      "created_at": "2025-10-30T10:29:12Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477395665",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477395665"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477415169",
      "pull_request_review_id": 3377790750,
      "id": 2477415169,
      "node_id": "PRRC_kwDOABII586TqlsB",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();",
      "path": "src/util/threadpool.h",
      "position": 139,
      "original_position": 135,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "What's the reason for locking and notifying manually instead of using higher-level primitives - have you tried these with C++20 https://en.cppreference.com/w/cpp/thread/barrier.html instead?",
      "created_at": "2025-10-30T10:33:01Z",
      "updated_at": "2025-11-17T15:55:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477415169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477415169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 135,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477415901",
      "pull_request_review_id": 3377790750,
      "id": 2477415901,
      "node_id": "PRRC_kwDOABII586Tql3d",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;",
      "path": "src/util/threadpool.h",
      "position": 128,
      "original_position": 129,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm not sure this is necessarry",
      "created_at": "2025-10-30T10:33:12Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477415901",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477415901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 128,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477455551",
      "pull_request_review_id": 3377790750,
      "id": 2477455551,
      "node_id": "PRRC_kwDOABII586Tqvi_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {",
      "path": "src/util/threadpool.h",
      "position": 65,
      "original_position": 66,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "do we really need this extra complexity here? ",
      "created_at": "2025-10-30T10:41:00Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477455551",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477455551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477459325",
      "pull_request_review_id": 3377790750,
      "id": 2477459325,
      "node_id": "PRRC_kwDOABII586Tqwd9",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker",
      "path": "src/util/threadpool.h",
      "position": 70,
      "original_position": 71,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "the comment mirrors the code, it doesn't really add anything that the code doesn't already say (especially since the comment above already stated the same)",
      "created_at": "2025-10-30T10:41:49Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477459325",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477459325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 70,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477491505",
      "pull_request_review_id": 3377790750,
      "id": 2477491505,
      "node_id": "PRRC_kwDOABII586Tq4Ux",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 89,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: for consistency\r\n```suggestion\r\n        for (size_t i{1}; i <= num_tasks; ++i) {\r\n```",
      "created_at": "2025-10-30T10:48:59Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477491505",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477491505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477505686",
      "pull_request_review_id": 3377790750,
      "id": 2477505686,
      "node_id": "PRRC_kwDOABII586Tq7yW",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 206,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), num_tasks);\r\n```",
      "created_at": "2025-10-30T10:51:49Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477505686",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477505686"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 206,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477534828",
      "pull_request_review_id": 3377790750,
      "id": 2477534828,
      "node_id": "PRRC_kwDOABII586TrC5s",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I like how thoroughly we're testing the functionality here, that helps a lot with being able to trust this complex code.\r\n\r\nI wanted to debug these one-by-one and I don't want to run all other tests before - and it's a bit awkward to have so many tests in a single place when they're admittedly separate.\r\nCould you please split them out into separate units, such as:\r\n```suggestion\r\nBOOST_AUTO_TEST_CASE(submit_to_non_started_pool_throws)\r\n{\r\n    ThreadPool threadPool{\"not_started\"};\r\n    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, HasReason{\"No active workers\"});\r\n}\r\n```",
      "created_at": "2025-10-30T10:58:10Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477534828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477534828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477550353",
      "pull_request_review_id": 3377790750,
      "id": 2477550353,
      "node_id": "PRRC_kwDOABII586TrGsR",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 51,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "As mentioned before, we're having a single big-bang test case here (called \"threadpool_basic\", but it contains everything we have), announcing the parts in comments followed by duplicating each comment.\r\nCan we split them out to focused, self-documenting test cases, something like:\r\n```python\r\nBOOST_AUTO_TEST_CASE(submit_to_non_started_pool_throws)\r\nBOOST_AUTO_TEST_CASE(submit_and_verify_completion)\r\nBOOST_AUTO_TEST_CASE(single_available_worker_processes_all_tasks)\r\nBOOST_AUTO_TEST_CASE(future_wait_blocks_until_task_completes)\r\nBOOST_AUTO_TEST_CASE(future_get_returns_task_result)\r\nBOOST_AUTO_TEST_CASE(task_exception_propagated_to_future)\r\nBOOST_AUTO_TEST_CASE(process_task_manually_when_workers_busy)\r\nBOOST_AUTO_TEST_CASE(recursive_task_submission)\r\nBOOST_AUTO_TEST_CASE(stop_completes_queued_tasks_gracefully)\r\n```\r\n\r\nThat would help reviewers experiment and have exact test faulures, we could replace a lot of dead comments with code and provide better structure for the testing efforts.",
      "created_at": "2025-10-30T11:01:29Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477550353",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477550353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477594461",
      "pull_request_review_id": 3377790750,
      "id": 2477594461,
      "node_id": "PRRC_kwDOABII586TrRdd",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 83,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nits: `std::atomic_int` and its brothers seem more focused (and brace init helps with many narrowing problems) - we're using these in the fuzzing commit as well:\r\n```suggestion\r\n        std::atomic_size_t counter{0};\r\n```",
      "created_at": "2025-10-30T11:10:34Z",
      "updated_at": "2025-10-30T16:07:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477594461",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477594461"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 83,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477599430",
      "pull_request_review_id": 3377790750,
      "id": 2477599430,
      "node_id": "PRRC_kwDOABII586TrSrG",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 90,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit:\r\n```suggestion\r\n            futures.emplace_back(threadPool.Submit([&counter, i] {\r\n```",
      "created_at": "2025-10-30T11:11:20Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477599430",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477599430"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477610248",
      "pull_request_review_id": 3377790750,
      "id": 2477610248,
      "node_id": "PRRC_kwDOABII586TrVUI",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 96,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm not yet sure I understand why the test framework needs a wait method, that sounds like something the thread pool should provide. This is why I mentioned in https://github.com/bitcoin/bitcoin/pull/26966#discussion_r2424805627 that the problem has to come before the solution, because the reviewers have to check out the follow-up comments to see if this is representative of actual usage or not.",
      "created_at": "2025-10-30T11:13:22Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477610248",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477610248"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 95,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 96,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477612103",
      "pull_request_review_id": 3377790750,
      "id": 2477612103,
      "node_id": "PRRC_kwDOABII586TrVxH",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 95,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "comment is redundant, the method name and context already state all of that",
      "created_at": "2025-10-30T11:13:42Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477612103",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477612103"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 95,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477631031",
      "pull_request_review_id": 3377790750,
      "id": 2477631031,
      "node_id": "PRRC_kwDOABII586TraY3",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);",
      "path": "src/util/threadpool.h",
      "position": 105,
      "original_position": 106,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can we narrow the type in that case to at least disallow negative values?\r\n```suggestion\r\n    void Start(size_t num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n    {\r\n        assert(num_workers > 0);\r\n```",
      "created_at": "2025-10-30T11:17:37Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477631031",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477631031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 103,
      "original_start_line": 104,
      "start_side": "RIGHT",
      "line": 105,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477663057",
      "pull_request_review_id": 3377790750,
      "id": 2477663057,
      "node_id": "PRRC_kwDOABII586TriNR",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 91,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Since this isn't a [synchronization operations](https://en.cppreference.com/w/cpp/atomic/memory_order.html#Relaxed_ordering), the default is `memory_order_seq_cst ` seems too strong here and it might hide the data race by providing unintended synchronization:\r\n```suggestion\r\n                counter.fetch_add(i, std::memory_order_relaxed);\r\n```\r\n\r\nI have created a godbolt reproducer to understand it better, see: https://godbolt.org/z/o87dsq1fG\r\nI couldn't find any real difference on x86 cpus, but ARM ones show the difference (`__aarch64_ldadd4_acq_rel` vs `__aarch64_ldadd4_relax`)",
      "created_at": "2025-10-30T11:23:02Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477663057",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477663057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477872985",
      "pull_request_review_id": 3377790750,
      "id": 2477872985,
      "node_id": "PRRC_kwDOABII586TsVdZ",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 77,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm usually coding along while reviewing, to simplify applying the suggestions that you like, I'm posting the final results as well:\r\n```C++\r\nBOOST_AUTO_TEST_CASE(submit_and_verify_completion)\r\n{\r\n    ThreadPool threadPool{\"completion\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n\r\n    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n    std::atomic_size_t counter{0};\r\n\r\n    std::vector<std::future<void>> futures(num_tasks);\r\n    for (size_t i{0}; i < num_tasks; ++i) {\r\n        futures[i] = threadPool.Submit([&counter, i] { counter.fetch_add(i, std::memory_order_relaxed); });\r\n    }\r\n\r\n    WaitFor(futures);\r\n    BOOST_CHECK_EQUAL(counter.load(std::memory_order_relaxed), (num_tasks - 1) * num_tasks / 2);\r\n    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n}\r\n```",
      "created_at": "2025-10-30T12:12:01Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477872985",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477872985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477876362",
      "pull_request_review_id": 3377790750,
      "id": 2477876362,
      "node_id": "PRRC_kwDOABII586TsWSK",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 79,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "we're iterating forward, seems simpler to use an unsigned here\r\n```suggestion\r\n        constexpr size_t num_tasks{50};\r\n```\r\nand to add some variance to the tests we could vary these randomly:\r\n```suggestion\r\n        const auto num_tasks{1 + m_rng.randrange<size_t>(50)};\r\n```\r\nnote that this will need:\r\n```C++\r\nBOOST_FIXTURE_TEST_SUITE(threadpool_tests, BasicTestingSetup)\r\n```",
      "created_at": "2025-10-30T12:13:28Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477876362",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477876362"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477927319",
      "pull_request_review_id": 3377790750,
      "id": 2477927319,
      "node_id": "PRRC_kwDOABII586TsiuX",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 26,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`ThreadPool::WorkersCount()` returns `size_t`, if we restricted `num_of_threads_to_block` to `size_t` as well, we could assert here:\r\n```C++\r\n    assert(threadPool.WorkersCount() >= num_of_threads_to_block);\r\n```",
      "created_at": "2025-10-30T12:32:48Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477927319",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477927319"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 26,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477992659",
      "pull_request_review_id": 3377790750,
      "id": 2477992659,
      "node_id": "PRRC_kwDOABII586TsyrT",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 22,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "As mentioned [before](https://github.com/bitcoin/bitcoin/pull/26966#discussion_r2424865671), I think these could be simplified to `std::span`, `std::string_view` and `strprintf`.\r\nAnd if we extract each test to a separate unit (as suggested below), we won't need the context parameter anymore.\r\nThe thread index also doesn't really help in case of the failure, which would enable us to simplify this.\r\nAnd lastly, since `BlockWorkers` is already a `std::vector<std::future<void>>` we don't actually need the template here:\r\n```suggestion\r\nvoid WaitFor(std::span<const std::future<void>> futures)\r\n{\r\n    for (const auto& f : futures) {\r\n        BOOST_REQUIRE(f.wait_for(TIMEOUT) == std::future_status::ready);\r\n    }\r\n}\r\n```",
      "created_at": "2025-10-30T12:55:45Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477992659",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2477992659"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478023810",
      "pull_request_review_id": 3377790750,
      "id": 2478023810,
      "node_id": "PRRC_kwDOABII586Ts6SC",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 102,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "we could generalize this by counting from `1` to `<NUM_WORKERS_DEFAULT`, something like:\r\n```C++\r\nBOOST_AUTO_TEST_CASE(limited_free_workers_processes_all_task)\r\n{\r\n    ThreadPool threadPool{\"block_counts\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n\r\n    for (size_t free{1}; free < NUM_WORKERS_DEFAULT; ++free) {\r\n        BOOST_TEST_MESSAGE(\"Testing with \" << free << \" available workers\");\r\n        std::counting_semaphore sem{0};\r\n        const auto blocking_tasks{BlockWorkers(threadPool, sem, free)};\r\n\r\n        size_t counter{0};\r\n        std::vector<std::future<void>> futures(num_tasks);\r\n        for (auto& f : futures) f = threadPool.Submit([&counter] { ++counter; });\r\n\r\n        WaitFor(futures);\r\n        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n\r\n        if (free == 1) {\r\n            BOOST_CHECK_EQUAL(counter, num_tasks);\r\n        } else {\r\n            BOOST_CHECK_LE(counter, num_tasks); // unsynchronized update from multiple threads doesn't guarantee consistency\r\n        }\r\n\r\n        sem.release(free);\r\n        WaitFor(blocking_tasks);\r\n    }\r\n\r\n    threadPool.Stop();\r\n}\r\n```",
      "created_at": "2025-10-30T13:05:20Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478023810",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478023810"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478145839",
      "pull_request_review_id": 3377790750,
      "id": 2478145839,
      "node_id": "PRRC_kwDOABII586TtYEv",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 62,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I needed at least nproc+1 workers to be able to reliably reproduce concurrency issues (such as the non-atomic `counter` update)\r\n```suggestion\r\n    const size_t NUM_WORKERS_DEFAULT{size_t(GetNumCores()) + 1}; // we need to make sure there's *some* contention\r\n```",
      "created_at": "2025-10-30T13:37:40Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478145839",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478145839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478192040",
      "pull_request_review_id": 3377790750,
      "id": 2478192040,
      "node_id": "PRRC_kwDOABII586TtjWo",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 123,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: these setup parts are longer than they need to be, this is just glue code, I find it distracting from the actual test logic:\r\n```suggestion\r\n        std::vector<std::future<void>> futures(num_tasks);\r\n        for (auto& f : futures) f = threadPool.Submit([&counter]{ ++counter; });\r\n```",
      "created_at": "2025-10-30T13:48:41Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478192040",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478192040"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 117,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478265102",
      "pull_request_review_id": 3377790750,
      "id": 2478265102,
      "node_id": "PRRC_kwDOABII586Tt1MO",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 143,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "hmm, isn't this why `WaitFor` was added with a timeout in the first place?",
      "created_at": "2025-10-30T14:08:58Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478265102",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478265102"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 143,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478268256",
      "pull_request_review_id": 3377790750,
      "id": 2478268256,
      "node_id": "PRRC_kwDOABII586Tt19g",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 140,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "maybe we can test more here, each test waiting a different amount (e.g. work index milliseconds) and we could assert at the end that complection takes at least `NUM_WORKERS_DEFAULT` milliseconds.\r\n```C++\r\nBOOST_AUTO_TEST_CASE(future_wait_blocks_until_task_completes)\r\n{\r\n    ThreadPool threadPool{\"wait_test\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n\r\n    const auto start{steady_clock::now()};\r\n    std::vector<std::future<void>> futures(num_tasks + 1);\r\n    for (size_t i{0}; i <= num_tasks; ++i) {\r\n        futures[i] = threadPool.Submit([i] { UninterruptibleSleep(milliseconds{i}); });\r\n    }\r\n    WaitFor(futures);\r\n    const size_t elapsed_ms{size_t(duration_cast<milliseconds>(steady_clock::now() - start).count())};\r\n    BOOST_CHECK(elapsed_ms >= num_tasks);\r\n}\r\n```",
      "created_at": "2025-10-30T14:10:00Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478268256",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478268256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 140,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478278715",
      "pull_request_review_id": 3377790750,
      "id": 2478278715,
      "node_id": "PRRC_kwDOABII586Tt4g7",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);\n+\n+        // Now process manually\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.ProcessTask();\n+        }\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+        blocker.set_value();\n+        threadPool.Stop();\n+        WaitFor(blocking_tasks, \"Failure waiting for test6 blocking task futures\");\n+    }\n+\n+    // Test case 7, recursive submission of tasks.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> signal;\n+        threadPool.Submit([&]() {\n+            threadPool.Submit([&]() {\n+                signal.set_value();\n+            });\n+        });\n+\n+        signal.get_future().wait();\n+        threadPool.Stop();\n+    }\n+\n+    // Test case 8, submit a task when all threads are busy and then stop the pool.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test8 blocking tasks enabled\");\n+\n+        // Submit an extra task that should execute once a worker is free\n+        std::future<bool> future = threadPool.Submit([]() { return true; });\n+\n+        // At this point, all workers are blocked, and the extra task is queued\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\n+\n+        // Wait a short moment before unblocking the threads to mimic a concurrent shutdown\n+        std::thread thread_unblocker([&blocker]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{300});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 252,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "We could likely use `UninterruptibleSleep` here instead",
      "created_at": "2025-10-30T14:13:12Z",
      "updated_at": "2025-10-30T16:07:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478278715",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478278715"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478379002",
      "pull_request_review_id": 3377790750,
      "id": 2478379002,
      "node_id": "PRRC_kwDOABII586TuQ_6",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 47,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "What is the reason for the heavy use of promises? Does it have any advantage compared to C++20 concurrency primitives? This seems to me like a barebones implementation for an `std::latch`. Can we use that instead?\r\n\r\nThis seemed like a `std::binary_semaphore` to me initially but couldn't make it work with that.\r\n\r\nBut we can still use a simple `std::counting_semaphore` which would avoid the `std::promise` + `std::shared_future` + `std::vector<std::future<void>>`, something like:\r\n```suggestion\r\nstd::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::counting_semaphore<>& release_sem, size_t num_of_threads_to_block)\r\n{\r\n    assert(threadPool.WorkersCount() >= num_of_threads_to_block);\r\n    std::latch ready{std::ptrdiff_t(num_of_threads_to_block)};\r\n\r\n    std::vector<std::future<void>> blocking_tasks(num_of_threads_to_block);\r\n    for (auto& f : blocking_tasks) f = threadPool.Submit([&] {\r\n        ready.count_down();\r\n        release_sem.acquire();\r\n    });\r\n\r\n    ready.wait();\r\n    return blocking_tasks;\r\n}\r\n```",
      "created_at": "2025-10-30T14:41:46Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478379002",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478379002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 26,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478404154",
      "pull_request_review_id": 3377790750,
      "id": 2478404154,
      "node_id": "PRRC_kwDOABII586TuXI6",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 147,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "we could extract this to something like:\r\n```C++\r\nBOOST_AUTO_TEST_CASE(future_get_returns_task_result)\r\n{\r\n    ThreadPool threadPool{\"result_test\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n    \r\n    BOOST_CHECK_EQUAL(threadPool.Submit([] { return true; }).get(), true);\r\n    BOOST_CHECK_EQUAL(threadPool.Submit([] { return 42; }).get(), 42);\r\n    BOOST_CHECK_EQUAL(threadPool.Submit([] { return std::string{\"true\"}; }).get(), \"true\");\r\n}\r\n```",
      "created_at": "2025-10-30T14:47:17Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478404154",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478404154"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 147,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478410042",
      "pull_request_review_id": 3377790750,
      "id": 2478410042,
      "node_id": "PRRC_kwDOABII586TuYk6",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 168,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "in other cases we called this `num_tasks`",
      "created_at": "2025-10-30T14:48:35Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478410042",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478410042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478427757",
      "pull_request_review_id": 3377790750,
      "id": 2478427757,
      "node_id": "PRRC_kwDOABII586Tuc5t",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 170,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "do we need a vector here of can we just consume whatever we just submitted?\r\n```C++\r\nBOOST_AUTO_TEST_CASE(task_exception_propagated_to_future)\r\n{\r\n    ThreadPool threadPool{\"exception_test\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n\r\n    const auto make_err{[&](size_t n) { return strprintf(\"error on thread #%s\", n); }};\r\n\r\n    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n    for (size_t i{0}; i < num_tasks; ++i) {\r\n        BOOST_CHECK_EXCEPTION(threadPool.Submit([&] { throw std::runtime_error(make_err(i)); }).get(), std::runtime_error, HasReason{make_err(i)});\r\n    }\r\n}\r\n```",
      "created_at": "2025-10-30T14:52:59Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478427757",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478427757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478578316",
      "pull_request_review_id": 3377790750,
      "id": 2478578316,
      "node_id": "PRRC_kwDOABII586TvBqM",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 188,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "We can split out the remaining 3 tests as well:\r\n```C++\r\n\r\nBOOST_AUTO_TEST_CASE(process_task_manually_when_workers_busy)\r\n{\r\n    ThreadPool threadPool{\"manual_process\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n\r\n    std::counting_semaphore sem{0};\r\n    const auto blocking_tasks{BlockWorkers(threadPool, sem, NUM_WORKERS_DEFAULT)};\r\n\r\n    std::atomic_size_t counter{0};\r\n    std::vector<std::future<void>> futures(num_tasks);\r\n    for (auto& f : futures) f = threadPool.Submit([&counter] { counter.fetch_add(1, std::memory_order_relaxed); });\r\n\r\n    UninterruptibleSleep(milliseconds{100});\r\n    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), num_tasks);\r\n\r\n    for (size_t i{0}; i < num_tasks; ++i) {\r\n        threadPool.ProcessTask();\r\n    }\r\n\r\n    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\r\n    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\r\n\r\n    sem.release(NUM_WORKERS_DEFAULT);\r\n    WaitFor(blocking_tasks);\r\n}\r\n\r\nBOOST_AUTO_TEST_CASE(recursive_task_submission)\r\n{\r\n    ThreadPool threadPool{\"recursive\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n\r\n    std::promise<void> signal;\r\n    threadPool.Submit([&threadPool, &signal] {\r\n        threadPool.Submit([&signal] {\r\n            signal.set_value();\r\n        });\r\n    });\r\n\r\n    signal.get_future().wait();\r\n}\r\n\r\nBOOST_AUTO_TEST_CASE(stop_completes_queued_tasks_gracefully)\r\n{\r\n    ThreadPool threadPool{\"graceful_stop\"};\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n\r\n    std::counting_semaphore sem{0};\r\n    const auto blocking_tasks{BlockWorkers(threadPool, sem, NUM_WORKERS_DEFAULT)};\r\n\r\n    auto future{threadPool.Submit([] { return true; })};\r\n    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\r\n\r\n    std::thread thread_unblocker{[&sem] {\r\n        std::this_thread::sleep_for(milliseconds{300});\r\n        sem.release(NUM_WORKERS_DEFAULT);\r\n    }};\r\n\r\n    threadPool.Stop();\r\n\r\n    BOOST_CHECK(future.get());\r\n    thread_unblocker.join();\r\n    WaitFor(blocking_tasks);\r\n    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\r\n}\r\n```",
      "created_at": "2025-10-30T15:34:21Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478578316",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478578316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478588317",
      "pull_request_review_id": 3377790750,
      "id": 2478588317,
      "node_id": "PRRC_kwDOABII586TvEGd",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the task’s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 194,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I was also wondering what this was meant to so, especially since there isn't any test coverage for it.",
      "created_at": "2025-10-30T15:37:37Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478588317",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478588317"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 194,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478599236",
      "pull_request_review_id": 3377790750,
      "id": 2478599236,
      "node_id": "PRRC_kwDOABII586TvGxE",
      "diff_hunk": "@@ -49,83 +50,6 @@ using common::InvalidPortErrMsg;\n /** Maximum size of http request (request line + headers) */\n static const size_t MAX_HEADERS_SIZE = 8192;\n \n-/** HTTP request work item */\n-class HTTPWorkItem final : public HTTPClosure",
      "path": "src/httpserver.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Is there a way to do this final threadpool migration in smaller steps?",
      "created_at": "2025-10-30T15:40:46Z",
      "updated_at": "2025-10-30T16:05:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2478599236",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2478599236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479418360",
      "pull_request_review_id": 3401492921,
      "id": 2479418360,
      "node_id": "PRRC_kwDOABII586TyOv4",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }\n+};\n+\n+// Waits for a future to complete. Increments 'fail_counter' if the expected exception is thrown.\n+static void GetFuture(std::future<void>& future, uint32_t& fail_counter)\n+{\n+    try {\n+        future.get();\n+    } catch (const ExpectedException&) {\n+        fail_counter++;\n+    } catch (...) {\n+        assert(false && \"Unexpected exception type\");\n+    }\n+}\n+\n+// Global thread pool for fuzzing. Persisting it across iterations prevents\n+// the excessive thread creation/destruction overhead that can lead to\n+// instability in the fuzzing environment.\n+// This is also how we use it in the app's lifecycle.\n+ThreadPool g_pool{\"fuzz\"};\n+// Global to verify we always have the same number of threads.\n+size_t g_num_workers = 3;\n+\n+static void setup_threadpool_test()\n+{\n+    // Disable logging entirely. It seems to cause memory leaks.",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 59,
      "original_position": 53,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": 2461223410,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It is a known issue. The pcp fuzz test does it too for the same reason (in an undocumented manner). I only document it properly so we don't forget this exists. Feel free to investigate it in a separate issue/PR. I'm not planning to do it. It is not an issue of the code introduced in this PR.",
      "created_at": "2025-10-30T20:22:43Z",
      "updated_at": "2025-10-30T20:22:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2479418360",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479418360"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 59,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479440054",
      "pull_request_review_id": 3401522899,
      "id": 2479440054,
      "node_id": "PRRC_kwDOABII586TyUC2",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {",
      "path": "src/util/threadpool.h",
      "position": 65,
      "original_position": 66,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477455551,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yes, we do. The reason is explained there. All thread busy, a new task arrives so notifications goes unnoticed, then threads finish processing and sleep. Loosing the new task wake up notification, not running the new task and sleeping until a new one gets submitted. There is a test exercising this exact behavior.",
      "created_at": "2025-10-30T20:31:35Z",
      "updated_at": "2025-10-30T20:31:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2479440054",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479440054"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479467969",
      "pull_request_review_id": 3401568491,
      "id": 2479467969,
      "node_id": "PRRC_kwDOABII586Tya3B",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();",
      "path": "src/util/threadpool.h",
      "position": 139,
      "original_position": 135,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477415169,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "That is part of the possible future experimentations written in the PR description. Goal is to keep the same synchronization mechanisms we had in the http server code.",
      "created_at": "2025-10-30T20:43:48Z",
      "updated_at": "2025-10-30T20:43:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2479467969",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479467969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 135,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479480850",
      "pull_request_review_id": 3401590644,
      "id": 2479480850,
      "node_id": "PRRC_kwDOABII586TyeAS",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 89,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477491505,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "`num_tasks` is an int. That would require casting it to size_t.",
      "created_at": "2025-10-30T20:49:11Z",
      "updated_at": "2025-10-30T20:49:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2479480850",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479480850"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479509680",
      "pull_request_review_id": 3401634174,
      "id": 2479509680,
      "node_id": "PRRC_kwDOABII586TylCw",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);",
      "path": "src/util/threadpool.h",
      "position": 105,
      "original_position": 106,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477631031,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This decision was on purpose. To be able to assert and abort the program if a negative number is provided. A negative integer to size_t conversion would be bad.",
      "created_at": "2025-10-30T21:01:41Z",
      "updated_at": "2025-10-30T21:01:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2479509680",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2479509680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 103,
      "original_start_line": 104,
      "start_side": "RIGHT",
      "line": 105,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481025343",
      "pull_request_review_id": 3403702771,
      "id": 2481025343,
      "node_id": "PRRC_kwDOABII586T4XE_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.",
      "path": "src/util/threadpool.h",
      "position": 101,
      "original_position": 102,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/33689/commits/e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a:\r\n\r\nCan we enforce this rule using a thread-local variable?",
      "created_at": "2025-10-31T10:55:57Z",
      "updated_at": "2025-10-31T12:48:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2481025343",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481025343"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481400847",
      "pull_request_review_id": 3404254607,
      "id": 2481400847,
      "node_id": "PRRC_kwDOABII586T5ywP",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }\n+};\n+\n+// Waits for a future to complete. Increments 'fail_counter' if the expected exception is thrown.\n+static void GetFuture(std::future<void>& future, uint32_t& fail_counter)\n+{\n+    try {\n+        future.get();\n+    } catch (const ExpectedException&) {\n+        fail_counter++;\n+    } catch (...) {\n+        assert(false && \"Unexpected exception type\");\n+    }\n+}\n+\n+// Global thread pool for fuzzing. Persisting it across iterations prevents\n+// the excessive thread creation/destruction overhead that can lead to\n+// instability in the fuzzing environment.\n+// This is also how we use it in the app's lifecycle.\n+ThreadPool g_pool{\"fuzz\"};\n+// Global to verify we always have the same number of threads.\n+size_t g_num_workers = 3;\n+\n+static void setup_threadpool_test()\n+{\n+    // Disable logging entirely. It seems to cause memory leaks.",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 59,
      "original_position": 53,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": 2461223410,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "k, thanks, please resolve the comment",
      "created_at": "2025-10-31T13:22:15Z",
      "updated_at": "2025-10-31T13:35:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2481400847",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481400847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 59,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481401944",
      "pull_request_review_id": 3404254607,
      "id": 2481401944,
      "node_id": "PRRC_kwDOABII586T5zBY",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();",
      "path": "src/util/threadpool.h",
      "position": 139,
      "original_position": 135,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477415169,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Goal is to keep the same synchronization mechanisms we had in the http server code\r\n\r\nWhat is the reason for that, isn't the goal to have a reusable `ThreadPool`?",
      "created_at": "2025-10-31T13:22:33Z",
      "updated_at": "2025-10-31T13:35:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2481401944",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481401944"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 135,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481430614",
      "pull_request_review_id": 3404254607,
      "id": 2481430614,
      "node_id": "PRRC_kwDOABII586T56BW",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {",
      "path": "src/util/threadpool.h",
      "position": 65,
      "original_position": 66,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477455551,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can you point me to the test that fails please? I have removed it, ran the tests added in this PR and they all passed.",
      "created_at": "2025-10-31T13:31:53Z",
      "updated_at": "2025-10-31T13:35:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2481430614",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481430614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 65,
      "original_line": 66,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481432376",
      "pull_request_review_id": 3404254607,
      "id": 2481432376,
      "node_id": "PRRC_kwDOABII586T56c4",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 89,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477491505,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Please see my suggestions above, it's a `size_t` there",
      "created_at": "2025-10-31T13:32:19Z",
      "updated_at": "2025-10-31T13:35:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2481432376",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481432376"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481442031",
      "pull_request_review_id": 3404254607,
      "id": 2481442031,
      "node_id": "PRRC_kwDOABII586T58zv",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);",
      "path": "src/util/threadpool.h",
      "position": 105,
      "original_position": 106,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477631031,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Where would we be getting negative numbers from?\r\nIf we care about the value being in a certain range, we could validate that instead:\r\n```C++\r\n        assert(num_workers > 0 && num_workers <= MAX_WORKER_COUNT);\r\n```",
      "created_at": "2025-10-31T13:34:28Z",
      "updated_at": "2025-10-31T13:35:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2481442031",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2481442031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 103,
      "original_start_line": 104,
      "start_side": "RIGHT",
      "line": 105,
      "original_line": 106,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2513309951",
      "pull_request_review_id": 3446857554,
      "id": 2513309951,
      "node_id": "PRRC_kwDOABII586VzhD_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.",
      "path": "src/util/threadpool.h",
      "position": 101,
      "original_position": 102,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2481025343,
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "i remember that in the past we had tons of issues with thread-local variables. They've been a pain in the ass on some platforms, and decided to not use them except for one case. Not sure if this is still the case, but if not, this needs to be updated:\r\nhttps://github.com/bitcoin/bitcoin/blob/master/src/util/threadnames.cpp#L39",
      "created_at": "2025-11-11T08:37:13Z",
      "updated_at": "2025-11-11T08:37:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2513309951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2513309951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2513507443",
      "pull_request_review_id": 3447130977,
      "id": 2513507443,
      "node_id": "PRRC_kwDOABII586V0RRz",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.",
      "path": "src/util/threadpool.h",
      "position": 101,
      "original_position": 102,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2481025343,
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "There's also our `thread_local` clang-tidy plugin: https://github.com/bitcoin/bitcoin/tree/master/contrib/devtools/bitcoin-tidy.",
      "created_at": "2025-11-11T09:35:06Z",
      "updated_at": "2025-11-11T09:35:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2513507443",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2513507443"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514271610",
      "pull_request_review_id": 3448117677,
      "id": 2514271610,
      "node_id": "PRRC_kwDOABII586V3L16",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.",
      "path": "src/util/threadpool.h",
      "position": 101,
      "original_position": 102,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2481025343,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> There's also our `thread_local` clang-tidy plugin: https://github.com/bitcoin/bitcoin/tree/master/contrib/devtools/bitcoin-tidy.\r\n\r\nI don't see why we would need a thread local variable with a non-trivial desctructor to implement this.\r\n\r\n> i remember that in the past we had tons of issues with thread-local variables. They've been a pain in the ass on some platforms, and decided to not use them except for one case. Not sure if this is still the case, but if not, this needs to be updated:\r\n> https://github.com/bitcoin/bitcoin/blob/master/src/util/threadnames.cpp#L39\r\n\r\nI think it would be fine in this case because the use is limited. A simple thread-local boolean and assertion should be enough.\r\n\r\nI don't have a strong opinion here; I just think it would be better to programmatically enforce the rule that certain functions should not be called from Worker Threads.",
      "created_at": "2025-11-11T13:38:24Z",
      "updated_at": "2025-11-11T13:38:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2514271610",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2514271610"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2525171514",
      "pull_request_review_id": 3461993428,
      "id": 2525171514,
      "node_id": "PRRC_kwDOABII586Wgw86",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.",
      "path": "src/util/threadpool.h",
      "position": 101,
      "original_position": 102,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2481025343,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Can we enforce this rule using a thread-local variable?\r\n\r\nAs `m_workers` is guarded, we could enforce it in a simple way:\r\n```c++\r\nfor (const auto& worker : m_workers) assert(worker.get_id() != std::this_thread::get_id());\r\n```",
      "created_at": "2025-11-13T22:45:23Z",
      "updated_at": "2025-11-17T15:21:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2525171514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2525171514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534425987",
      "pull_request_review_id": 3461993428,
      "id": 2534425987,
      "node_id": "PRRC_kwDOABII586XEEWD",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 12,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477334363,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "renamed.",
      "created_at": "2025-11-17T14:58:58Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534425987",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534425987"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534438190",
      "pull_request_review_id": 3461993428,
      "id": 2534438190,
      "node_id": "PRRC_kwDOABII586XEHUu",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 114,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477395665,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm not sure about including extra dependencies on a low-level class for tiny readability improvements. But I'm not really opposed to this one, so done as suggested.",
      "created_at": "2025-11-17T15:02:16Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534438190",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534438190"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 114,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534442998",
      "pull_request_review_id": 3461993428,
      "id": 2534442998,
      "node_id": "PRRC_kwDOABII586XEIf2",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 75,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477534828,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2025-11-17T15:03:39Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534442998",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534442998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 75,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534443997",
      "pull_request_review_id": 3461993428,
      "id": 2534443997,
      "node_id": "PRRC_kwDOABII586XEIvd",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 51,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477550353,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-11-17T15:03:50Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534443997",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534443997"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 51,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534447295",
      "pull_request_review_id": 3461993428,
      "id": 2534447295,
      "node_id": "PRRC_kwDOABII586XEJi_",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 91,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477663057,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2025-11-17T15:04:35Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534447295",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534447295"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534465728",
      "pull_request_review_id": 3461993428,
      "id": 2534465728,
      "node_id": "PRRC_kwDOABII586XEODA",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 22,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477992659,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "we would probably still need the context string to differentiate between the initial `BlockWorkers()` calls vs the final result `WaitFor`. Should re-check if `BOOST_REQUIRE` prints the stack trace; most likely it doesn't and that was the reason behind my past-self added the context string.",
      "created_at": "2025-11-17T15:09:39Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534465728",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534465728"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534473189",
      "pull_request_review_id": 3461993428,
      "id": 2534473189,
      "node_id": "PRRC_kwDOABII586XEP3l",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 62,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478145839,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Instead of doing it for all the test cases, added another case that exercises the contention.",
      "created_at": "2025-11-17T15:11:49Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534473189",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534473189"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 62,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534474010",
      "pull_request_review_id": 3461993428,
      "id": 2534474010,
      "node_id": "PRRC_kwDOABII586XEQEa",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 123,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478192040,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2025-11-17T15:12:03Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534474010",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534474010"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 117,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534476766",
      "pull_request_review_id": 3461993428,
      "id": 2534476766,
      "node_id": "PRRC_kwDOABII586XEQve",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);\n+\n+        // Now process manually\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.ProcessTask();\n+        }\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+        blocker.set_value();\n+        threadPool.Stop();\n+        WaitFor(blocking_tasks, \"Failure waiting for test6 blocking task futures\");\n+    }\n+\n+    // Test case 7, recursive submission of tasks.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> signal;\n+        threadPool.Submit([&]() {\n+            threadPool.Submit([&]() {\n+                signal.set_value();\n+            });\n+        });\n+\n+        signal.get_future().wait();\n+        threadPool.Stop();\n+    }\n+\n+    // Test case 8, submit a task when all threads are busy and then stop the pool.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test8 blocking tasks enabled\");\n+\n+        // Submit an extra task that should execute once a worker is free\n+        std::future<bool> future = threadPool.Submit([]() { return true; });\n+\n+        // At this point, all workers are blocked, and the extra task is queued\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\n+\n+        // Wait a short moment before unblocking the threads to mimic a concurrent shutdown\n+        std::thread thread_unblocker([&blocker]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{300});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 252,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478278715,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2025-11-17T15:12:51Z",
      "updated_at": "2025-11-17T15:21:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534476766",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534476766"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534489773",
      "pull_request_review_id": 3461993428,
      "id": 2534489773,
      "node_id": "PRRC_kwDOABII586XET6t",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 47,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478379002,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> What is the reason for the heavy use of promises? Does it have any advantage compared to C++20 concurrency primitives? \r\n\r\nI wrote this code 4 years ago. When the project was using C++11 or C++14 (I don't recall which one was).\r\n\r\n> This seems to me like a barebones implementation for an std::latch. Can we use that instead?\r\n\r\nProbably. But I don't think it matters much at the end. Will check it. Thanks.",
      "created_at": "2025-11-17T15:16:03Z",
      "updated_at": "2025-11-17T15:21:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534489773",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534489773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 26,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534492438",
      "pull_request_review_id": 3461993428,
      "id": 2534492438,
      "node_id": "PRRC_kwDOABII586XEUkW",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 168,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478410042,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2025-11-17T15:16:45Z",
      "updated_at": "2025-11-17T15:21:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534492438",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534492438"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 168,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534496697",
      "pull_request_review_id": 3461993428,
      "id": 2534496697,
      "node_id": "PRRC_kwDOABII586XEVm5",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 170,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478427757,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> do we need a vector here of can we just consume whatever we just submitted?\r\n\r\nConsuming right away would wait for the task to be executed; we want to exercise some concurrency too.",
      "created_at": "2025-11-17T15:18:03Z",
      "updated_at": "2025-11-17T15:21:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534496697",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534496697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534497887",
      "pull_request_review_id": 3461993428,
      "id": 2534497887,
      "node_id": "PRRC_kwDOABII586XEV5f",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 188,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478578316,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Splitted.",
      "created_at": "2025-11-17T15:18:23Z",
      "updated_at": "2025-11-17T15:21:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534497887",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534497887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534504879",
      "pull_request_review_id": 3461993428,
      "id": 2534504879,
      "node_id": "PRRC_kwDOABII586XEXmv",
      "diff_hunk": "@@ -49,83 +50,6 @@ using common::InvalidPortErrMsg;\n /** Maximum size of http request (request line + headers) */\n static const size_t MAX_HEADERS_SIZE = 8192;\n \n-/** HTTP request work item */\n-class HTTPWorkItem final : public HTTPClosure",
      "path": "src/httpserver.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "in_reply_to_id": 2478599236,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I guess you wrote this first and then answered yourself in your final comment; which is basically a long version of the PR's \"Note 2\" description.",
      "created_at": "2025-11-17T15:20:28Z",
      "updated_at": "2025-11-17T15:21:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534504879",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534504879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534655978",
      "pull_request_review_id": 3473454632,
      "id": 2534655978,
      "node_id": "PRRC_kwDOABII586XE8fq",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(WAIT_TIMEOUT) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 73,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Continuing the thread from https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477534828:\n\n```patch\n#include <common/system.h>\n+#include <test/util/setup_common.h>\n#include <util/string.h>\n```\n\n```suggestion \n    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, HasReason{\"No active workers; cannot accept new tasks\"});\n```\n\n",
      "created_at": "2025-11-17T16:01:10Z",
      "updated_at": "2025-11-17T17:00:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534655978",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534655978"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534663536",
      "pull_request_review_id": 3473454632,
      "id": 2534663536,
      "node_id": "PRRC_kwDOABII586XE-Vw",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 91,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477663057,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Can you please apply this to the other cases as well?",
      "created_at": "2025-11-17T16:03:22Z",
      "updated_at": "2025-11-17T17:00:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534663536",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534663536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534675487",
      "pull_request_review_id": 3473454632,
      "id": 2534675487,
      "node_id": "PRRC_kwDOABII586XFBQf",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 27,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Continuing the discussion in https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2477876362, could we randomize this on the call-site, so that we can exercise cases when we have other than 3 workers (to make sure we don't introduce an accidental bias), i.e. in the test it would be something like:\r\n```C++\r\n    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n```",
      "created_at": "2025-11-17T16:06:40Z",
      "updated_at": "2025-11-17T17:02:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534675487",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534675487"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534738205",
      "pull_request_review_id": 3473454632,
      "id": 2534738205,
      "node_id": "PRRC_kwDOABII586XFQkd",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 22,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477992659,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The original failure looks like this: \n> unknown location:0: fatal error: in \"threadpool_tests/submit_tasks_complete_successfully\": std::runtime_error: Timeout waiting for: test1 task, task index 0\n>\n>test/threadpool_tests.cpp:77: last checkpoint: \"submit_tasks_complete_successfully\" test entry\n\nIf you want the extra method to not mask the failure stack, we can make it a macro, like we did with e.g. https://github.com/bitcoin/bitcoin/blob/cc5dda1de333cf7aa10e2237ee2c9221f705dbd9/src/test/headers_sync_chainwork_tests.cpp#L22-L42\n\nWhich would look like:\n```C++\n#define WAIT_FOR(futures)                                                         \\\n    do {                                                                          \\\n        for (const auto& f : futures) {                                           \\\n            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n        }                                                                         \\\n    } while (0)\n```\nand a failure stack would be more helpful:\n> test/threadpool_tests.cpp:96: fatal error: in \"threadpool_tests/submit_tasks_complete_successfully\": critical check f.wait_for(WAIT_TIMEOUT) != std::future_status::ready has failed\n\nwhich would point to the exact call site instead of the helper method: https://github.com/bitcoin/bitcoin/blob/41c99a2e3ef4c1cddaaa313a454009a141a6a782/src/test/threadpool_tests.cpp#L96\n",
      "created_at": "2025-11-17T16:25:05Z",
      "updated_at": "2025-11-17T17:00:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534738205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534738205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534746780",
      "pull_request_review_id": 3473454632,
      "id": 2534746780,
      "node_id": "PRRC_kwDOABII586XFSqc",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 123,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478192040,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I still see init + reserve + loop + emplace in most tests, could we apply to the rest as well?",
      "created_at": "2025-11-17T16:27:30Z",
      "updated_at": "2025-11-17T17:00:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534746780",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534746780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 117,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 123,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534813432",
      "pull_request_review_id": 3473454632,
      "id": 2534813432,
      "node_id": "PRRC_kwDOABII586XFi74",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        int counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter += 1;\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 170,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2478427757,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> we want to exercise some concurrency too\r\n\r\nYou're right, that's better indeed.\r\nMy suggestion updated to keep the vector\r\n\r\n```C++\r\n// Test 5, throw exceptions and catch it on the consumer side\r\nBOOST_AUTO_TEST_CASE(task_exception_propagates_to_future)\r\n{\r\n    ThreadPool threadPool(\"exception_test\");\r\n    threadPool.Start(NUM_WORKERS_DEFAULT);\r\n\r\n    const auto make_err{[&](size_t n) { return strprintf(\"error on thread #%s\", n); }};\r\n\r\n    const auto num_tasks{1 + m_rng.randrange<size_t>(20)};\r\n    std::vector<std::future<void>> futures(num_tasks);\r\n    for (size_t i{0}; i < num_tasks; ++i) {\r\n        futures[i] = threadPool.Submit([&make_err, i] { throw std::runtime_error(make_err(i)); });\r\n    }\r\n\r\n    for (size_t i{0}; i < num_tasks; ++i) {\r\n        BOOST_CHECK_EXCEPTION(futures[i].get(), std::runtime_error, HasReason{make_err(i)});\r\n    }\r\n}\r\n```",
      "created_at": "2025-11-17T16:46:25Z",
      "updated_at": "2025-11-17T17:00:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534813432",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534813432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534845237",
      "pull_request_review_id": 3473454632,
      "id": 2534845237,
      "node_id": "PRRC_kwDOABII586XFqs1",
      "diff_hunk": "@@ -49,83 +50,6 @@ using common::InvalidPortErrMsg;\n /** Maximum size of http request (request line + headers) */\n static const size_t MAX_HEADERS_SIZE = 8192;\n \n-/** HTTP request work item */\n-class HTTPWorkItem final : public HTTPClosure",
      "path": "src/httpserver.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "in_reply_to_id": 2478599236,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Not exactly sure what you mean by that - `Note 2` does seem like a good idea to me and it's probably similar to what I meant. It would help the review process to gain more confidence in the implementation if we migrated away in smaller steps, documenting how the tests we add for the old implementation also pass when we switch over to the new implementation.",
      "created_at": "2025-11-17T16:55:40Z",
      "updated_at": "2025-11-17T17:00:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2534845237",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2534845237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535106877",
      "pull_request_review_id": 3474032207,
      "id": 2535106877,
      "node_id": "PRRC_kwDOABII586XGqk9",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(WAIT_TIMEOUT) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 73,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534655978,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Missed to fully answer your previous comment related to this change, sorry. I didn't do it to not include `setup_common.h`, as it comes with way more dependencies than just `HasReason()`.\r\n\r\nThe idea is to try to reduce large Bitcoin-Core repo dependencies in this low level class, mainly when they do not add much value (this one just let us remove two lines of code with no behavior change), so this class and tests can be easily used elsewhere.\r\nWe could move `HasReason()` to another test utils file too but I don't think it worth the effort.",
      "created_at": "2025-11-17T18:23:36Z",
      "updated_at": "2025-11-17T18:23:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2535106877",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535106877"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535227041",
      "pull_request_review_id": 3474184625,
      "id": 2535227041,
      "node_id": "PRRC_kwDOABII586XHH6h",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 27,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534675487,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "While I like the extra coverage, I’m not fully convinced about adding this bit of non-determinism. That’s why I didn’t include it in the last push. It could make reproducing failures trickier, since we’d be adding another dimension to all tests; core counts behave differently across environments.\r\n\r\nProbably a good middle ground could be adding a separate test that picks a random worker count and prints the available core count on failure. That gives us some extra coverage without making the other tests harder to debug, and it makes it clear what’s needed to reproduce those specific failures.",
      "created_at": "2025-11-17T19:09:51Z",
      "updated_at": "2025-11-17T19:09:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2535227041",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535227041"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535258707",
      "pull_request_review_id": 3474230165,
      "id": 2535258707,
      "node_id": "PRRC_kwDOABII586XHPpT",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(WAIT_TIMEOUT) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 73,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534655978,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This is needed in multiple methods here, it would simplify the diff and it provides a higher level primitive instead of repeating and reimplementing what we have already built a helper for.\r\nNot sure why we'd want to reduce dependencies here, what's the advantage of that? I value clean code a lot more, especially for a test that doesn't even have performance requirements?\r\nWe can of course move `HasReason` in a separate PR, but I think we can use it here before that as well.",
      "created_at": "2025-11-17T19:21:27Z",
      "updated_at": "2025-11-17T19:21:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2535258707",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535258707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535271000",
      "pull_request_review_id": 3474245832,
      "id": 2535271000,
      "node_id": "PRRC_kwDOABII586XHSpY",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 27,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534675487,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It's not about coverage, but rather avoiding bias that we may introduce by hard-coding arbitrary values.\r\n\r\nI prefer a situation that is \"hard to reproduce\" over something that we won't find because of hard-coded values.\r\n\r\n> core counts behave differently across environments\r\n\r\nExactly, let's exercise those differences, that's exactly what we want from our tests, to ruthlessly try to break the code, right?",
      "created_at": "2025-11-17T19:25:34Z",
      "updated_at": "2025-11-17T19:25:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2535271000",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535271000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535364299",
      "pull_request_review_id": 3474371204,
      "id": 2535364299,
      "node_id": "PRRC_kwDOABII586XHpbL",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(WAIT_TIMEOUT) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 73,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534655978,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Not sure why we'd want to reduce dependencies here, what's the advantage of that?\r\n\r\nI wrote it above; the idea is to be able to use this low-level class and tests elsewhere, outside the project, just by pulling a few files without dragging in all our unit test framework machinery, which has tons other dependencies.\r\nIf we were talking about a substantial improvement, I’d agree with you, but here it’s just a 2-line diff with no behavior change. And for me, that makes the rationale for including it not very convincing.",
      "created_at": "2025-11-17T20:03:18Z",
      "updated_at": "2025-11-17T20:03:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2535364299",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535364299"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535431623",
      "pull_request_review_id": 3474457988,
      "id": 2535431623,
      "node_id": "PRRC_kwDOABII586XH53H",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 27,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534675487,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> Exactly, let's exercise those differences, that's exactly what we want from our tests, to ruthlessly try to break the code, right?\r\n\r\nWe’re going to side-track the discussion a bit, but I’m not sure I completely agree.\r\nGenerally, I see unit tests as being meant for correctness, not stress testing. For example, we want to ensure certain behavior is always retained — it’s not about trying to break the code in a non-deterministic way. That’s what fuzz tests are for, where we randomize inputs. I’d also argue that we don’t yet have a proper heavy-load testing framework either.\r\n\r\nStill, IIRC, our current fuzzing framework has some limitations; the engine runs the function faster than the OS can release the threads, which causes memory usage to increase non-stop (at least that’s what I remember from a good number of experiments we did a few months ago).\r\n\r\nIn any case, this is just a general software development sidetrack… sorry, couldn’t contain myself.\r\nWe could still have a specific test case for this or dynamically adapt the number of workers if others are happy with that too.",
      "created_at": "2025-11-17T20:31:27Z",
      "updated_at": "2025-11-17T20:31:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2535431623",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535431623"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535484827",
      "pull_request_review_id": 3474521087,
      "id": 2535484827,
      "node_id": "PRRC_kwDOABII586XIG2b",
      "diff_hunk": "@@ -49,83 +50,6 @@ using common::InvalidPortErrMsg;\n /** Maximum size of http request (request line + headers) */\n static const size_t MAX_HEADERS_SIZE = 8192;\n \n-/** HTTP request work item */\n-class HTTPWorkItem final : public HTTPClosure",
      "path": "src/httpserver.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "in_reply_to_id": 2478599236,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I imagine the problem is that you haven't compared the current http code with the `ThreadPool` code, which is pretty much the same but properly documented and test covered. That's one of the reasons behind the not modernization of the underlying sync mechanism in this PR, and why I added the \"Note 2\" paragraph as well as wrote https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3444568607.\r\n\r\nLook at the current `WorkQueue`:\r\n\r\n```c++\r\nvoid Run() EXCLUSIVE_LOCKS_REQUIRED(!cs)\r\n    {\r\n        while (true) {\r\n            std::unique_ptr<WorkItem> i;\r\n            {\r\n                WAIT_LOCK(cs, lock);\r\n                while (running && queue.empty())\r\n                    cond.wait(lock);\r\n                if (!running && queue.empty())\r\n                    break;\r\n                i = std::move(queue.front());\r\n                queue.pop_front();\r\n            }\r\n            (*i)();\r\n        }\r\n    }\r\n```\r\n\r\nAnd this is the ThreadPool (stripping all comments)\r\n\r\n```c++\r\n\r\nvoid WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n    {\r\n        WAIT_LOCK(m_mutex, wait_lock);\r\n        for (;;) {\r\n            std::packaged_task<void()> task;\r\n            {\r\n                if (!m_interrupt && m_work_queue.empty()) {\r\n                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\r\n                }\r\n\r\n                if (m_interrupt && m_work_queue.empty()) return;\r\n               \r\n                task = std::move(m_work_queue.front());\r\n                m_work_queue.pop();\r\n            }\r\n\r\n            REVERSE_LOCK(wait_lock, m_mutex);\r\n            task();\r\n        }\r\n    }\r\n```\r\n\r\n------------------------\r\n\r\nIn any case, since most reviewers seem ok to proceed with the current approach, I think it’s more productive to keep working on it rather than continue circling around this topic, even if it’s not to your taste.",
      "created_at": "2025-11-17T20:54:32Z",
      "updated_at": "2025-11-17T20:55:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2535484827",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2535484827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2539707339",
      "pull_request_review_id": 3479784124,
      "id": 2539707339,
      "node_id": "PRRC_kwDOABII586XYNvL",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 91,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477663057,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2025-11-18T21:29:52Z",
      "updated_at": "2025-11-18T21:29:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2539707339",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2539707339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2539707584",
      "pull_request_review_id": 3479784398,
      "id": 2539707584,
      "node_id": "PRRC_kwDOABII586XYNzA",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 22,
      "commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477992659,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2025-11-18T21:30:10Z",
      "updated_at": "2025-11-18T21:30:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2539707584",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2539707584"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 14,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 22,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541727790",
      "pull_request_review_id": 3482342931,
      "id": 2541727790,
      "node_id": "PRRC_kwDOABII586Xf7Au",
      "diff_hunk": "@@ -0,0 +1,271 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) {\n+            err = true;\n+        }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 91,
      "commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "original_commit_id": "e1eb4cd3a5eb192cd6d9ee5d255688c06ab2089a",
      "in_reply_to_id": 2477663057,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Thanks. Currently all `fetch_add` calls use `memory_order_relaxed`, which makes sense since we don't want the counter itself to act as a barrier for other data, but the corresponding `load`s still use the default `std::memory_order_seq_cst`.\r\nSince external synchronization (e.g. via `WAIT_FOR` calls) already provide happens-before relationships, I don't think the memory ordering of  `load` operations should be sequential.\r\nI don't think it's a bug, but would likely be more consistent if we used the same `memory_order_relaxed` on the loads as well. \r\nTo avoid accidental synchronization, can we use `memory_order_relaxed` throughout (for `fetch_add ` & `load`)?\r\nWhat do you think?",
      "created_at": "2025-11-19T12:06:13Z",
      "updated_at": "2025-11-19T18:03:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2541727790",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541727790"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541753444",
      "pull_request_review_id": 3482342931,
      "id": 2541753444,
      "node_id": "PRRC_kwDOABII586XgBRk",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 27,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534675487,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> We could still have a specific test case for this or dynamically adapt the number of workers\r\n\r\nHow would that solve the problem I highlighted, namely that 3 is a special value that introduces needless bias? \r\nWe could theoretically have a bug that only manifests when the worker count equals (or exceeds) the CPU count (but maybe only happens for exceptions), which would never happen with 3 workers, but would sometimes fail correctly if we randomize instead of hard-code magic values.",
      "created_at": "2025-11-19T12:14:02Z",
      "updated_at": "2025-11-19T18:03:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2541753444",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541753444"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 27,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541760411",
      "pull_request_review_id": 3482342931,
      "id": 2541760411,
      "node_id": "PRRC_kwDOABII586XgC-b",
      "diff_hunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.",
      "path": "src/test/threadpool_tests.cpp",
      "position": 37,
      "original_position": 23,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "258518d880e81938fcd9672b37bc640e8a06c930",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "we already have individual test cases, there's no need to duplicate them here",
      "created_at": "2025-11-19T12:16:06Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2541760411",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541760411"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 26,
      "original_start_line": 12,
      "start_side": "RIGHT",
      "line": 37,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541764350",
      "pull_request_review_id": 3482342931,
      "id": 2541764350,
      "node_id": "PRRC_kwDOABII586XgD7-",
      "diff_hunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(WAIT_TIMEOUT) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 73,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "adb891184ee341e5107ece8f592939ead81d7a99",
      "in_reply_to_id": 2534655978,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> the idea is to be able to use this low-level class and tests elsewhere\r\n\r\nI haven't heard that argument before, why would we care about other projects wanting to copy-paste our code?\r\nLet them refactor, but we should write the best code for *our* project.\r\n\r\n> but here it’s just a 2-line diff\r\n\r\nIt's not, please see my remaining suggestions many of which haven't been applied yet.\r\n\r\n-----\r\n\r\nAlso, since we're ignoring the return value here, we should likely cast to void here:\r\n```suggestion\r\n    BOOST_CHECK_EXCEPTION((void)threadPool.Submit([] { return false; }), std::runtime_error, HasReason{\"No active workers; cannot accept new tasks\"});\r\n```",
      "created_at": "2025-11-19T12:17:15Z",
      "updated_at": "2025-11-19T18:03:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2541764350",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541764350"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541801771",
      "pull_request_review_id": 3482342931,
      "id": 2541801771,
      "node_id": "PRRC_kwDOABII586XgNEr",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Enqueues a new task for asynchronous execution.\n+     *\n+     * Returns a `std::future` that provides the task’s result or propagates",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 150,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: for consistency with other spelling, e.g. https://github.com/bitcoin/bitcoin/blob/2de0ce5cd85e1b99e318883964df318ffb615fe4/src/util/threadpool.h#L94\r\n\r\n```suggestion\r\n     * Returns a `std::future` that provides the task's result or propagates\r\n```",
      "created_at": "2025-11-19T12:27:00Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2541801771",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541801771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541836752",
      "pull_request_review_id": 3482342931,
      "id": 2541836752,
      "node_id": "PRRC_kwDOABII586XgVnQ",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "some of these includes seem unused, can you please check?\r\n\r\n<details>\r\n<summary>iwyu_tool.py</summary>\r\n\r\n```\r\n python3 /opt/homebrew/bin/iwyu_tool.py -p build-iwyu src/test/threadpool_tests.cpp -- -Xiwyu --cxx17ns -Xiwyu --mapping_file=$PWD/contrib/devtools/iwyu/bitcoin.core.i\r\nmp -Xiwyu --max_line_length=160 -Xiwyu --check_also=$PWD/src/util/threadpool.h\r\n\r\n/Users/lorinc/IdeaProjects/bitcoin/src/util/threadpool.h should add these lines:\r\n#include <__vector/vector.h>   // for vector\r\n\r\n/Users/lorinc/IdeaProjects/bitcoin/src/util/threadpool.h should remove these lines:\r\n- #include <util/threadinterrupt.h>  // lines 13-13\r\n- #include <atomic>  // lines 16-16\r\n- #include <functional>  // lines 19-19\r\n- #include <memory>  // lines 21-21\r\n- #include <vector>  // lines 26-26\r\n\r\nThe full include-list for /Users/lorinc/IdeaProjects/bitcoin/src/util/threadpool.h:\r\n#include <__vector/vector.h>   // for vector\r\n#include <sync.h>              // for UniqueLock, EXCLUSIVE_LOCKS_REQUIRED, LOCK, WITH_LOCK, GUARDED_BY, Mutex, REVERSE_LOCK, WAIT_LOCK\r\n#include <tinyformat.h>        // for format, formatTruncated, formatValue, makeFormatList, strprintf\r\n#include <util/check.h>        // for assert, inline_assertion_check, Assume\r\n#include <util/string.h>       // for string, basic_string, basic_string_view\r\n#include <util/thread.h>       // for TraceThread\r\n#include <algorithm>           // for move\r\n#include <condition_variable>  // for condition_variable\r\n#include <cstddef>             // for size_t\r\n#include <future>              // for packaged_task\r\n#include <queue>               // for queue\r\n#include <stdexcept>           // for runtime_error\r\n#include <thread>              // for thread, get_id, operator==, __thread_id\r\n#include <utility>             // for move, forward\r\n---\r\n\r\n/Users/lorinc/IdeaProjects/bitcoin/src/test/threadpool_tests.cpp should add these lines:\r\n#include <__vector/vector.h>                                        // for vector\r\n#include <algorithm>                                                // for max\r\n#include <atomic>                                                   // for atomic, memory_order_relaxed, memory_order_acquire, memory_order_release\r\n#include <boost/preprocessor/arithmetic/limits/dec_256.hpp>         // for BOOST_PP_DEC_1, BOOST_PP_DEC_2, BOOST_PP_DEC_128, BOOST_PP_DEC_16, BOOST_PP_DEC_3\r\n#include <boost/preprocessor/comparison/limits/not_equal_256.hpp>   // for BOOST_PP_NOT_EQUAL_1, BOOST_PP_NOT_EQUAL_CHECK_BOOST_PP_NOT_EQUAL_1\r\n#include <boost/preprocessor/control/expr_iif.hpp>                  // for BOOST_PP_EXPR_IIF_1\r\n#include <boost/preprocessor/control/iif.hpp>                       // for BOOST_PP_IIF_1, BOOST_PP_IIF_0\r\n#include <boost/preprocessor/detail/limits/auto_rec_256.hpp>        // for BOOST_PP_NODE_ENTRY_256\r\n#include <boost/preprocessor/logical/compl.hpp>                     // for BOOST_PP_COMPL_0\r\n#include <boost/preprocessor/logical/limits/bool_256.hpp>           // for BOOST_PP_BOOL_0, BOOST_PP_BOOL_1, BOOST_PP_BOOL_2\r\n#include <boost/preprocessor/repetition/detail/limits/for_256.hpp>  // for BOOST_PP_FOR_0, BOOST_PP_FOR_1, BOOST_PP_FOR_127, BOOST_PP_FOR_15, BOOST_PP_FOR_3\r\n#include <boost/preprocessor/repetition/for.hpp>                    // for BOOST_PP_FOR_CHECK_BOOST_PP_NIL\r\n#include <boost/preprocessor/seq/limits/elem_256.hpp>               // for BOOST_PP_SEQ_ELEM_0\r\n#include <boost/preprocessor/seq/limits/size_256.hpp>               // for BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_2, BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_3\r\n#include <boost/preprocessor/tuple/elem.hpp>                        // for BOOST_PP_TUPLE_ELEM_O_3\r\n#include <boost/preprocessor/variadic/limits/elem_64.hpp>           // for BOOST_PP_VARIADIC_ELEM_3\r\n#include <boost/test/tools/assertion_result.hpp>                    // for assertion_result\r\n#include <boost/test/tools/old/interface.hpp>                       // for BOOST_TEST_TOOL_PASS_ARGS2, BOOST_TEST_TOOL_PASS_PRED2, BOOST_CHECK_EQUAL, BOOST_...\r\n#include <boost/test/tree/auto_registration.hpp>                    // for auto_test_unit_registrar\r\n#include <boost/test/unit_test_suite.hpp>                           // for BOOST_AUTO_TEST_CASE, BOOST_AUTO_TEST_CASE_FIXTURE, BOOST_AUTO_TEST_SUITE, BOOST_...\r\n#include <boost/test/utils/basic_cstring/basic_cstring.hpp>         // for basic_cstring\r\n#include <boost/test/utils/lazy_ostream.hpp>                        // for operator<<\r\n#include <future>                                                   // for future, promise, future_status, shared_future\r\n#include <stdexcept>                                                // for runtime_error\r\n#include <thread>                                                   // for thread\r\n\r\n/Users/lorinc/IdeaProjects/bitcoin/src/test/threadpool_tests.cpp should remove these lines:\r\n- #include <boost/test/unit_test.hpp>  // lines 10-10\r\n\r\nThe full include-list for /Users/lorinc/IdeaProjects/bitcoin/src/test/threadpool_tests.cpp:\r\n#include <__vector/vector.h>                                        // for vector\r\n#include <common/system.h>                                          // for GetNumCores\r\n#include <util/string.h>                                            // for basic_string, allocator, char_traits, string, ToString, operator+\r\n#include <util/threadpool.h>                                        // for ThreadPool\r\n#include <util/time.h>                                              // for UninterruptibleSleep, milliseconds, operator\"\"s\r\n#include <algorithm>                                                // for max\r\n#include <atomic>                                                   // for atomic, memory_order_relaxed, memory_order_acquire, memory_order_release\r\n#include <boost/preprocessor/arithmetic/limits/dec_256.hpp>         // for BOOST_PP_DEC_1, BOOST_PP_DEC_2, BOOST_PP_DEC_128, BOOST_PP_DEC_16, BOOST_PP_DEC_3\r\n#include <boost/preprocessor/comparison/limits/not_equal_256.hpp>   // for BOOST_PP_NOT_EQUAL_1, BOOST_PP_NOT_EQUAL_CHECK_BOOST_PP_NOT_EQUAL_1\r\n#include <boost/preprocessor/control/expr_iif.hpp>                  // for BOOST_PP_EXPR_IIF_1\r\n#include <boost/preprocessor/control/iif.hpp>                       // for BOOST_PP_IIF_1, BOOST_PP_IIF_0\r\n#include <boost/preprocessor/detail/limits/auto_rec_256.hpp>        // for BOOST_PP_NODE_ENTRY_256\r\n#include <boost/preprocessor/logical/compl.hpp>                     // for BOOST_PP_COMPL_0\r\n#include <boost/preprocessor/logical/limits/bool_256.hpp>           // for BOOST_PP_BOOL_0, BOOST_PP_BOOL_1, BOOST_PP_BOOL_2\r\n#include <boost/preprocessor/repetition/detail/limits/for_256.hpp>  // for BOOST_PP_FOR_0, BOOST_PP_FOR_1, BOOST_PP_FOR_127, BOOST_PP_FOR_15, BOOST_PP_FOR_3\r\n#include <boost/preprocessor/repetition/for.hpp>                    // for BOOST_PP_FOR_CHECK_BOOST_PP_NIL\r\n#include <boost/preprocessor/seq/limits/elem_256.hpp>               // for BOOST_PP_SEQ_ELEM_0\r\n#include <boost/preprocessor/seq/limits/size_256.hpp>               // for BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_2, BOOST_PP_SEQ_SIZE_BOOST_PP_SEQ_SIZE_3\r\n#include <boost/preprocessor/tuple/elem.hpp>                        // for BOOST_PP_TUPLE_ELEM_O_3\r\n#include <boost/preprocessor/variadic/limits/elem_64.hpp>           // for BOOST_PP_VARIADIC_ELEM_3\r\n#include <boost/test/tools/assertion_result.hpp>                    // for assertion_result\r\n#include <boost/test/tools/old/interface.hpp>                       // for BOOST_TEST_TOOL_PASS_ARGS2, BOOST_TEST_TOOL_PASS_PRED2, BOOST_CHECK_EQUAL, BOOST_...\r\n#include <boost/test/tree/auto_registration.hpp>                    // for auto_test_unit_registrar\r\n#include <boost/test/unit_test_suite.hpp>                           // for BOOST_AUTO_TEST_CASE, BOOST_AUTO_TEST_CASE_FIXTURE, BOOST_AUTO_TEST_SUITE, BOOST_...\r\n#include <boost/test/utils/basic_cstring/basic_cstring.hpp>         // for basic_cstring\r\n#include <boost/test/utils/lazy_ostream.hpp>                        // for operator<<\r\n#include <future>                                                   // for future, promise, future_status, shared_future\r\n#include <stdexcept>                                                // for runtime_error\r\n#include <thread>                                                   // for thread\r\n---\r\n```\r\n\r\n</details>",
      "created_at": "2025-11-19T12:39:14Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2541836752",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2541836752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542010169",
      "pull_request_review_id": 3482342931,
      "id": 2542010169,
      "node_id": "PRRC_kwDOABII586Xg_85",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();",
      "path": "src/util/threadpool.h",
      "position": 140,
      "original_position": 141,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "https://corecheck.dev/bitcoin/bitcoin/pulls/33689 suggests using `std::jthread` instead, which would eliminate the need for manual joins - can you check if our infrastructure would support that?",
      "created_at": "2025-11-19T13:26:50Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542010169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542010169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 140,
      "original_line": 141,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542015748",
      "pull_request_review_id": 3482342931,
      "id": 2542015748,
      "node_id": "PRRC_kwDOABII586XhBUE",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.",
      "path": "src/util/threadpool.h",
      "position": 92,
      "original_position": 94,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: comment is redundant, the code already explains it. There are few other comments that don't provide value, can you please check them?",
      "created_at": "2025-11-19T13:28:25Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542015748",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542015748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 92,
      "original_line": 94,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542051426",
      "pull_request_review_id": 3482342931,
      "id": 2542051426,
      "node_id": "PRRC_kwDOABII586XhKBi",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Enqueues a new task for asynchronous execution.\n+     *\n+     * Returns a `std::future` that provides the task’s result or propagates\n+     * any exception it throws.\n+     * Note: Ignoring the returned future requires guarding the task against\n+     * uncaught exceptions, as they would otherwise be silently discarded.\n+     */\n+    template <class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 156,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: we could mark this as `[[nodiscard]]` and reformat with clang-format:\r\n```suggestion\r\n    template <class F>\r\n    [[nodiscard]] EXCLUSIVE_LOCKS_REQUIRED(!m_mutex) auto Enqueue(F&& fn)\r\n```\r\n\r\nNote that this reveals that we often ignore the return value and should make it explicit if that's deliberate or not.\r\nI also think that calling in `Enqueue` could describe its behavior better.",
      "created_at": "2025-11-19T13:38:34Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542051426",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542051426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 155,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542073214",
      "pull_request_review_id": 3482342931,
      "id": 2542073214,
      "node_id": "PRRC_kwDOABII586XhPV-",
      "diff_hunk": "@@ -327,13 +252,13 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n \n     // Dispatch to worker thread\n     if (i != iend) {\n-        std::unique_ptr<HTTPWorkItem> item(new HTTPWorkItem(std::move(hreq), path, i->handler));\n-        assert(g_work_queue);\n-        if (g_work_queue->Enqueue(item.get())) {\n-            item.release(); /* if true, queue took ownership */\n+        if ((int)g_threadpool_http.WorkQueueSize() < g_max_queue_depth) {\n+            g_threadpool_http.Submit([req = std::move(hreq), in_path = std::move(path), fn = i->handler]() {",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 118,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "as far as I can tell, we're ignoring the return value here and silently ignoring any thrown thread exception - which we have tested so carefully.\r\n\r\nSince my understanding is that this is an asynchronous fire-and-forget task, we can't just `.get()` the future here, but we can likely handle the potential exceptions inside and void the method to signal that we're deliberately discarding the future (not forgetting it).",
      "created_at": "2025-11-19T13:44:05Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542073214",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542073214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542188657",
      "pull_request_review_id": 3482342931,
      "id": 2542188657,
      "node_id": "PRRC_kwDOABII586Xhrhx",
      "diff_hunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });\n+}\n+\n+// Test 1, submit tasks and verify completion\n+BOOST_AUTO_TEST_CASE(submit_tasks_complete_successfully)\n+{\n+    int num_tasks = 50;\n+\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<int> counter = 0;\n+\n+    // Store futures to ensure completion before checking counter.\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 1; i <= num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter, i]() {\n+            counter.fetch_add(i, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    // Wait for all tasks to finish\n+    WAIT_FOR(futures);\n+    int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+    BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+}\n+\n+// Test 2, maintain all threads busy except one\n+BOOST_AUTO_TEST_CASE(single_available_worker_executes_all_tasks)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    // Single blocking future for all threads\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1);\n+\n+    // Now execute tasks on the single available worker\n+    // and check that all the tasks are executed.\n+    int num_tasks = 15;\n+    int counter = 0;\n+\n+    // Store futures to wait on\n+    std::vector<std::future<void>> futures(num_tasks);\n+    for (auto& f : futures) f = threadPool.Submit([&counter]{ counter++; });\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+    blocker.set_value();\n+    WAIT_FOR(blocking_tasks);\n+    threadPool.Stop();\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 3, wait for work to finish\n+BOOST_AUTO_TEST_CASE(wait_for_task_to_finish)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<bool> flag = false;\n+    std::future<void> future = threadPool.Submit([&flag]() {\n+        UninterruptibleSleep(std::chrono::milliseconds{200});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 133,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n        UninterruptibleSleep(200ms);\r\n```",
      "created_at": "2025-11-19T14:13:05Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542188657",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542188657"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542192400",
      "pull_request_review_id": 3482342931,
      "id": 2542192400,
      "node_id": "PRRC_kwDOABII586XhscQ",
      "diff_hunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });\n+}\n+\n+// Test 1, submit tasks and verify completion\n+BOOST_AUTO_TEST_CASE(submit_tasks_complete_successfully)\n+{\n+    int num_tasks = 50;\n+\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<int> counter = 0;\n+\n+    // Store futures to ensure completion before checking counter.\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 1; i <= num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter, i]() {\n+            counter.fetch_add(i, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    // Wait for all tasks to finish\n+    WAIT_FOR(futures);\n+    int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+    BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+}\n+\n+// Test 2, maintain all threads busy except one\n+BOOST_AUTO_TEST_CASE(single_available_worker_executes_all_tasks)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    // Single blocking future for all threads\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1);\n+\n+    // Now execute tasks on the single available worker\n+    // and check that all the tasks are executed.\n+    int num_tasks = 15;\n+    int counter = 0;\n+\n+    // Store futures to wait on\n+    std::vector<std::future<void>> futures(num_tasks);\n+    for (auto& f : futures) f = threadPool.Submit([&counter]{ counter++; });\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+    blocker.set_value();\n+    WAIT_FOR(blocking_tasks);\n+    threadPool.Stop();\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 3, wait for work to finish\n+BOOST_AUTO_TEST_CASE(wait_for_task_to_finish)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<bool> flag = false;\n+    std::future<void> future = threadPool.Submit([&flag]() {\n+        UninterruptibleSleep(std::chrono::milliseconds{200});\n+        flag.store(true, std::memory_order_release);\n+    });\n+    BOOST_CHECK(future.wait_for(WAIT_TIMEOUT) == std::future_status::ready);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 145,
      "original_position": 136,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "```suggestion\r\n    BOOST_CHECK_EQUAL(future.wait_for(WAIT_TIMEOUT), std::future_status::ready);\r\n```",
      "created_at": "2025-11-19T14:13:52Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542192400",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542192400"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542433744",
      "pull_request_review_id": 3482342931,
      "id": 2542433744,
      "node_id": "PRRC_kwDOABII586XinXQ",
      "diff_hunk": "@@ -516,21 +429,17 @@ void InterruptHTTPServer()\n         // Reject requests on current connections\n         evhttp_set_gencb(eventHTTP, http_reject_request_cb, nullptr);\n     }\n-    if (g_work_queue) {\n-        g_work_queue->Interrupt();\n-    }\n+    // Interrupt pool after disabling requests\n+    g_threadpool_http.Interrupt();",
      "path": "src/httpserver.cpp",
      "position": 210,
      "original_position": 182,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "still not sure I fully understand the difference between stopping and interrupting - we should probably merge it with Stop and document it better",
      "created_at": "2025-11-19T15:07:19Z",
      "updated_at": "2025-11-19T18:05:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542433744",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542433744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 448,
      "original_line": 433,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542627460",
      "pull_request_review_id": 3482342931,
      "id": 2542627460,
      "node_id": "PRRC_kwDOABII586XjWqE",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();",
      "path": "src/util/threadpool.h",
      "position": 76,
      "original_position": 78,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "we could make it a bit more specific by making\r\n```C++\r\nstd::deque<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\r\n```\r\nwhich would allow\r\n```suggestion\r\n                m_work_queue.pop_front();\r\n```\r\nfor symmetry with `m_work_queue.front()` and to clarify that\r\n```C++\r\n            m_work_queue.emplace(std::move(task));\r\n```\r\nactually inserts at the back\r\n```C++\r\n            m_work_queue.emplace_back(std::move(task));\r\n```",
      "created_at": "2025-11-19T15:56:23Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542627460",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542627460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 76,
      "original_line": 78,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542748830",
      "pull_request_review_id": 3482342931,
      "id": 2542748830,
      "node_id": "PRRC_kwDOABII586Xj0Se",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Enqueues a new task for asynchronous execution.\n+     *\n+     * Returns a `std::future` that provides the task’s result or propagates\n+     * any exception it throws.\n+     * Note: Ignoring the returned future requires guarding the task against\n+     * uncaught exceptions, as they would otherwise be silently discarded.\n+     */\n+    template <class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 174,
      "original_position": 175,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "It seems to me this is a convenience method to expose the inner workings of the pool - but the current usages don't seem to require it.\r\n\r\n> // Test 6, all workers are busy, help them by processing tasks from outside\r\n\r\nIt's not obvious why that would be necessary, doesn't this mean that we have misjudged the number of threads the pool should have?\r\n\r\nI would prefer having the simplest pool we can to get the job done and extend it when we actually need the functionality instead.\r\nOr if we *do* need this for some reason, we should be able to deduplicate since this is basically the exact same implementation and what the `WorkerThread` does in a loop:\r\n```C++\r\nstd::counting_semaphore<> m_sem{0};\r\n\r\nvoid WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n{\r\n    for (;;) {\r\n        m_sem.acquire();\r\n        if (!ProcessTask()) return;\r\n    }\r\n}\r\n\r\n...\r\n\r\n/**\r\n * @brief Execute a single queued task synchronously.\r\n * Removes one task from the queue and executes it on the calling thread.\r\n * @return true if a task was executed, false if queue was empty\r\n */\r\nbool ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n{\r\n    std::packaged_task<void()> task;\r\n    {\r\n        LOCK(m_mutex);\r\n        if (m_work_queue.empty()) return false;\r\n        task = std::move(m_work_queue.front());\r\n        m_work_queue.pop_front();\r\n    }\r\n    task();\r\n    return true;\r\n}\r\n```",
      "created_at": "2025-11-19T16:28:22Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542748830",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542748830"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 174,
      "original_line": 175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542801455",
      "pull_request_review_id": 3482342931,
      "id": 2542801455,
      "node_id": "PRRC_kwDOABII586XkBIv",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable",
      "path": "src/util/threadpool.h",
      "position": 54,
      "original_position": 56,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The `condition_variable`(since C++11)  with locks, reverse locks, waits, notifies can be modernized to a `std::counting_semaphore<> m_sem{0};` (since C++20) that we release when we enqueue an element in `Submit`, in `Interrupt()` and `Stop` we release all of them, and in `WorkerThread` we `m_sem.acquire();` before calling `ProcessTask`",
      "created_at": "2025-11-19T16:42:18Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542801455",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542801455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 51,
      "original_start_line": 53,
      "start_side": "RIGHT",
      "line": 54,
      "original_line": 56,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542812758",
      "pull_request_review_id": 3482342931,
      "id": 2542812758,
      "node_id": "PRRC_kwDOABII586XkD5W",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);",
      "path": "src/util/threadpool.h",
      "position": 134,
      "original_position": 135,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "tests are passing without these lines - can we cover them?",
      "created_at": "2025-11-19T16:45:10Z",
      "updated_at": "2025-11-19T18:03:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542812758",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542812758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 133,
      "original_start_line": 134,
      "start_side": "RIGHT",
      "line": 134,
      "original_line": 135,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542814950",
      "pull_request_review_id": 3482342931,
      "id": 2542814950,
      "node_id": "PRRC_kwDOABII586XkEbm",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()",
      "path": "src/util/threadpool.h",
      "position": 143,
      "original_position": 144,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I also find it weird that we can restart a `ThreadPool` - can we add a Start() → Stop() → Start() unit test if that something we want indeed? I understand it may not be trivial, but I would rather we restructure for RAII or some better lifecycle instead.",
      "created_at": "2025-11-19T16:45:50Z",
      "updated_at": "2025-11-19T18:03:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542814950",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542814950"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 143,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542817887",
      "pull_request_review_id": 3482342931,
      "id": 2542817887,
      "node_id": "PRRC_kwDOABII586XkFJf",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 133,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "nit: we've used backticks in other similar cases\r\n```suggestion\r\n            // Ensure `Stop()` isn't called from any worker thread to avoid deadlocks\r\n```",
      "created_at": "2025-11-19T16:46:45Z",
      "updated_at": "2025-11-19T18:03:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542817887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542817887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542818527",
      "pull_request_review_id": 3482342931,
      "id": 2542818527,
      "node_id": "PRRC_kwDOABII586XkFTf",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 136,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": null,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "same:\r\n```suggestion\r\n            // Early shutdown to return right away on any concurrent `Submit()` call\r\n```",
      "created_at": "2025-11-19T16:46:58Z",
      "updated_at": "2025-11-19T18:03:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542818527",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542818527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542891746",
      "pull_request_review_id": 3482342931,
      "id": 2542891746,
      "node_id": "PRRC_kwDOABII586XkXLi",
      "diff_hunk": "@@ -49,83 +50,6 @@ using common::InvalidPortErrMsg;\n /** Maximum size of http request (request line + headers) */\n static const size_t MAX_HEADERS_SIZE = 8192;\n \n-/** HTTP request work item */\n-class HTTPWorkItem final : public HTTPClosure",
      "path": "src/httpserver.cpp",
      "position": 13,
      "original_position": 13,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "435e8b5a55033fbfc6428a612b9826713b3cf57a",
      "in_reply_to_id": 2478599236,
      "user": {
        "login": "l0rinc",
        "id": 1841944,
        "node_id": "MDQ6VXNlcjE4NDE5NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1841944?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/l0rinc",
        "html_url": "https://github.com/l0rinc",
        "followers_url": "https://api.github.com/users/l0rinc/followers",
        "following_url": "https://api.github.com/users/l0rinc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/l0rinc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/l0rinc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/l0rinc/subscriptions",
        "organizations_url": "https://api.github.com/users/l0rinc/orgs",
        "repos_url": "https://api.github.com/users/l0rinc/repos",
        "events_url": "https://api.github.com/users/l0rinc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/l0rinc/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "This is a big change, other reviewers can just review the unified view if they don't want smaller commits, but I currently cannot view this in small steps, so I insist that we should split it into smaller changes. I want to help, that's why I'm spending so much time with the details, I think this is a really risky change, I want to make sure it's correct. Let me know how I can help.",
      "created_at": "2025-11-19T17:08:30Z",
      "updated_at": "2025-11-19T18:03:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2542891746",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2542891746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 53,
      "original_line": 53,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631432438",
      "pull_request_review_id": 3593444540,
      "id": 2631432438,
      "node_id": "PRRC_kwDOABII586c2Hj2",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 133,
      "commit_id": "258518d880e81938fcd9672b37bc640e8a06c930",
      "original_commit_id": "258518d880e81938fcd9672b37bc640e8a06c930",
      "in_reply_to_id": null,
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "\n\nIn \"util: introduce general purpose thread pool”\n258518d880e81938fcd9672b37bc640e8a06c930\n\nThis comment is incorrect because this check alone is not sufficient to guarantee that `Stop()` is never called from a worker thread.\n\nConsider the following scenario: `Stop()` is called both from a worker thread and from a non-worker thread sequentially. The call from outside the pool may execute first (unless the caller explicitly waits on the future from the thread pool `Stop()`). The non thread pool `Stop()` call acquires the lock, sets the interrupt flag, clears the worker list, and joins all worker threads.\n\nWhen the subsequent call to `Stop()` from within a worker thread executes, the worker list is already empty, comparison succeeds, the check does not detect that `Stop()` is being invoked from a worker thread.\n\nThis does not result in a deadlock, since there are no remaining threads to join. \n\nPerhaps the comment should be adjusted to something like\n\n```cpp\n// Ensure Stop() is not called from a worker thread while workers are still registered,\n// which would otherwise cause a self-join deadlock during shutdown.\n```\n",
      "created_at": "2025-12-18T14:58:14Z",
      "updated_at": "2025-12-18T15:35:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2631432438",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2631432438"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2649847223",
      "pull_request_review_id": 3614779016,
      "id": 2649847223,
      "node_id": "PRRC_kwDOABII586d8XW3",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 133,
      "commit_id": "258518d880e81938fcd9672b37bc640e8a06c930",
      "original_commit_id": "258518d880e81938fcd9672b37bc640e8a06c930",
      "in_reply_to_id": 2631432438,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Good catch. Thanks. Updated.",
      "created_at": "2025-12-28T18:10:35Z",
      "updated_at": "2025-12-28T18:10:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2649847223",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2649847223"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733935420",
      "pull_request_review_id": 3713586023,
      "id": 2733935420,
      "node_id": "PRRC_kwDOABII586i9Is8",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Enqueues a new task for asynchronous execution.\n+     *\n+     * Returns a `std::future` that provides the task’s result or propagates",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 150,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2541801771,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2026-01-27T21:40:26Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2733935420",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733935420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 150,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733935754",
      "pull_request_review_id": 3713586023,
      "id": 2733935754,
      "node_id": "PRRC_kwDOABII586i9IyK",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 13,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2541836752,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2026-01-27T21:40:33Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2733935754",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733935754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 13,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733949052",
      "pull_request_review_id": 3713586023,
      "id": 2733949052,
      "node_id": "PRRC_kwDOABII586i9MB8",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Enqueues a new task for asynchronous execution.\n+     *\n+     * Returns a `std::future` that provides the task’s result or propagates\n+     * any exception it throws.\n+     * Note: Ignoring the returned future requires guarding the task against\n+     * uncaught exceptions, as they would otherwise be silently discarded.\n+     */\n+    template <class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 156,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2542051426,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Sure. Added `[[nodiscard]]`. I personally prefer `Submit` as tasks might not get executed in order as `enqueue` suggests.",
      "created_at": "2026-01-27T21:45:06Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2733949052",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733949052"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": 155,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 156,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733962714",
      "pull_request_review_id": 3713586023,
      "id": 2733962714,
      "node_id": "PRRC_kwDOABII586i9PXa",
      "diff_hunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });\n+}\n+\n+// Test 1, submit tasks and verify completion\n+BOOST_AUTO_TEST_CASE(submit_tasks_complete_successfully)\n+{\n+    int num_tasks = 50;\n+\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<int> counter = 0;\n+\n+    // Store futures to ensure completion before checking counter.\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 1; i <= num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter, i]() {\n+            counter.fetch_add(i, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    // Wait for all tasks to finish\n+    WAIT_FOR(futures);\n+    int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+    BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+}\n+\n+// Test 2, maintain all threads busy except one\n+BOOST_AUTO_TEST_CASE(single_available_worker_executes_all_tasks)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    // Single blocking future for all threads\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1);\n+\n+    // Now execute tasks on the single available worker\n+    // and check that all the tasks are executed.\n+    int num_tasks = 15;\n+    int counter = 0;\n+\n+    // Store futures to wait on\n+    std::vector<std::future<void>> futures(num_tasks);\n+    for (auto& f : futures) f = threadPool.Submit([&counter]{ counter++; });\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+    blocker.set_value();\n+    WAIT_FOR(blocking_tasks);\n+    threadPool.Stop();\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 3, wait for work to finish\n+BOOST_AUTO_TEST_CASE(wait_for_task_to_finish)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<bool> flag = false;\n+    std::future<void> future = threadPool.Submit([&flag]() {\n+        UninterruptibleSleep(std::chrono::milliseconds{200});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 133,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2542188657,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2026-01-27T21:49:50Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2733962714",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733962714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733963046",
      "pull_request_review_id": 3713586023,
      "id": 2733963046,
      "node_id": "PRRC_kwDOABII586i9Pcm",
      "diff_hunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+// General test values\n+constexpr int NUM_WORKERS_DEFAULT = 3;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION(threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });\n+}\n+\n+// Test 1, submit tasks and verify completion\n+BOOST_AUTO_TEST_CASE(submit_tasks_complete_successfully)\n+{\n+    int num_tasks = 50;\n+\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<int> counter = 0;\n+\n+    // Store futures to ensure completion before checking counter.\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 1; i <= num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter, i]() {\n+            counter.fetch_add(i, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    // Wait for all tasks to finish\n+    WAIT_FOR(futures);\n+    int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+    BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+}\n+\n+// Test 2, maintain all threads busy except one\n+BOOST_AUTO_TEST_CASE(single_available_worker_executes_all_tasks)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    // Single blocking future for all threads\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1);\n+\n+    // Now execute tasks on the single available worker\n+    // and check that all the tasks are executed.\n+    int num_tasks = 15;\n+    int counter = 0;\n+\n+    // Store futures to wait on\n+    std::vector<std::future<void>> futures(num_tasks);\n+    for (auto& f : futures) f = threadPool.Submit([&counter]{ counter++; });\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+    blocker.set_value();\n+    WAIT_FOR(blocking_tasks);\n+    threadPool.Stop();\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 3, wait for work to finish\n+BOOST_AUTO_TEST_CASE(wait_for_task_to_finish)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<bool> flag = false;\n+    std::future<void> future = threadPool.Submit([&flag]() {\n+        UninterruptibleSleep(std::chrono::milliseconds{200});\n+        flag.store(true, std::memory_order_release);\n+    });\n+    BOOST_CHECK(future.wait_for(WAIT_TIMEOUT) == std::future_status::ready);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 145,
      "original_position": 136,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2542192400,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done as suggested.",
      "created_at": "2026-01-27T21:49:55Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2733963046",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733963046"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 145,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733966376",
      "pull_request_review_id": 3713586023,
      "id": 2733966376,
      "node_id": "PRRC_kwDOABII586i9QQo",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 133,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2542817887,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Removed the backticks.",
      "created_at": "2026-01-27T21:50:55Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2733966376",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733966376"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 133,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733966714",
      "pull_request_review_id": 3713586023,
      "id": 2733966714,
      "node_id": "PRRC_kwDOABII586i9QV6",
      "diff_hunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure 'Stop()' isn't called from any worker thread to avoid deadlocks\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent 'Submit()' call",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 136,
      "commit_id": "d504f81c86852fdbb487f89a8b2cb81a5e68cdf3",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2542818527,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "removed the backticks",
      "created_at": "2026-01-27T21:51:02Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2733966714",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2733966714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2738558225",
      "pull_request_review_id": 3713586023,
      "id": 2738558225,
      "node_id": "PRRC_kwDOABII586jOxUR",
      "diff_hunk": "@@ -327,13 +252,13 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n \n     // Dispatch to worker thread\n     if (i != iend) {\n-        std::unique_ptr<HTTPWorkItem> item(new HTTPWorkItem(std::move(hreq), path, i->handler));\n-        assert(g_work_queue);\n-        if (g_work_queue->Enqueue(item.get())) {\n-            item.release(); /* if true, queue took ownership */\n+        if ((int)g_threadpool_http.WorkQueueSize() < g_max_queue_depth) {\n+            g_threadpool_http.Submit([req = std::move(hreq), in_path = std::move(path), fn = i->handler]() {",
      "path": "src/httpserver.cpp",
      "position": 1,
      "original_position": 118,
      "commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "original_commit_id": "2de0ce5cd85e1b99e318883964df318ffb615fe4",
      "in_reply_to_id": 2542073214,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yeah, that why I was very explicit in the `Submit()` documentation about this behavior.\r\nI was thinking specifically about this line.\r\n\r\nI managed to crash master just by throwing an exception from the RPC handler, which highlights another advantage of this PR since the same scenario no longer results in a crash here. Because of this, I added an early commit in the PR to explain and explicitly fix the crash, keeping it isolated from the HTTP-pool changes. And also included an error logging improvement for the functional test framework.",
      "created_at": "2026-01-28T20:52:06Z",
      "updated_at": "2026-01-29T00:19:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2738558225",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2738558225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 256,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2747516622",
      "pull_request_review_id": 3729838460,
      "id": 2747516622,
      "node_id": "PRRC_kwDOABII586jw8bO",
      "diff_hunk": "@@ -0,0 +1,202 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/thread.h>\n+\n+#include <algorithm>\n+#include <condition_variable>\n+#include <functional>\n+#include <future>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 38,
      "commit_id": "59f277a407971ceaedcba8641a58f3a3c479085e",
      "original_commit_id": "59f277a407971ceaedcba8641a58f3a3c479085e",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/33689/changes/59f277a407971ceaedcba8641a58f3a3c479085e:\n\nConsider documenting `Interrupt()` as well.",
      "created_at": "2026-01-30T18:43:06Z",
      "updated_at": "2026-01-30T20:15:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2747516622",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2747516622"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2747522885",
      "pull_request_review_id": 3729838460,
      "id": 2747522885,
      "node_id": "PRRC_kwDOABII586jw99F",
      "diff_hunk": "@@ -0,0 +1,304 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <random.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// General test values\n+int NUM_WORKERS_DEFAULT = 0;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+struct ThreadPoolFixture {\n+    ThreadPoolFixture() {\n+        NUM_WORKERS_DEFAULT = FastRandomContext().randrange(GetNumCores()) + 1;\n+        LogInfo(\"thread pool workers count: %d\", NUM_WORKERS_DEFAULT);\n+    }\n+};\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_FIXTURE_TEST_SUITE(threadpool_tests, ThreadPoolFixture)\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION((void)threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });\n+}\n+\n+// Test 1, submit tasks and verify completion\n+BOOST_AUTO_TEST_CASE(submit_tasks_complete_successfully)\n+{\n+    int num_tasks = 50;\n+\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<int> counter = 0;\n+\n+    // Store futures to ensure completion before checking counter.\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 1; i <= num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter, i]() {\n+            counter.fetch_add(i, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    // Wait for all tasks to finish\n+    WAIT_FOR(futures);\n+    int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+    BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+}\n+\n+// Test 2, maintain all threads busy except one\n+BOOST_AUTO_TEST_CASE(single_available_worker_executes_all_tasks)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    // Single blocking future for all threads\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1);\n+\n+    // Now execute tasks on the single available worker\n+    // and check that all the tasks are executed.\n+    int num_tasks = 15;\n+    int counter = 0;\n+\n+    // Store futures to wait on\n+    std::vector<std::future<void>> futures(num_tasks);\n+    for (auto& f : futures) f = threadPool.Submit([&counter]{ counter++; });\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+    blocker.set_value();\n+    WAIT_FOR(blocking_tasks);\n+    threadPool.Stop();\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 3, wait for work to finish\n+BOOST_AUTO_TEST_CASE(wait_for_task_to_finish)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<bool> flag = false;\n+    std::future<void> future = threadPool.Submit([&flag]() {\n+        UninterruptibleSleep(200ms);\n+        flag.store(true, std::memory_order_release);\n+    });\n+    BOOST_CHECK(future.wait_for(WAIT_TIMEOUT) == std::future_status::ready);\n+    BOOST_CHECK(flag.load(std::memory_order_acquire));\n+}\n+\n+// Test 4, obtain result object\n+BOOST_AUTO_TEST_CASE(get_result_from_completed_task)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::future<bool> future_bool = threadPool.Submit([]() { return true; });\n+    BOOST_CHECK(future_bool.get());\n+\n+    std::future<std::string> future_str = threadPool.Submit([]() { return std::string(\"true\"); });\n+    std::string result = future_str.get();\n+    BOOST_CHECK_EQUAL(result, \"true\");\n+}\n+\n+// Test 5, throw exception and catch it on the consumer side\n+BOOST_AUTO_TEST_CASE(task_exception_propagates_to_future)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    int num_tasks = 5;\n+    std::string err_msg{\"something wrong happened\"};\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 0; i < num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+            throw std::runtime_error(err_msg + util::ToString(i));\n+        }));\n+    }\n+\n+    for (int i = 0; i < num_tasks; i++) {\n+        BOOST_CHECK_EXCEPTION(futures.at(i).get(), std::runtime_error, [&](const std::runtime_error& e) {\n+            BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            return true;\n+        });\n+    }\n+}\n+\n+// Test 6, all workers are busy, help them by processing tasks from outside\n+BOOST_AUTO_TEST_CASE(process_tasks_manually_when_workers_busy)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT);\n+\n+    // Now submit tasks and check that none of them are executed.\n+    int num_tasks = 20;\n+    std::atomic<int> counter = 0;\n+    for (int i = 0; i < num_tasks; i++) {\n+        (void)threadPool.Submit([&counter]() {\n+            counter.fetch_add(1, std::memory_order_relaxed);\n+        });\n+    }\n+    UninterruptibleSleep(100ms);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), num_tasks);\n+\n+    // Now process manually\n+    for (int i = 0; i < num_tasks; i++) {\n+        threadPool.ProcessTask();\n+    }\n+    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    blocker.set_value();\n+    threadPool.Stop();\n+    WAIT_FOR(blocking_tasks);\n+}\n+\n+// Test 7, submit tasks from other tasks\n+BOOST_AUTO_TEST_CASE(recursive_task_submission)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    std::promise<void> signal;\n+    (void)threadPool.Submit([&]() {\n+        (void)threadPool.Submit([&]() {\n+            signal.set_value();\n+        });\n+    });\n+\n+    signal.get_future().wait();\n+    threadPool.Stop();\n+}\n+\n+// Test 8, submit task when all threads are busy and then stop the pool\n+BOOST_AUTO_TEST_CASE(task_submitted_while_busy_completes)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT);\n+\n+    // Submit an extra task that should execute once a worker is free\n+    std::future<bool> future = threadPool.Submit([]() { return true; });\n+\n+    // At this point, all workers are blocked, and the extra task is queued\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\n+\n+    // Wait a short moment before unblocking the threads to mimic a concurrent shutdown\n+    std::thread thread_unblocker([&blocker]() {\n+        UninterruptibleSleep(300ms);\n+        blocker.set_value();\n+    });\n+\n+    // Stop the pool while the workers are still blocked\n+    threadPool.Stop();\n+\n+    // Expect the submitted task to complete\n+    BOOST_CHECK(future.get());\n+    thread_unblocker.join();\n+\n+    // Obviously all the previously blocking tasks should be completed at this point too\n+    WAIT_FOR(blocking_tasks);\n+\n+    // Pool should be stopped and no workers remaining\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 9, more workers than available cores (congestion test)\n+BOOST_AUTO_TEST_CASE(congestion_more_workers_than_cores)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(std::max(1, GetNumCores() * 2)); // Oversubscribe by 2×\n+\n+    int num_tasks = 200;\n+    std::atomic<int> counter{0};\n+\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 0; i < num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter] {\n+            counter.fetch_add(1, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+}\n+\n+// Test 10, Interrupt() prevents further submissions\n+BOOST_AUTO_TEST_CASE(interrupt_blocks_new_submissions)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    threadPool.Interrupt();",
      "path": "src/test/threadpool_tests.cpp",
      "position": 298,
      "original_position": 297,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "59f277a407971ceaedcba8641a58f3a3c479085e",
      "in_reply_to_id": null,
      "user": {
        "login": "Eunovo",
        "id": 37949128,
        "node_id": "MDQ6VXNlcjM3OTQ5MTI4",
        "avatar_url": "https://avatars.githubusercontent.com/u/37949128?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Eunovo",
        "html_url": "https://github.com/Eunovo",
        "followers_url": "https://api.github.com/users/Eunovo/followers",
        "following_url": "https://api.github.com/users/Eunovo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Eunovo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Eunovo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Eunovo/subscriptions",
        "organizations_url": "https://api.github.com/users/Eunovo/orgs",
        "repos_url": "https://api.github.com/users/Eunovo/repos",
        "events_url": "https://api.github.com/users/Eunovo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Eunovo/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/33689/changes/59f277a407971ceaedcba8641a58f3a3c479085e:\r\n\r\nIt seems that `Interrupt()` is safe to call from a worker thread. If it is intended to be used this way, consider expanding this test to also call `Interrupt()` from a worker thread.",
      "created_at": "2026-01-30T18:45:29Z",
      "updated_at": "2026-01-30T20:15:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2747522885",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2747522885"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2748007913",
      "pull_request_review_id": 3730433830,
      "id": 2748007913,
      "node_id": "PRRC_kwDOABII586jy0Xp",
      "diff_hunk": "@@ -0,0 +1,202 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/thread.h>\n+\n+#include <algorithm>\n+#include <condition_variable>\n+#include <functional>\n+#include <future>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 38,
      "commit_id": "59f277a407971ceaedcba8641a58f3a3c479085e",
      "original_commit_id": "59f277a407971ceaedcba8641a58f3a3c479085e",
      "in_reply_to_id": 2747516622,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2026-01-30T21:16:13Z",
      "updated_at": "2026-01-30T21:16:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2748007913",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2748007913"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 38,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2748008200",
      "pull_request_review_id": 3730434182,
      "id": 2748008200,
      "node_id": "PRRC_kwDOABII586jy0cI",
      "diff_hunk": "@@ -0,0 +1,304 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <random.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// General test values\n+int NUM_WORKERS_DEFAULT = 0;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+struct ThreadPoolFixture {\n+    ThreadPoolFixture() {\n+        NUM_WORKERS_DEFAULT = FastRandomContext().randrange(GetNumCores()) + 1;\n+        LogInfo(\"thread pool workers count: %d\", NUM_WORKERS_DEFAULT);\n+    }\n+};\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_FIXTURE_TEST_SUITE(threadpool_tests, ThreadPoolFixture)\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION((void)threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");\n+        return true;\n+    });\n+}\n+\n+// Test 1, submit tasks and verify completion\n+BOOST_AUTO_TEST_CASE(submit_tasks_complete_successfully)\n+{\n+    int num_tasks = 50;\n+\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<int> counter = 0;\n+\n+    // Store futures to ensure completion before checking counter.\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 1; i <= num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter, i]() {\n+            counter.fetch_add(i, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    // Wait for all tasks to finish\n+    WAIT_FOR(futures);\n+    int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+    BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+}\n+\n+// Test 2, maintain all threads busy except one\n+BOOST_AUTO_TEST_CASE(single_available_worker_executes_all_tasks)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    // Single blocking future for all threads\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT - 1);\n+\n+    // Now execute tasks on the single available worker\n+    // and check that all the tasks are executed.\n+    int num_tasks = 15;\n+    int counter = 0;\n+\n+    // Store futures to wait on\n+    std::vector<std::future<void>> futures(num_tasks);\n+    for (auto& f : futures) f = threadPool.Submit([&counter]{ counter++; });\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter, num_tasks);\n+\n+    blocker.set_value();\n+    WAIT_FOR(blocking_tasks);\n+    threadPool.Stop();\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 3, wait for work to finish\n+BOOST_AUTO_TEST_CASE(wait_for_task_to_finish)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::atomic<bool> flag = false;\n+    std::future<void> future = threadPool.Submit([&flag]() {\n+        UninterruptibleSleep(200ms);\n+        flag.store(true, std::memory_order_release);\n+    });\n+    BOOST_CHECK(future.wait_for(WAIT_TIMEOUT) == std::future_status::ready);\n+    BOOST_CHECK(flag.load(std::memory_order_acquire));\n+}\n+\n+// Test 4, obtain result object\n+BOOST_AUTO_TEST_CASE(get_result_from_completed_task)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    std::future<bool> future_bool = threadPool.Submit([]() { return true; });\n+    BOOST_CHECK(future_bool.get());\n+\n+    std::future<std::string> future_str = threadPool.Submit([]() { return std::string(\"true\"); });\n+    std::string result = future_str.get();\n+    BOOST_CHECK_EQUAL(result, \"true\");\n+}\n+\n+// Test 5, throw exception and catch it on the consumer side\n+BOOST_AUTO_TEST_CASE(task_exception_propagates_to_future)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    int num_tasks = 5;\n+    std::string err_msg{\"something wrong happened\"};\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 0; i < num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+            throw std::runtime_error(err_msg + util::ToString(i));\n+        }));\n+    }\n+\n+    for (int i = 0; i < num_tasks; i++) {\n+        BOOST_CHECK_EXCEPTION(futures.at(i).get(), std::runtime_error, [&](const std::runtime_error& e) {\n+            BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            return true;\n+        });\n+    }\n+}\n+\n+// Test 6, all workers are busy, help them by processing tasks from outside\n+BOOST_AUTO_TEST_CASE(process_tasks_manually_when_workers_busy)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT);\n+\n+    // Now submit tasks and check that none of them are executed.\n+    int num_tasks = 20;\n+    std::atomic<int> counter = 0;\n+    for (int i = 0; i < num_tasks; i++) {\n+        (void)threadPool.Submit([&counter]() {\n+            counter.fetch_add(1, std::memory_order_relaxed);\n+        });\n+    }\n+    UninterruptibleSleep(100ms);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), num_tasks);\n+\n+    // Now process manually\n+    for (int i = 0; i < num_tasks; i++) {\n+        threadPool.ProcessTask();\n+    }\n+    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    blocker.set_value();\n+    threadPool.Stop();\n+    WAIT_FOR(blocking_tasks);\n+}\n+\n+// Test 7, submit tasks from other tasks\n+BOOST_AUTO_TEST_CASE(recursive_task_submission)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    std::promise<void> signal;\n+    (void)threadPool.Submit([&]() {\n+        (void)threadPool.Submit([&]() {\n+            signal.set_value();\n+        });\n+    });\n+\n+    signal.get_future().wait();\n+    threadPool.Stop();\n+}\n+\n+// Test 8, submit task when all threads are busy and then stop the pool\n+BOOST_AUTO_TEST_CASE(task_submitted_while_busy_completes)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+    std::promise<void> blocker;\n+    std::shared_future<void> blocker_future(blocker.get_future());\n+    const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT);\n+\n+    // Submit an extra task that should execute once a worker is free\n+    std::future<bool> future = threadPool.Submit([]() { return true; });\n+\n+    // At this point, all workers are blocked, and the extra task is queued\n+    BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 1);\n+\n+    // Wait a short moment before unblocking the threads to mimic a concurrent shutdown\n+    std::thread thread_unblocker([&blocker]() {\n+        UninterruptibleSleep(300ms);\n+        blocker.set_value();\n+    });\n+\n+    // Stop the pool while the workers are still blocked\n+    threadPool.Stop();\n+\n+    // Expect the submitted task to complete\n+    BOOST_CHECK(future.get());\n+    thread_unblocker.join();\n+\n+    // Obviously all the previously blocking tasks should be completed at this point too\n+    WAIT_FOR(blocking_tasks);\n+\n+    // Pool should be stopped and no workers remaining\n+    BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+}\n+\n+// Test 9, more workers than available cores (congestion test)\n+BOOST_AUTO_TEST_CASE(congestion_more_workers_than_cores)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(std::max(1, GetNumCores() * 2)); // Oversubscribe by 2×\n+\n+    int num_tasks = 200;\n+    std::atomic<int> counter{0};\n+\n+    std::vector<std::future<void>> futures;\n+    futures.reserve(num_tasks);\n+    for (int i = 0; i < num_tasks; i++) {\n+        futures.emplace_back(threadPool.Submit([&counter] {\n+            counter.fetch_add(1, std::memory_order_relaxed);\n+        }));\n+    }\n+\n+    WAIT_FOR(futures);\n+    BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+}\n+\n+// Test 10, Interrupt() prevents further submissions\n+BOOST_AUTO_TEST_CASE(interrupt_blocks_new_submissions)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    threadPool.Start(NUM_WORKERS_DEFAULT);\n+    threadPool.Interrupt();",
      "path": "src/test/threadpool_tests.cpp",
      "position": 298,
      "original_position": 297,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "59f277a407971ceaedcba8641a58f3a3c479085e",
      "in_reply_to_id": 2747522885,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Done.",
      "created_at": "2026-01-30T21:16:20Z",
      "updated_at": "2026-01-30T21:16:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2748008200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2748008200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 298,
      "original_line": 297,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2783553065",
      "pull_request_review_id": 3774273771,
      "id": 2783553065,
      "node_id": "PRRC_kwDOABII586l6aYp",
      "diff_hunk": "@@ -327,7 +327,24 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n \n     // Dispatch to worker thread\n     if (i != iend) {\n-        std::unique_ptr<HTTPWorkItem> item(new HTTPWorkItem(std::move(hreq), path, i->handler));\n+        auto item = std::make_unique<HTTPWorkItem>(std::move(hreq), path, [fn = i->handler](HTTPRequest* req, const std::string& path_inner) {\n+            std::string err_msg;\n+            try {\n+                return fn(req, path_inner);\n+            } catch (const std::exception& e) {\n+                LogWarning(\"Unexpected error while processing request for '%s'. Error msg: '%s'\", req->GetURI(), e.what());\n+                err_msg = e.what();\n+            } catch (...) {\n+                LogWarning(\"Unknown error while processing request for '%s'\", req->GetURI());\n+                err_msg = \"unknown error\";\n+            }\n+            // Reply so the client doesn't hang waiting for the response.\n+            req->WriteHeader(\"Connection\", \"close\");\n+            // TODO: Implement specific error formatting for the REST and JSON-RPC servers responses.\n+            req->WriteReply(HTTP_INTERNAL_SERVER_ERROR, err_msg);\n+            return false;",
      "path": "src/httpserver.cpp",
      "position": 29,
      "original_position": 29,
      "commit_id": "45930a79412dc45f9d391cd7689d029fa4f0189e",
      "original_commit_id": "45930a79412dc45f9d391cd7689d029fa4f0189e",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "45930a79412dc45f9d391cd7689d029fa4f0189e\n\nnit: `HTTPRequestHandler` is defined as returning a `bool` but I don't think we ever use its return value, can probably be `void`. No change needed at this time, I just noticed this code either returns a hard coded bool, or the value from some arbitrary function, whose type is not so easy to see on the same page.",
      "created_at": "2026-02-09T16:39:57Z",
      "updated_at": "2026-02-10T18:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2783553065",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2783553065"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2783817192",
      "pull_request_review_id": 3774273771,
      "id": 2783817192,
      "node_id": "PRRC_kwDOABII586l7a3o",
      "diff_hunk": "@@ -147,6 +147,9 @@ def main(self):\n         except subprocess.CalledProcessError as e:\n             self.log.exception(f\"Called Process failed with stdout='{e.stdout}'; stderr='{e.stderr}';\")\n             self.success = TestStatus.FAILED\n+        except JSONRPCException as e:\n+            self.log.exception(f\"Failure during setup: error={e.error}, http_status={e.http_status}\")",
      "path": "test/functional/test_framework/test_framework.py",
      "position": 5,
      "original_position": 5,
      "commit_id": "6354b4fd7fe819eb13274b212e426a7d10ca75d3",
      "original_commit_id": "6354b4fd7fe819eb13274b212e426a7d10ca75d3",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "6354b4fd7fe819eb13274b212e426a7d10ca75d3\n\nThis is good but could even be improved (doesn't have to be here). For example with the diff below and the suggested diff in the first commit message, you can actually get _all_ the information logged out:\n\ncurrent:\n> test_framework.authproxy.JSONRPCException: non-JSON HTTP response with '500 Internal Server Error' from server (-342)\n\nwith diff below:\n> test_framework.authproxy.JSONRPCException: non-JSON HTTP response with '500 Internal Server Error' from server: error from json rpc handler (-342)\n\n\n\n```diff\ndiff --git a/test/functional/test_framework/authproxy.py b/test/functional/test_framework/authproxy.py\nindex 9b2fc0f7f9..051423928d 100644\n--- a/test/functional/test_framework/authproxy.py\n+++ b/test/functional/test_framework/authproxy.py\n@@ -195,7 +195,7 @@ class AuthServiceProxy():\n         content_type = http_response.getheader('Content-Type')\n         if content_type != 'application/json':\n             raise JSONRPCException(\n-                {'code': -342, 'message': 'non-JSON HTTP response with \\'%i %s\\' from server' % (http_response.status, http_response.reason)},\n+                {'code': -342, 'message': 'non-JSON HTTP response with \\'%i %s\\' from server: %s' % (http_response.status, http_response.reason, http_response.read().decode())},\n                 http_response.status)\n \n         data = http_response.read()\n```",
      "created_at": "2026-02-09T17:50:38Z",
      "updated_at": "2026-02-10T18:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2783817192",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2783817192"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2783949380",
      "pull_request_review_id": 3774273771,
      "id": 2783949380,
      "node_id": "PRRC_kwDOABII586l77JE",
      "diff_hunk": "@@ -0,0 +1,211 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/thread.h>\n+\n+#include <algorithm>\n+#include <condition_variable>\n+#include <functional>\n+#include <future>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Interrupt()` stops new task submission and lets queued ones drain\n+ *   in the background. Callers can continue other shutdown steps and call\n+ *   Stop() at the end to ensure no remaining tasks are left to execute.\n+ *\n+ * - `Stop()` prevents further task submission and blocks until all the\n+ *   queued ones are completed.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset",
      "path": "src/util/threadpool.h",
      "position": 108,
      "original_position": 108,
      "commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "original_commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1\n\nWhat scenario would we stop and then re-start an instantiated worker pool?",
      "created_at": "2026-02-09T18:19:46Z",
      "updated_at": "2026-02-10T18:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2783949380",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2783949380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 108,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2784073214",
      "pull_request_review_id": 3774273771,
      "id": 2784073214,
      "node_id": "PRRC_kwDOABII586l8ZX-",
      "diff_hunk": "@@ -0,0 +1,211 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/thread.h>\n+\n+#include <algorithm>\n+#include <condition_variable>\n+#include <functional>\n+#include <future>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Interrupt()` stops new task submission and lets queued ones drain\n+ *   in the background. Callers can continue other shutdown steps and call\n+ *   Stop() at the end to ensure no remaining tasks are left to execute.\n+ *\n+ * - `Stop()` prevents further task submission and blocks until all the\n+ *   queued ones are completed.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure Stop() is not called from a worker thread while workers are still registered,\n+            // otherwise a self-join deadlock would occur.\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent Submit() call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Enqueues a new task for asynchronous execution.\n+     *\n+     * Returns a `std::future` that provides the task's result or propagates\n+     * any exception it throws.\n+     * Note: Ignoring the returned future requires guarding the task against\n+     * uncaught exceptions, as they would otherwise be silently discarded.\n+     */\n+    template <class F> [[nodiscard]] EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)",
      "path": "src/util/threadpool.h",
      "position": 155,
      "original_position": 155,
      "commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "original_commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1\n\nJust curious about your style choice here, I'd've written like this\n\n```cpp\ntemplate <class F>\n[[nodiscard]] auto Submit(F&& fn) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n```",
      "created_at": "2026-02-09T18:45:54Z",
      "updated_at": "2026-02-10T18:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2784073214",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2784073214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 154,
      "original_start_line": 154,
      "start_side": "RIGHT",
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2785224696",
      "pull_request_review_id": 3774273771,
      "id": 2785224696,
      "node_id": "PRRC_kwDOABII586mAyf4",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <random.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// General test values\n+int NUM_WORKERS_DEFAULT = 0;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+struct ThreadPoolFixture {\n+    ThreadPoolFixture() {\n+        NUM_WORKERS_DEFAULT = FastRandomContext().randrange(GetNumCores()) + 1;\n+        LogInfo(\"thread pool workers count: %d\", NUM_WORKERS_DEFAULT);\n+    }\n+};\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_FIXTURE_TEST_SUITE(threadpool_tests, ThreadPoolFixture)\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, const std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION((void)threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");",
      "path": "src/test/threadpool_tests.cpp",
      "position": 77,
      "original_position": 77,
      "commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "original_commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1\n\nWhy not use `HasReason()`?\n\n\n```cpp\n#include <test/util/setup_common.h>\n...\n    BOOST_CHECK_EXCEPTION(\n        (void)threadPool.Submit([]{ return false; }),\n        std::runtime_error,\n        HasReason{\"No active workers; cannot accept new tasks\"\n    });\n```\n\nDrahtbot should be complaining about this ;-)\nsee https://github.com/bitcoin/bitcoin/pull/34242#discussion_r2716939301\n\nand in `task_exception_propagates_to_future` and `interrupt_blocks_new_submissions` below",
      "created_at": "2026-02-10T00:41:10Z",
      "updated_at": "2026-02-10T18:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2785224696",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2785224696"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 76,
      "original_start_line": 76,
      "start_side": "RIGHT",
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2789304427",
      "pull_request_review_id": 3774273771,
      "id": 2789304427,
      "node_id": "PRRC_kwDOABII586mQWhr",
      "diff_hunk": "@@ -342,16 +274,9 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n             req->WriteHeader(\"Connection\", \"close\");\n             // TODO: Implement specific error formatting for the REST and JSON-RPC servers responses.\n             req->WriteReply(HTTP_INTERNAL_SERVER_ERROR, err_msg);\n-            return false;\n-        });\n+        };\n \n-        assert(g_work_queue);\n-        if (g_work_queue->Enqueue(item.get())) {\n-            (void)item.release(); /* if true, queue took ownership */\n-        } else {\n-            LogWarning(\"Request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\");\n-            item->req->WriteReply(HTTP_SERVICE_UNAVAILABLE, \"Work queue depth exceeded\");\n-        }\n+        [[maybe_unused]] auto _{g_threadpool_http.Submit(std::move(item))};",
      "path": "src/httpserver.cpp",
      "position": 144,
      "original_position": 144,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "38fd85c676a072ebf256e806beda9d7533790baa\n\nRelated to my comment on the first commit about how these workers dont return any thing. So now in the above try/catch wrapper the return values are removed which makes sense to me.\n\nMy guess is that for _this use case_ of threadpool, we don't need to examine the return value of the future from the task, but other uses of threadpool will not discard it?",
      "created_at": "2026-02-10T17:29:07Z",
      "updated_at": "2026-02-10T18:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2789304427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2789304427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2789942086",
      "pull_request_review_id": 3781215880,
      "id": 2789942086,
      "node_id": "PRRC_kwDOABII586mSyNG",
      "diff_hunk": "@@ -327,7 +327,24 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n \n     // Dispatch to worker thread\n     if (i != iend) {\n-        std::unique_ptr<HTTPWorkItem> item(new HTTPWorkItem(std::move(hreq), path, i->handler));\n+        auto item = std::make_unique<HTTPWorkItem>(std::move(hreq), path, [fn = i->handler](HTTPRequest* req, const std::string& path_inner) {\n+            std::string err_msg;\n+            try {\n+                return fn(req, path_inner);\n+            } catch (const std::exception& e) {\n+                LogWarning(\"Unexpected error while processing request for '%s'. Error msg: '%s'\", req->GetURI(), e.what());\n+                err_msg = e.what();\n+            } catch (...) {\n+                LogWarning(\"Unknown error while processing request for '%s'\", req->GetURI());\n+                err_msg = \"unknown error\";\n+            }\n+            // Reply so the client doesn't hang waiting for the response.\n+            req->WriteHeader(\"Connection\", \"close\");\n+            // TODO: Implement specific error formatting for the REST and JSON-RPC servers responses.\n+            req->WriteReply(HTTP_INTERNAL_SERVER_ERROR, err_msg);\n+            return false;",
      "path": "src/httpserver.cpp",
      "position": 29,
      "original_position": 29,
      "commit_id": "45930a79412dc45f9d391cd7689d029fa4f0189e",
      "original_commit_id": "45930a79412dc45f9d391cd7689d029fa4f0189e",
      "in_reply_to_id": 2783553065,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "Yeah, the first commit fixes the possible crash using the existing `HTTPRequestHandler`, which returns a bool. In the removal commit, when `HTTPRequestHandler` gets dropped, the bool return value is dropped as well.",
      "created_at": "2026-02-10T19:52:18Z",
      "updated_at": "2026-02-10T19:52:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2789942086",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2789942086"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 345,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790087151",
      "pull_request_review_id": 3781363967,
      "id": 2790087151,
      "node_id": "PRRC_kwDOABII586mTVnv",
      "diff_hunk": "@@ -0,0 +1,211 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/thread.h>\n+\n+#include <algorithm>\n+#include <condition_variable>\n+#include <functional>\n+#include <future>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Interrupt()` stops new task submission and lets queued ones drain\n+ *   in the background. Callers can continue other shutdown steps and call\n+ *   Stop() at the end to ensure no remaining tasks are left to execute.\n+ *\n+ * - `Stop()` prevents further task submission and blocks until all the\n+ *   queued ones are completed.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset",
      "path": "src/util/threadpool.h",
      "position": 108,
      "original_position": 108,
      "commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "original_commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "in_reply_to_id": 2783949380,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> [c528dd5](https://github.com/bitcoin/bitcoin/commit/c528dd5f8ccc3955b00bdba869f0a774efa97fe1)\r\n> \r\n> What scenario would we stop and then re-start an instantiated worker pool?\r\n\r\nI was thinking about single-shot tasks that require a large number of threads, where keeping those threads alive for the entire lifetime of the software would be unnecessary overhead. E.g. RPC commands such as `scanblocks`, `rescanblockchain`, `dumputxoset`, etc.\r\n\r\nRight now, the thread pool code is simple enough and not very configurable, but we will likely add more features and tuning options over time. Those settings will likely only be available during the node's initialization, so we need to construct the pool early with them (note: we really don't want to go back to the global `ArgsManager` dependency). And, at the same time, we don’t want to keep a large number of threads running when there's no work for them.",
      "created_at": "2026-02-10T20:19:18Z",
      "updated_at": "2026-02-10T20:20:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2790087151",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790087151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 108,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790107690",
      "pull_request_review_id": 3781386136,
      "id": 2790107690,
      "node_id": "PRRC_kwDOABII586mTaoq",
      "diff_hunk": "@@ -0,0 +1,211 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <tinyformat.h>\n+#include <util/check.h>\n+#include <util/thread.h>\n+\n+#include <algorithm>\n+#include <condition_variable>\n+#include <functional>\n+#include <future>\n+#include <queue>\n+#include <stdexcept>\n+#include <thread>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Interrupt()` stops new task submission and lets queued ones drain\n+ *   in the background. Callers can continue other shutdown steps and call\n+ *   Stop() at the end to ensure no remaining tasks are left to execute.\n+ *\n+ * - `Stop()` prevents further task submission and blocks until all the\n+ *   queued ones are completed.\n+ */\n+class ThreadPool\n+{\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock, [&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, strprintf(\"%s_pool_%d\", m_name, i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            // Ensure Stop() is not called from a worker thread while workers are still registered,\n+            // otherwise a self-join deadlock would occur.\n+            auto id = std::this_thread::get_id();\n+            for (const auto& worker : m_workers) assert(worker.get_id() != id);\n+            // Early shutdown to return right away on any concurrent Submit() call\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Enqueues a new task for asynchronous execution.\n+     *\n+     * Returns a `std::future` that provides the task's result or propagates\n+     * any exception it throws.\n+     * Note: Ignoring the returned future requires guarding the task against\n+     * uncaught exceptions, as they would otherwise be silently discarded.\n+     */\n+    template <class F> [[nodiscard]] EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)",
      "path": "src/util/threadpool.h",
      "position": 155,
      "original_position": 155,
      "commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "original_commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "in_reply_to_id": 2784073214,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I'm pretty sure I had it like that, and there was a suggestion to change it to the current form. Since it was merely an aesthetic change and there were so many comments, I didn't put much thought into it.",
      "created_at": "2026-02-10T20:24:08Z",
      "updated_at": "2026-02-10T20:24:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2790107690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790107690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 154,
      "original_start_line": 154,
      "start_side": "RIGHT",
      "line": 155,
      "original_line": 155,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790150996",
      "pull_request_review_id": 3781436866,
      "id": 2790150996,
      "node_id": "PRRC_kwDOABII586mTlNU",
      "diff_hunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <random.h>\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+#include <util/time.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+// General test values\n+int NUM_WORKERS_DEFAULT = 0;\n+constexpr char POOL_NAME[] = \"test\";\n+constexpr auto WAIT_TIMEOUT = 120s;\n+\n+struct ThreadPoolFixture {\n+    ThreadPoolFixture() {\n+        NUM_WORKERS_DEFAULT = FastRandomContext().randrange(GetNumCores()) + 1;\n+        LogInfo(\"thread pool workers count: %d\", NUM_WORKERS_DEFAULT);\n+    }\n+};\n+\n+// Test Cases Overview\n+// 0) Submit task to a non-started pool.\n+// 1) Submit tasks and verify completion.\n+// 2) Maintain all threads busy except one.\n+// 3) Wait for work to finish.\n+// 4) Wait for result object.\n+// 5) The task throws an exception, catch must be done in the consumer side.\n+// 6) Busy workers, help them by processing tasks externally.\n+// 7) Recursive submission of tasks.\n+// 8) Submit task when all threads are busy, stop pool and verify task gets executed.\n+// 9) Congestion test; create more workers than available cores.\n+// 10) Ensure Interrupt() prevents further submissions.\n+BOOST_FIXTURE_TEST_SUITE(threadpool_tests, ThreadPoolFixture)\n+\n+#define WAIT_FOR(futures)                                                         \\\n+    do {                                                                          \\\n+        for (const auto& f : futures) {                                           \\\n+            BOOST_REQUIRE(f.wait_for(WAIT_TIMEOUT) == std::future_status::ready); \\\n+        }                                                                         \\\n+    } while (0)\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, const std::shared_future<void>& blocker_future, int num_of_threads_to_block)\n+{\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WAIT_FOR(ready_futures);\n+    return blocking_tasks;\n+}\n+\n+// Test 0, submit task to a non-started pool\n+BOOST_AUTO_TEST_CASE(submit_task_before_start_fails)\n+{\n+    ThreadPool threadPool(POOL_NAME);\n+    BOOST_CHECK_EXCEPTION((void)threadPool.Submit([]{ return false; }), std::runtime_error, [&](const std::runtime_error& e) {\n+        BOOST_CHECK_EQUAL(e.what(), \"No active workers; cannot accept new tasks\");",
      "path": "src/test/threadpool_tests.cpp",
      "position": 77,
      "original_position": 77,
      "commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "original_commit_id": "c528dd5f8ccc3955b00bdba869f0a774efa97fe1",
      "in_reply_to_id": 2785224696,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "I think I answered this in a previous comment. \r\n\r\nI'm happy using `HasReason`, but not adding a dependency to the entire unit test framework machinery (`<test/util/setup_common.h>`). The rationale is that the thread pool lives at a lower level and shouldn't get access to the chainstate, feerate, or any other higher-level concepts. It is also easier for anyone who wants to experiment with the code to be able to pull the thread pool alone into a separate project. This last sentence comes from experience.. it would have been so nice to have constructed the script interpreter and other primitives in this way, not so tied to the whole project machinery.. we would have found many issues and improvements way faster.\r\n\r\nSo, in short, I agree with using it. I just think we should first move the `HasReason` class to a general utility file, to beak the general framework dependency. It could be done in a quick follow-up, happy to do it or ACK it if someone wants to tackle it too.",
      "created_at": "2026-02-10T20:34:48Z",
      "updated_at": "2026-02-10T20:35:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2790150996",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790150996"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": 76,
      "original_start_line": 76,
      "start_side": "RIGHT",
      "line": 77,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790169080",
      "pull_request_review_id": 3781460221,
      "id": 2790169080,
      "node_id": "PRRC_kwDOABII586mTpn4",
      "diff_hunk": "@@ -342,16 +274,9 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n             req->WriteHeader(\"Connection\", \"close\");\n             // TODO: Implement specific error formatting for the REST and JSON-RPC servers responses.\n             req->WriteReply(HTTP_INTERNAL_SERVER_ERROR, err_msg);\n-            return false;\n-        });\n+        };\n \n-        assert(g_work_queue);\n-        if (g_work_queue->Enqueue(item.get())) {\n-            (void)item.release(); /* if true, queue took ownership */\n-        } else {\n-            LogWarning(\"Request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\");\n-            item->req->WriteReply(HTTP_SERVICE_UNAVAILABLE, \"Work queue depth exceeded\");\n-        }\n+        [[maybe_unused]] auto _{g_threadpool_http.Submit(std::move(item))};",
      "path": "src/httpserver.cpp",
      "position": 144,
      "original_position": 144,
      "commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "original_commit_id": "38fd85c676a072ebf256e806beda9d7533790baa",
      "in_reply_to_id": 2789304427,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "> My guess is that for this use case of threadpool, we don't need to examine the return value of the future from the task, but other uses of threadpool will not discard it?\r\n\r\nyeah, any parallelizable user single-shot locking command would wait for it to finish. The examples I have in my head are RPC-related like `scanblocks`, `rescanblockchain`, `dumputxoset`, etc. But we could surely find more just by looking at the REST server or the GUI.",
      "created_at": "2026-02-10T20:39:28Z",
      "updated_at": "2026-02-10T20:39:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2790169080",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2790169080"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 279,
      "original_line": 279,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2799781242",
      "pull_request_review_id": 3791991892,
      "id": 2799781242,
      "node_id": "PRRC_kwDOABII586m4UV6",
      "diff_hunk": "@@ -147,6 +147,9 @@ def main(self):\n         except subprocess.CalledProcessError as e:\n             self.log.exception(f\"Called Process failed with stdout='{e.stdout}'; stderr='{e.stderr}';\")\n             self.success = TestStatus.FAILED\n+        except JSONRPCException as e:\n+            self.log.exception(f\"Failure during setup: error={e.error}, http_status={e.http_status}\")",
      "path": "test/functional/test_framework/test_framework.py",
      "position": 5,
      "original_position": 5,
      "commit_id": "6354b4fd7fe819eb13274b212e426a7d10ca75d3",
      "original_commit_id": "6354b4fd7fe819eb13274b212e426a7d10ca75d3",
      "in_reply_to_id": 2783817192,
      "user": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false,
        "name": null,
        "patch_url": null
      },
      "body": "The commit message seems wrong, because `Unexpected exception` will *also* log all details that are available.\r\n\r\nSo this seems like the wrong fix. The correct fix would be to add any missing details to the exception string. Fixed in https://github.com/bitcoin/bitcoin/pull/34575",
      "created_at": "2026-02-12T16:15:44Z",
      "updated_at": "2026-02-12T16:15:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2799781242",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2799781242"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    }
  ]
}