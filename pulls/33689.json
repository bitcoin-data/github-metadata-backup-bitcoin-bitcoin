{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689",
    "id": 2940741002,
    "node_id": "PR_kwDOABII586vSCWK",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/33689",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/33689.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/33689.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/f5eca8d5252a68f0fbc8b5efec021c75744555b6",
    "number": 33689,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "http: replace WorkQueue and single threads handling for ThreadPool",
    "user": {
      "login": "furszy",
      "id": 5377650,
      "node_id": "MDQ6VXNlcjUzNzc2NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/furszy",
      "html_url": "https://github.com/furszy",
      "followers_url": "https://api.github.com/users/furszy/followers",
      "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
      "organizations_url": "https://api.github.com/users/furszy/orgs",
      "repos_url": "https://api.github.com/users/furszy/repos",
      "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/furszy/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This has been a recent discovery; the general thread pool class created for #26966, cleanly \r\nintegrates into the HTTP server. It simplifies init, shutdown and requests execution logic.\r\nReplacing code that was never unit tested for code that is properly unit and fuzz tested.\r\nAlthough our functional test framework extensively uses this RPC interface (thatâ€™s how\r\nweâ€™ve been ensuring its correct behavior so far - which is not the best).\r\n\r\nThis clearly separates the responsibilities:\r\nThe HTTP server now focuses solely on receiving and dispatching requests, while ThreadPool handles\r\nconcurrency, queuing, and execution.\r\n\r\nThis will also allows us to experiment with further performance improvements at the task queuing and\r\nexecution level, such as a lock-free structure or task prioritization or any other implementation detail\r\nlike coroutines in the future, without having to deal with HTTP code that lives on a different layer.\r\n\r\nNote:\r\nThe rationale behind introducing the ThreadPool first is to be able to easily cherry-pick it across different\r\nworking paths. Some of the ones that are benefited from it are #26966 for the parallelization of the indexes\r\ninitial sync, #31132 for the parallelization of the inputs fetching procedure, #32061 for the libevent replacement,\r\nthe kernel API #30595 (https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2413702370) to avoid blocking validation among others use cases not publicly available.\r\n\r\nNote 2:\r\nI could have created a wrapper around the existing code and replaced the `WorkQueue` in a subsequent\r\ncommit, but it didnâ€™t seem worth the extra commits and review effort. The `ThreadPool` implements\r\nessentially the same functionality in a more modern and cleaner way.",
    "labels": [
      {
        "id": 98279177,
        "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
        "name": "RPC/REST/ZMQ",
        "color": "0052cc",
        "default": false
      }
    ],
    "created_at": "2025-10-23T14:36:44Z",
    "updated_at": "2025-10-29T20:28:05Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "58d0d9da93048a70b295715a32a1c3f3f7a893bd",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "furszy:2025_threadpool_http_server",
      "ref": "2025_threadpool_http_server",
      "sha": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 143624913,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDM2MjQ5MTM=",
        "name": "bitcoin-core",
        "full_name": "furszy/bitcoin-core",
        "owner": {
          "login": "furszy",
          "id": 5377650,
          "node_id": "MDQ6VXNlcjUzNzc2NTA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/furszy",
          "html_url": "https://github.com/furszy",
          "followers_url": "https://api.github.com/users/furszy/followers",
          "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
          "organizations_url": "https://api.github.com/users/furszy/orgs",
          "repos_url": "https://api.github.com/users/furszy/repos",
          "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/furszy/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/furszy/bitcoin-core",
        "description": "Bitcoin-Core",
        "fork": true,
        "url": "https://api.github.com/repos/furszy/bitcoin-core",
        "archive_url": "https://api.github.com/repos/furszy/bitcoin-core/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/furszy/bitcoin-core/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/furszy/bitcoin-core/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/furszy/bitcoin-core/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/furszy/bitcoin-core/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/furszy/bitcoin-core/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/furszy/bitcoin-core/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/furszy/bitcoin-core/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/furszy/bitcoin-core/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/furszy/bitcoin-core/contributors",
        "deployments_url": "https://api.github.com/repos/furszy/bitcoin-core/deployments",
        "downloads_url": "https://api.github.com/repos/furszy/bitcoin-core/downloads",
        "events_url": "https://api.github.com/repos/furszy/bitcoin-core/events",
        "forks_url": "https://api.github.com/repos/furszy/bitcoin-core/forks",
        "git_commits_url": "https://api.github.com/repos/furszy/bitcoin-core/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/furszy/bitcoin-core/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/furszy/bitcoin-core/git/tags%7B/sha%7D",
        "git_url": "git://github.com/furszy/bitcoin-core.git",
        "issue_comment_url": "https://api.github.com/repos/furszy/bitcoin-core/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/furszy/bitcoin-core/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/furszy/bitcoin-core/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/furszy/bitcoin-core/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/furszy/bitcoin-core/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/furszy/bitcoin-core/languages",
        "merges_url": "https://api.github.com/repos/furszy/bitcoin-core/merges",
        "milestones_url": "https://api.github.com/repos/furszy/bitcoin-core/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/furszy/bitcoin-core/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/furszy/bitcoin-core/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/furszy/bitcoin-core/releases%7B/id%7D",
        "ssh_url": "git@github.com:furszy/bitcoin-core.git",
        "stargazers_url": "https://api.github.com/repos/furszy/bitcoin-core/stargazers",
        "statuses_url": "https://api.github.com/repos/furszy/bitcoin-core/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/furszy/bitcoin-core/subscribers",
        "subscription_url": "https://api.github.com/repos/furszy/bitcoin-core/subscription",
        "tags_url": "https://api.github.com/repos/furszy/bitcoin-core/tags",
        "teams_url": "https://api.github.com/repos/furszy/bitcoin-core/teams",
        "trees_url": "https://api.github.com/repos/furszy/bitcoin-core/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/furszy/bitcoin-core.git",
        "hooks_url": "https://api.github.com/repos/furszy/bitcoin-core/hooks",
        "svn_url": "https://github.com/furszy/bitcoin-core",
        "homepage": "",
        "language": "C++",
        "forks_count": 3,
        "stargazers_count": 5,
        "watchers_count": 5,
        "size": 438764,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-29T15:55:00Z",
        "created_at": "2018-08-05T15:28:43Z",
        "updated_at": "2025-10-29T14:29:59Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "292ea0eb8982faef460c210bd4215d603f487463",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38128,
        "stargazers_count": 86500,
        "watchers_count": 86500,
        "size": 295475,
        "default_branch": "master",
        "open_issues_count": 732,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-29T16:53:46Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-10-29T19:31:50Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 596,
    "deletions": 119,
    "changed_files": 7,
    "commits": 3,
    "review_comments": 33,
    "comments": 7
  },
  "events": [
    {
      "event": "labeled",
      "id": 20456160660,
      "node_id": "LE_lADOABII587TTDKpzwAAAATDSD2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20456160660",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:36:49Z",
      "label": {
        "name": "RPC/REST/ZMQ",
        "color": "0052cc"
      }
    },
    {
      "event": "commented",
      "id": 3437382621,
      "node_id": "IC_kwDOABII587M4kvd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437382621",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:36:51Z",
      "updated_at": "2025-10-29T18:20:54Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33689.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [pinheadmz](https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3395201777) |\n| Concept ACK | [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3390482262) |\n| Approach ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3453541325) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo over LogPrintf [WIP, NOMERGE, DRAFT] by maflcko)\n* [#27731](https://github.com/bitcoin/bitcoin/pull/27731) (Prevent file descriptor exhaustion from too many RPC calls by fjahr)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437382621",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3437391085,
      "node_id": "IC_kwDOABII587M4mzt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437391085",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:38:28Z",
      "updated_at": "2025-10-23T14:38:28Z",
      "author_association": "MEMBER",
      "body": "concept ACK :-) will be reviewing this",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437391085",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "review_requested",
      "id": 20456472339,
      "node_id": "RRE_lADOABII587TTDKpzwAAAATDTP8T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20456472339",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:49:34Z",
      "requested_reviewer": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 3437452461,
      "node_id": "IC_kwDOABII587M41yt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437452461",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:50:33Z",
      "updated_at": "2025-10-23T14:50:33Z",
      "author_association": "MEMBER",
      "body": "Adding myself as i wrote the original shitty code.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437452461",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3442252872,
      "node_id": "IC_kwDOABII587NLJxI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3442252872",
      "actor": {
        "login": "Raimo33",
        "id": 104778891,
        "node_id": "U_kgDOBj7Miw",
        "avatar_url": "https://avatars.githubusercontent.com/u/104778891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Raimo33",
        "html_url": "https://github.com/Raimo33",
        "followers_url": "https://api.github.com/users/Raimo33/followers",
        "following_url": "https://api.github.com/users/Raimo33/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Raimo33/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Raimo33/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Raimo33/subscriptions",
        "organizations_url": "https://api.github.com/users/Raimo33/orgs",
        "repos_url": "https://api.github.com/users/Raimo33/repos",
        "events_url": "https://api.github.com/users/Raimo33/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Raimo33/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-24T09:54:44Z",
      "updated_at": "2025-10-24T09:55:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "Can't we use an already existing open source library instead of reinventing the wheel?",
      "user": {
        "login": "Raimo33",
        "id": 104778891,
        "node_id": "U_kgDOBj7Miw",
        "avatar_url": "https://avatars.githubusercontent.com/u/104778891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Raimo33",
        "html_url": "https://github.com/Raimo33",
        "followers_url": "https://api.github.com/users/Raimo33/followers",
        "following_url": "https://api.github.com/users/Raimo33/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Raimo33/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Raimo33/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Raimo33/subscriptions",
        "organizations_url": "https://api.github.com/users/Raimo33/orgs",
        "repos_url": "https://api.github.com/users/Raimo33/repos",
        "events_url": "https://api.github.com/users/Raimo33/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Raimo33/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3442252872",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3444568607,
      "node_id": "IC_kwDOABII587NT_If",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3444568607",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-24T19:17:48Z",
      "updated_at": "2025-10-24T19:17:48Z",
      "author_association": "MEMBER",
      "body": "> Can't we use an already existing open source library instead of reinventing the wheel?\r\n\r\nThat's a good question. It's usually where we all start.\r\nGenerally, the project consensus is to avoid introducing new external dependencies (unless theyâ€™re maintained by us) to minimize potential attack vectors. This doesnâ€™t mean we should reinvent everything, just that we need to be very careful about what we decide to include.\r\n\r\nThat being said, for the changes introduced in this PR, can argue that weâ€™re encapsulating, documenting, and unit + fuzz testing code that wasnâ€™t covered before, while also improving separation of responsibilities. Weâ€™re not adding anything more complex or that behaves radically differently from what we currently have.\r\nThe nice property of this PR is that it will let us experiment with more complex approaches in the future without having to deal with application-specific code (like the HTTP server code). This also includes learning from other open source libraries for sure.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3444568607",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3453541325,
      "node_id": "IC_kwDOABII587N2NvN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3453541325",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-27T22:17:47Z",
      "updated_at": "2025-10-27T22:17:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3453541325",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "reviewed",
      "id": 3389146181,
      "node_id": "PRR_kwDOABII587KAkRF",
      "url": null,
      "actor": null,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T14:51:59Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3389146181",
      "submitted_at": "2025-10-28T14:51:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "reviewed",
      "id": 3389972243,
      "node_id": "PRR_kwDOABII587KDt8T",
      "url": null,
      "actor": null,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T17:26:24Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3389972243",
      "submitted_at": "2025-10-28T17:26:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20562303395,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATJm9mj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20562303395",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/195a96258f970c384ce180d57e73616904ef5fa1",
      "created_at": "2025-10-28T19:08:59Z"
    },
    {
      "event": "reviewed",
      "id": 3390482262,
      "node_id": "PRR_kwDOABII587KFqdW",
      "url": null,
      "actor": null,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T19:29:51Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, thanks for the seperation from the initial index PR.",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3390482262",
      "submitted_at": "2025-10-28T19:29:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "reviewed",
      "id": 3385232782,
      "node_id": "PRR_kwDOABII587Jxo2O",
      "url": null,
      "actor": null,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-29T15:28:32Z",
      "author_association": "MEMBER",
      "body": "ACK 195a96258f970c384ce180d57e73616904ef5fa1\n\nBuilt and tested on macos/arm64 and debian/x86. Reviewed each commit and left a few comments.\n\nI also tested the branch against other popular software that consumes the HTTP interface by running their CI:\n- [bitcoinjs-lib](https://github.com/pinheadmz/bitcoinjs-lib/pull/2)\n- [rpc-bitcoin](https://github.com/pinheadmz/rpc-bitcoin/pull/2)\n- [eclair](https://github.com/pinheadmz/eclair/pull/2)\n- [lnd](https://github.com/pinheadmz/lnd/pull/2/)\n- [electrs](https://github.com/pinheadmz/electrs/pull/2)\n\n\nThe http worker threads are clearly labeled and visible in htop!\n\n<img width=\"559\" height=\"304\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/d27aedd8-0ac1-4659-8fa9-6389e49b0b8f\" />\n\n\n\n\n<details><summary>Show Signature</summary>\n\n```\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nACK 195a96258f970c384ce180d57e73616904ef5fa1\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmkCMdwACgkQ5+KYS2KJ\nyTriXA//RRnzezUHdmzRlKmoSDA+ZBHz0RY3z2LGk63izb/YdYaJY9JBZL2Y9BA8\nK2nyexdSDC/DFOm4H56ddEe6ChlB7w+uZc92SgFSLSvavInpZ80KEJRk07vgoIL7\nhwuyyevWyOOU32iz1NE3q316TMaJmzVsPhRGwbdmTXNwJLtUX6g4czfh28ajW1DC\nY9ULKwT36rFHRcKwC1YZYuBJUNBZWQgVBcydcmS1UEykY4mBnCW9knrATwn/29b7\n2AYPV+yuaiy9OpDEOJ8iKtZOPGR36NrIUleMUqruq4Sy2/TnJtm3AKNK0336/Fxu\nMqVyPKSyusg7kBA6f2h/2+NHpbyLoboYhjZew+HvED/aFfi+Jla+nxybkUYXfciL\npzbND22TTuRGB1fKU7AwPD0TO9JwOTU385iEdpoGq8rbT3EpgPr31N4TeDQDJx5t\njPzzWZYj43JMuIc3bm/K5S2HYSdFZUEDQC81kbND+jOLF6YkJwS9794anLO38tvi\nfip/eLK8Nw4pmWnW63/9lc+Y/1gLpgLDMxxhA1NKJyytk7z2IRo7vJKck6TqAjcZ\nnU8Wv9/ful5ndDJfLIKuYT9jqRk9ORohVwv+P+ppuO8jhFjhuswxPlFJKkMXTeZn\nhGi8QCrAUuibvVuLfLKVExJqSmmeUAkTVKp5ZTWLwNB7IkZrSoo=\n=hZYm\n-----END PGP SIGNATURE-----\n```\n\npinheadmz's public key is [on openpgp.org](https://keys.openpgp.org/vks/v1/by-fingerprint/E61773CD6E01040E2F1BD78CE7E2984B6289C93A)\n</details>\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3385232782",
      "submitted_at": "2025-10-29T15:28:32Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "review_requested",
      "id": 20583424463,
      "node_id": "RRE_lADOABII587TTDKpzwAAAATK3iHP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20583424463",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:28:37Z",
      "requested_reviewer": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "review_requested",
      "id": 20583424830,
      "node_id": "RRE_lADOABII587TTDKpzwAAAATK3iM-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20583424830",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:28:38Z",
      "requested_reviewer": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDg1OGNiZjQ3ZWFiNzI3MTc4ZjE2MjA0YjNiZTMzZmY1NTFkYzFjOWE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/858cbf47eab727178f16204b3be33ff551dc1c9a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/858cbf47eab727178f16204b3be33ff551dc1c9a",
      "tree": {
        "sha": "9b1850341957f384c5963db2a9ef9a01ee1eca0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b1850341957f384c5963db2a9ef9a01ee1eca0a"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9b1850341957f384c5963db2a9ef9a01ee1eca0a\nparent d30f149360d10de31bd7f7369aa61ce8be0837b5\nauthor furszy <matiasfurszyfer@protonmail.com> 1676560833 -0300\ncommitter furszy <matiasfurszyfer@protonmail.com> 1761753147 -0400\n\nutil: introduce general purpose thread pool\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAmkCODsACgkQXdI8zGhq\npiNNyg/+KT9wlHeH40zSEBQyoWT5nwZ8DIhzrwfp8LpFSPQ3DgXb5k8VyZIaFYPb\nLBv/Z94UCAXRvUj/mVvHFTEY9/u9vZpsKXuJc8xkSjuEhXf69Fa/+RuphcFwIwsS\nCItDhdBgbNhoQBrLxK2+bQeR4vdFXquJysjcIO8c1ltJ7glJly0PZ3/9B4Ir6/fM\n2pyCBMP0FPJQkoMHQBMde3q2fwT+Joch4ds/wa0ia4gI4aaju0funxk4JdwxDXx8\n6Qa2GJ+iNEelKPsuyMfsOrKVY/cu7c2YzTm14clnjj6iNUCrlioJTtvz9NNWciiq\nL6TwzabI3PDCZvvEKCJDg1YPz0gMpbVFzEvZLYAOfbsg/iCUieqEoQcz+VAYR+b2\n0jhyje2VT19ptjWTbUzCQbdO1A0Dikh2O157Bk/1D0cf7a3ZrvOwAhVF6cVBrRAf\nKvpOf10zgpS0znCfnHH0ld/TStYxXvNRcP67dRY9uAOEnRYDn/efUtxrIVQ+zOd8\ngIbVStMrZMlWptfJVp1qXMHnAlgWuWrfqUKeUuljyWEQSOgpZ3ls9EJge5xDrcWO\nlPKr81lYCovdwinuX2GEQfsugGeickzeWnSsoRZilgHHGG6SV4tXPjJ/fWsndCib\npYj4HsxO3diu2s2qRtadvl+BjWec+4mhEdWjujCDPyyl0gisIXk=\n=sfCq\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d30f149360d10de31bd7f7369aa61ce8be0837b5",
          "sha": "d30f149360d10de31bd7f7369aa61ce8be0837b5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d30f149360d10de31bd7f7369aa61ce8be0837b5"
        }
      ],
      "message": "util: introduce general purpose thread pool",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-29T15:52:27Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2023-02-16T15:20:33Z"
      },
      "sha": "858cbf47eab727178f16204b3be33ff551dc1c9a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMzM2E4YTU5YTNjMjM1ZDc3NWY4ODlmZWU5OTVjZmVlNzQ5MWIxZjA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/333a8a59a3c235d775f889fee995cfee7491b1f0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/333a8a59a3c235d775f889fee995cfee7491b1f0",
      "tree": {
        "sha": "4b59025d106581941081c9fe83562abe5c265e2e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b59025d106581941081c9fe83562abe5c265e2e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4b59025d106581941081c9fe83562abe5c265e2e\nparent 858cbf47eab727178f16204b3be33ff551dc1c9a\nauthor TheCharlatan <seb.kung@gmail.com> 1758561710 -0400\ncommitter furszy <matiasfurszyfer@protonmail.com> 1761753264 -0400\n\nfuzz: add test case for threadpool\n\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAmkCOLAACgkQXdI8zGhq\npiP31hAAhs4MunUL8i1gTNkgoAlxd/sV7X/jlpEitsmHLZmrppqjW8f0Pj8BeGH2\nwOiM3FZBdQLDT6BqmZFW+SUFwSTMejMC4rhcP6VsGmHo60sPwCm9HNv8/JP9ksyp\n44oMMAKu1N3ZIOEvnDcVM0l1xJVqDr4o8IV3Fi/eRR9cLhX0P0YJi09xTRMuZMdu\nj969yDsA5dHO6XZjq/Nt2SGJ9ftCQmhICHxY0aJgGq74a4YaXKp0k3RS7fNbnUFI\nwdnANRLQn3dA4Qlb06ZuzUbncIeEHHCnT8WIxJPhFUZt/dvCEOPRloTgEHRhwEIz\npP5Net0ks9Y1ZxuGqAZwph2Cju8Y08uLMPsmQOQ8Wsm7eQgIU11mIyqX2zfpnmZ9\nskWRZKOIr3MDycIRhDk71sk+Pv1GUS1DQWjAAsSGmyVDZJ8ZCSpiwzVLYZk8NPT5\n4lTxNBVF0BxJjR8SgzEahiWamCIN+X2t5iSntrBWVM393SyPjUHBQYNE6JfChXBO\n5c7vWh8GBHBZ1xg3x9yI200jemGDBFK4r106zTfOxIhfPYLy7uMkt6u6CUnFg6Cv\nx1lk+eAbjtPLlZSTQk737Sdj5I7COgksTNENy4ieN/+lJWwupnXg3GN7opeHIVtx\ni1JmCMvrnir5cmvjyeFMzpNTQdrTTwn07MaC3BBgb8+vpOAE4rY=\n=rte9\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/858cbf47eab727178f16204b3be33ff551dc1c9a",
          "sha": "858cbf47eab727178f16204b3be33ff551dc1c9a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/858cbf47eab727178f16204b3be33ff551dc1c9a"
        }
      ],
      "message": "fuzz: add test case for threadpool\n\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-29T15:54:24Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-22T17:21:50Z"
      },
      "sha": "333a8a59a3c235d775f889fee995cfee7491b1f0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGY1ZWNhOGQ1MjUyYTY4ZjBmYmM4YjVlZmVjMDIxYzc1NzQ0NTU1YjY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "tree": {
        "sha": "79555688482db4fa16e03dd93018009cd15061f7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79555688482db4fa16e03dd93018009cd15061f7"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 79555688482db4fa16e03dd93018009cd15061f7\nparent 333a8a59a3c235d775f889fee995cfee7491b1f0\nauthor furszy <matiasfurszyfer@protonmail.com> 1760791720 -0400\ncommitter furszy <matiasfurszyfer@protonmail.com> 1761753264 -0400\n\nhttp: replace WorkQueue and threads handling for ThreadPool\n\nReplace the HTTP server's WorkQueue implementation and single threads\nhandling code with ThreadPool for processing HTTP requests. The\nThreadPool class encapsulates all this functionality on a reusable\nclass, properly unit and fuzz tested (the previous code was not\nunit nor fuzz tested at all).\n\nThis cleanly separates responsibilities:\nThe HTTP server now focuses solely on receiving and dispatching requests,\nwhile ThreadPool handles concurrency, queuing, and execution.\nIt simplifies init, shutdown and requests tracking.\n\nThis also allows us to experiment with further performance improvements at\nthe task queuing and execution level, such as a lock-free structure, task\nprioritization or any other performance improvement in the future, without\nhaving to deal with HTTP code that lives on a different layer.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAmkCOLAACgkQXdI8zGhq\npiO9kQ//S9aCFsmT2eltp9RY5HhambxoyXJQ9pRcNJJ6mTMFkSe5JvAuxBvf2rND\n+RkqAfPS7d0ej/p66q19EK46wB9CUStYof4UkE63gNXMOAUQ1OlIs79YVAnwUGAa\nf919bY6eF210lQMtTaxF5KKhUbRppLEzYg/DI9AK6kxbOm2DzSCb3ZHPq6LhJs6L\nwO2XzLVsFpCXL8huGlr45O17ATFugP29tgsv/lictrjXAGjrX1KlBgEvKanMHK+D\n68lL24anK+D1MluIUQ0VwCNTCApHnnCeqnprbAwaMw8WdBiPiK69XedpkMlCh4XL\nbUUHf5oeYcY+yWBIHkw3ZVwKZRVvkdaHok+59MAw4qRq+BUs2GI+z6Fq0Uk9sz6i\n1kgu6k6jqr87nb3nYz49qeCZ6QyV2qBOP77b3mpJ45D/LdOIHWZXcPoygpHimKrS\nOEsPJ8am625GKQnVlaxbrSdMMd7pbW+YHxQc4nl4d5mWWc4lmwo2tlGUKW40t6hi\nTMtukVDGsCuDJ7VecqF757h1Nt7f1+dY2JH/3YQKaIakHsV9kuPfAB16ZmPZLqHw\nSzpOV/+FO7g81SGKmNXdAmSjwy4Nm8GjiHMKvgfUatqNwpsi+sKCOib+utHeuFEW\nJ6JS2p9Zp1Pv76RR5EnJsiSaFlO12OdMjmXQbpC/u+8Cr4x0u3E=\n=muAK\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/333a8a59a3c235d775f889fee995cfee7491b1f0",
          "sha": "333a8a59a3c235d775f889fee995cfee7491b1f0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/333a8a59a3c235d775f889fee995cfee7491b1f0"
        }
      ],
      "message": "http: replace WorkQueue and threads handling for ThreadPool\n\nReplace the HTTP server's WorkQueue implementation and single threads\nhandling code with ThreadPool for processing HTTP requests. The\nThreadPool class encapsulates all this functionality on a reusable\nclass, properly unit and fuzz tested (the previous code was not\nunit nor fuzz tested at all).\n\nThis cleanly separates responsibilities:\nThe HTTP server now focuses solely on receiving and dispatching requests,\nwhile ThreadPool handles concurrency, queuing, and execution.\nIt simplifies init, shutdown and requests tracking.\n\nThis also allows us to experiment with further performance improvements at\nthe task queuing and execution level, such as a lock-free structure, task\nprioritization or any other performance improvement in the future, without\nhaving to deal with HTTP code that lives on a different layer.",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-29T15:54:24Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-18T12:48:40Z"
      },
      "sha": "f5eca8d5252a68f0fbc8b5efec021c75744555b6"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20584251694,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATK6sEu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20584251694",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "created_at": "2025-10-29T15:55:01Z"
    },
    {
      "event": "commented",
      "id": 3462430016,
      "node_id": "IC_kwDOABII587OYH1A",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3462430016",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:56:44Z",
      "updated_at": "2025-10-29T15:56:44Z",
      "author_association": "MEMBER",
      "body": "Oh, awesome extensive test and review @pinheadmz! you rock!",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3462430016",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "mentioned",
      "id": 20584303883,
      "node_id": "MEE_lADOABII587TTDKpzwAAAATK640L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20584303883",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:56:46Z"
    },
    {
      "event": "subscribed",
      "id": 20584303920,
      "node_id": "SE_lADOABII587TTDKpzwAAAATK640w",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20584303920",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-29T15:56:46Z"
    },
    {
      "event": "reviewed",
      "id": 3395201777,
      "node_id": "PRR_kwDOABII587KXqrx",
      "url": null,
      "actor": null,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-29T18:20:50Z",
      "author_association": "MEMBER",
      "body": "ACK f5eca8d5252a68f0fbc8b5efec021c75744555b6\n\nminor changes since last ack\n\n<details><summary>Show Signature</summary>\n\n```\n-----BEGIN PGP SIGNED MESSAGE-----\nHash: SHA256\n\nACK f5eca8d5252a68f0fbc8b5efec021c75744555b6\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAEBCAAdFiEE5hdzzW4BBA4vG9eM5+KYS2KJyToFAmkCWuYACgkQ5+KYS2KJ\nyTpb9RAAgxNlDQlqkVfnIK2Xt8BQmRsiG+1KHQGJA2d3RHoxjFg2129fj47y5i+t\nGlatlcsXEcibI2D0F22sKSzY1u0LWy4GYLI1d12JAIewA99n/lRr1ktDk3v64pp8\nkldvYpd8UBs7DCHSJhPs4HbOPgwIILPASdSbQTb+6m48X5jg+cu+yMBuANVq3sbB\n9I8rUlbUgRva5voy3EGRkXsGTuwcaCoLDNHnnjrqQkJMYTym47rMF/xTZJJ11isF\nQrpzFu+P2tFy1oj0bGd4e5EhqNk++qfRCuw9sGLgLL6YEHzC/ihVH/L5NAxoeJX4\nL0yX09BG5wDrbUQvZn4w1uaQz39Uor5mb8+tZyDUyRmO9MrG5AHomUtfdbiYLwSO\n007bLD+WX4Hxode47xCdhUhqflXqbHD2mhkf5ESyUgGu3smSHSQQosuzIJiVmTn9\nb2UJG6see/tckFvart6YLn1AIu9uCyUMmB+hZIcSasZv95oEHv1YB3E5dcKUmq0d\nA1cUHIhNvU4i/hNy2xgijgSjDdpVQMFbLYUt9y4ZnzpJXFd7mnbpHVUVM1P+Onvp\nScAtgvosXfbd5PjnAQWsMWgSmVHUtSc4t9GPjGlRYaVpHFkEbqWpWeKrYqMkU3id\n9YiFP9BueWNbNV7OBlB0LcfCpwO2WbvfJOW93/jxDovc0tgohbU=\n=c8aD\n-----END PGP SIGNATURE-----\n```\n\npinheadmz's public key is [on openpgp.org](https://keys.openpgp.org/vks/v1/by-fingerprint/E61773CD6E01040E2F1BD78CE7E2984B6289C93A)\n</details>\n",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3395201777",
      "submitted_at": "2025-10-29T18:20:49Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2466909255",
      "pull_request_review_id": 3385232782,
      "id": 2466909255,
      "node_id": "PRRC_kwDOABII586TCgxH",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\nnit: don't bother with the year any more... (applies to all new files)",
      "created_at": "2025-10-27T19:55:45Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2466909255",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2466909255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469840049",
      "pull_request_review_id": 3389146181,
      "id": 2469840049,
      "node_id": "PRRC_kwDOABII586TNsSx",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Isn't this comment already implied by `GUARDED_BY(m_mutex)`? Also it's written by the control thread and read by worker threads, so of course it must only be modified while holding the mutex. This comment doesn't add anything IMO.\r\n",
      "created_at": "2025-10-28T14:38:48Z",
      "updated_at": "2025-10-28T14:51:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469840049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469840049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469885604",
      "pull_request_review_id": 3389146181,
      "id": 2469885604,
      "node_id": "PRRC_kwDOABII586TN3ak",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm unclear what the purpose of this function is. It interrupts the workers, like `Stop`, but doesn't join them or wait for them to finish.\r\nIf the idea is to clear the workqueue and park the threads without being able to add more tasks, it does not accomplish that since the threads will exit their loops as well and not be parked on the cv.",
      "created_at": "2025-10-28T14:51:52Z",
      "updated_at": "2025-10-28T14:52:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469885604",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469885604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469913117",
      "pull_request_review_id": 3385232782,
      "id": 2469913117,
      "node_id": "PRRC_kwDOABII586TN-Id",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\nI was wondering if there's any way to assert that the unblocked tasks are all executing on one single remaining worker... would it be insane to use a non-atomic `int` here?",
      "created_at": "2025-10-28T14:58:40Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469913117",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469913117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469957844",
      "pull_request_review_id": 3385232782,
      "id": 2469957844,
      "node_id": "PRRC_kwDOABII586TOJDU",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 202,
      "original_position": 202,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\n[As mentioned before](https://github.com/bitcoin/bitcoin/pull/26966#discussion_r2228839630), not a blocker but i feel like sleeps like this are test-flakiness waiting to happen ...",
      "created_at": "2025-10-28T15:11:05Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469957844",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469957844"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 202,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469965455",
      "pull_request_review_id": 3385232782,
      "id": 2469965455,
      "node_id": "PRRC_kwDOABII586TOK6P",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);\n+\n+        // Now process manually\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.ProcessTask();\n+        }\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 209,
      "original_position": 209,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "c219b93c3b043de202bdf3c65b433fd17af2da89\r\n\r\nbelt-and-suspenders, could \r\n`BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);`\r\nI just like the symmetry in a test since you assert the value is `20` before taking action.",
      "created_at": "2025-10-28T15:13:17Z",
      "updated_at": "2025-10-29T15:28:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469965455",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469965455"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469981199",
      "pull_request_review_id": 3389342066,
      "id": 2469981199,
      "node_id": "PRRC_kwDOABII586TOOwP",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Isn't this comment already implied by `GUARDED_BY(m_mutex)`? Also it's written by the control thread and read by worker threads, so of course it must only be modified while holding the mutex. This comment doesn't add anything IMO.\r\n\r\nWhat I meant there is that the variable shouldnâ€™t be an atomic bool alone (in case someone propose to change it in the future). It must share the same mutex as the condition variable; otherwise, workers might not see the update. This is stated in the `std::condition_variable` ref.\r\nI mention it because it is very tempting to avoid locking the mutex during task submission in this way, and might seen like a harmless optimization, but it turns out to cause very subtle issues.\r\n\r\nMaybe you have a better way to state this? Happy to change it if it is not being understood as supposed.",
      "created_at": "2025-10-28T15:18:19Z",
      "updated_at": "2025-10-28T15:45:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469981199",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469981199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470045034",
      "pull_request_review_id": 3389433909,
      "id": 2470045034,
      "node_id": "PRRC_kwDOABII586TOeVq",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I'm unclear what the purpose of this function is. It interrupts the workers, like `Stop`, but doesn't join them or wait for them to finish.\r\n> If the idea is to clear the workqueue and park the threads without being able to add more tasks, it does not accomplish that since the threads will exit their loops as well and not be parked on the cv.\r\n\r\nActually, the goal is to keep the current shutdown semantics unchanged. The process already follows two stages: first, we stop accepting new requests and events (e.g. unregistering the libevent callback to stop incoming requests); then, once no new work can be queued, we call `Stop()` and wait for the remaining tasks to finish before tearing down the objects.\r\n\r\n`Interrupt()` belongs to the first stage. It basically block new task submissions during shutdown to avoid queue growth. Itâ€™s not intended to clear the queue or park the threads. It is there just to avoid pilling up new tasks during shutdown.",
      "created_at": "2025-10-28T15:35:33Z",
      "updated_at": "2025-10-28T15:36:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470045034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470045034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470109463",
      "pull_request_review_id": 3389526506,
      "id": 2470109463,
      "node_id": "PRRC_kwDOABII586TOuEX",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see, so the goal is to stop the thread pool but in a non-blocking way. Could the same be done via a bool parameter to `Stop` to skip joining? Then `Stop` will be called without that bool set in the destructor to join the threads, if this behavior is desired (like it is in the http server).\r\nAlso, could we modify `Start` in that case to not assert on number of threads if `m_interrupt` is true, and instead join them if we stilll have outstanding threads?",
      "created_at": "2025-10-28T15:52:39Z",
      "updated_at": "2025-10-28T16:22:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470109463",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470109463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470161972",
      "pull_request_review_id": 3389600535,
      "id": 2470161972,
      "node_id": "PRRC_kwDOABII586TO640",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see. Then perhaps more directly:\r\n```suggestion\r\n    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\r\n```",
      "created_at": "2025-10-28T16:04:23Z",
      "updated_at": "2025-10-28T16:04:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470161972",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470161972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470424759",
      "pull_request_review_id": 3389972243,
      "id": 2470424759,
      "node_id": "PRRC_kwDOABII586TP7C3",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe we should relax this atomic operation so that it doesn't hide any issues by synchronizing them for us.\r\n```suggestion\r\n    void operator()() const { m_counter.fetch_add(1, std::memory_order_relaxed); }\r\n```",
      "created_at": "2025-10-28T17:26:23Z",
      "updated_at": "2025-10-28T17:26:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470424759",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470424759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470732607",
      "pull_request_review_id": 3390383679,
      "id": 2470732607,
      "node_id": "PRRC_kwDOABII586TRGM_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Could the same be done via a bool parameter to Stop to skip joining?\r\n\r\nIf we do that, the threads wouldn't remain in the `m_workers` vector anymore. They'd be swapped out on the first call. That means we wouldn't be able to wait for them to finish later on, which would be quite bad since weâ€™d lose track of when all requests are fulfilled before destroying the backend objects (that's basically what joining the threads mean for us right now). And this could lead to requests accessing null pointers if we proceed with the shutdown without waiting on the threads to join, etc.\r\n\r\n> Also, could we modify Start in that case to not assert on number of threads, and instead join them if m_interrupt is true and we still have outstanding threads?\r\n\r\nWe could also help them process task by calling `ProcessTask()` if something like that happens.\r\nBut I'm not sure that's the best design. We would be integrating `Stop()` inside `Start()`, which would make callers less careful on when to call `Stop()`, which should be part of their code design.\r\n\r\nStill, I don't think we should worry nor overthink this now. The current code starts and stops the thread pool only once during the entire app's lifecycle.",
      "created_at": "2025-10-28T19:01:57Z",
      "updated_at": "2025-10-28T19:03:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470732607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470732607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470743689",
      "pull_request_review_id": 3390398684,
      "id": 2470743689,
      "node_id": "PRRC_kwDOABII586TRI6J",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "sounds good, taken. thanks!",
      "created_at": "2025-10-28T19:07:04Z",
      "updated_at": "2025-10-28T19:07:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470743689",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470743689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470749427",
      "pull_request_review_id": 3390405551,
      "id": 2470749427,
      "node_id": "PRRC_kwDOABII586TRKTz",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": 2470424759,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sure, pushed. Thanks!",
      "created_at": "2025-10-28T19:09:07Z",
      "updated_at": "2025-10-28T19:09:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470749427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470749427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470750271",
      "pull_request_review_id": 3390406684,
      "id": 2470750271,
      "node_id": "PRRC_kwDOABII586TRKg_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was thinking like this\r\n```diff\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\nindex 94409facd5..dc1a218abd 100644\r\n--- a/src/util/threadpool.h\r\n+++ b/src/util/threadpool.h\r\n@@ -123,19 +123,19 @@ public:\r\n      *\r\n      * Must be called from a controller (non-worker) thread.\r\n      */\r\n-    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n+    void Stop(bool join_threads = true) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         // Notify workers and join them.\r\n         std::vector<std::thread> threads_to_join;\r\n         {\r\n             LOCK(m_mutex);\r\n             m_interrupt = true;\r\n-            threads_to_join.swap(m_workers);\r\n+            if (join_threads) threads_to_join.swap(m_workers);\r\n         }\r\n         m_cv.notify_all();\r\n         for (auto& worker : threads_to_join) worker.join();\r\n         // Since we currently wait for tasks completion, sanity-check empty queue\r\n-        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\r\n+         if (join_threads) WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\r\n         // Note: m_interrupt is left true until next Start()\r\n     }\r\n \r\n@@ -179,12 +179,6 @@ public:\r\n         task();\r\n     }\r\n \r\n-    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n-    {\r\n-        WITH_LOCK(m_mutex, m_interrupt = true);\r\n-        m_cv.notify_all();\r\n-    }\r\n-\r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         return WITH_LOCK(m_mutex, return m_work_queue.size());\r\n```\r\n\r\n> Still, I don't think we should worry nor overthink this now. The current code starts and stops the thread pool only once during the entire app's lifecycle.\r\n\r\nErr, then why not have threads start during construction? Otherwise there's no need for `Start`.",
      "created_at": "2025-10-28T19:09:28Z",
      "updated_at": "2025-10-28T19:09:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470750271",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470750271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470765839",
      "pull_request_review_id": 3390429167,
      "id": 2470765839,
      "node_id": "PRRC_kwDOABII586TROUP",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You know, we could call `ProcessTask()` during `Stop()` too, which would be a strict improvement over the current locking-wait behavior in master (since we would shut down faster by actively processing pending requests on the shutdown thread as well). This is something that hasnâ€™t been possible until now.\r\nStill, this is material for a follow-up; would say that it is better to keep this PR as contained as possible so all other PRs and working paths that depend on this structure can actually make use of it.",
      "created_at": "2025-10-28T19:15:43Z",
      "updated_at": "2025-10-28T19:17:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470765839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470765839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470784762",
      "pull_request_review_id": 3390460118,
      "id": 2470784762,
      "node_id": "PRRC_kwDOABII586TRS76",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That is a good idea, but not related to my suggestion here :). Yes, that would be a good followup.\r\nI don't think we should have a method that would cause the node to crash if `Start` is called more than once. I disagree and think just calling `Stop` at the beginning of `Start` would be safer than the current implementation.",
      "created_at": "2025-10-28T19:22:53Z",
      "updated_at": "2025-10-28T19:22:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470784762",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470784762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470824383",
      "pull_request_review_id": 3390512679,
      "id": 2470824383,
      "node_id": "PRRC_kwDOABII586TRcm_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "hehe, it seems we sent a message at a similar time and missed yours.\r\n\r\nre `Interrupt()` removal suggestion:\r\n\r\nI find it harder to reason about the current two stages shutdown procedure if we have to call to the same `Stop()` method twice. At that point it would be simpler to just wait for all tasks to finish on the first call and remove the second one. But that seems suboptimal as there is no rush to wait for them at that point of the shutdown sequence.\r\n\r\nAlso, a benefit of keeping `Interrupt()` is that we can build on top of it and have a faster and non-locking way of checking if the thread pool is enabled. \r\nSo callers would be able to call something like `pool.IsRunning()` to see if they can submit tasks without have to worry locking the main mutex and slowing down the workers processing. Something like:\r\n\r\n```diff\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\n--- a/src/util/threadpool.h\t(revision e0ec3232daf2c311471a1da149821bed18853fcc)\r\n+++ b/src/util/threadpool.h\t(date 1761158485938)\r\n@@ -55,6 +55,9 @@\r\n     // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\r\n     bool m_interrupt GUARDED_BY(m_mutex){false};\r\n     std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\r\n+    // Enabled only after Start and disabled early on Stop/Interrupt.\r\n+    // This lets us do non-blocking 'IsRunning' checks.\r\n+    std::atomic<bool> m_running{false};\r\n \r\n     void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n@@ -109,9 +112,11 @@\r\n         m_interrupt = false; // Reset\r\n \r\n         // Create workers\r\n         m_workers.reserve(num_workers);\r\n         for (int i = 0; i < num_workers; i++) {\r\n             m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\r\n         }\r\n+        m_running.store(true, std::memory_order_release);\r\n     }\r\n \r\n     /**\r\n@@ -124,7 +129,9 @@\r\n      */\r\n     void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n-        // Notify workers and join them.\r\n+        // Mark as no longer accepting new tasks\r\n+        m_running.store(false, std::memory_order_release);\r\n+        // Notify workers and join them\r\n         std::vector<std::thread> threads_to_join;\r\n         {\r\n             LOCK(m_mutex);\r\n@@ -147,11 +154,16 @@\r\n     template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     auto Submit(F&& fn)\r\n     {\r\n+        // Quick rejection based on Start/Stop/Interrupt before locking\r\n+        if (!m_running.load(std::memory_order_acquire)) {\r\n+            throw std::runtime_error(\"ThreadPool not running\");\r\n+        }\r\n+\r\n         std::packaged_task task{std::forward<F>(fn)};\r\n         auto future{task.get_future()};\r\n         {\r\n             LOCK(m_mutex);\r\n             if (m_workers.empty() || m_interrupt) {\r\n                 throw std::runtime_error(\"No active workers; cannot accept new tasks\");\r\n             }\r\n             m_work_queue.emplace(std::move(task));\r\n@@ -180,7 +192,9 @@\r\n \r\n     void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n+        m_running.store(false, std::memory_order_release);\r\n         WITH_LOCK(m_mutex, m_interrupt = true);\r\n         m_cv.notify_all();\r\n     }\r\n \r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n@@ -192,6 +206,11 @@\r\n     {\r\n         return WITH_LOCK(m_mutex, return m_workers.size());\r\n     }\r\n+\r\n+    bool IsRunning() const noexcept\r\n+    {\r\n+        return m_running.load(std::memory_order_acquire);\r\n+    }\r\n };\r\n \r\n #endif // BITCOIN_UTIL_THREADPOOL_H\r\n```\r\n\r\n(this is not needed here because we are disconnecting the http callback prior to interrupting the pool but it seems useful in general).",
      "created_at": "2025-10-28T19:37:46Z",
      "updated_at": "2025-10-28T19:50:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470824383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470824383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470845344",
      "pull_request_review_id": 3390538651,
      "id": 2470845344,
      "node_id": "PRRC_kwDOABII586TRhug",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I don't think we should have a method that would cause the node to crash if Start is called more than once. I disagree and think just calling Stop at the beginning of Start would be safer than the current implementation.\r\n\r\nWouldn't you agree that if your code calls `Start()` twice, you have a design issue? Thread pools are typically started once, maintained for the entire appâ€™s lifecycle, and reused across modules. Mainly because creating and destroying threads isnâ€™t cheap. I think itâ€™s fair to expect an exception in that case, as it would indicate poorly structured code.\r\n\r\nI also donâ€™t think anyone would expect `Start()` to wait for all existing threads to shut down and then spawn new ones. That would be a surprising behavior to me. Why would you spawn new ones if you already have threads available?",
      "created_at": "2025-10-28T19:46:09Z",
      "updated_at": "2025-10-28T19:47:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470845344",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470845344"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470851529",
      "pull_request_review_id": 3390546152,
      "id": 2470851529,
      "node_id": "PRRC_kwDOABII586TRjPJ",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "So why have `Start` and `Stop` then? Just start threads in constructor and join in destructor? Use `Interrupt` to stop new tasks from being added. This follows RAII principles.",
      "created_at": "2025-10-28T19:48:41Z",
      "updated_at": "2025-10-28T19:49:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470851529",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470851529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470902222",
      "pull_request_review_id": 3390612876,
      "id": 2470902222,
      "node_id": "PRRC_kwDOABII586TRvnO",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> So why have `Start` and `Stop` then? Just start threads in constructor and join in destructor? Use `Interrupt` to stop new tasks from being added. This follows RAII principles.\r\n\r\nGood question. We could easily build an RAII wrapper on top of this. The approaches arenâ€™t conflicting; it would just be an additional layer over the current code.\r\nYet, I think the current design smoothly integrates with our existing workflows. We already use the `start`, `interrupt`, and `stop` terms throughout the codebase (check `init.cpp` and all our components), so following that general convention makes it easier to reason about these components globally. Even without deep knowledge of the http server workflow, anyone familiar with this convention can quickly hook up new functionality.\r\n\r\nAlso, I suspect weâ€™ll find opportunities for improvements (or smarter shutdown behaviors) along the way that might require customizing `Stop()` with some inputs, so might be better not to enforce RAII too early.",
      "created_at": "2025-10-28T20:11:38Z",
      "updated_at": "2025-10-28T20:13:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470902222",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470902222"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2471097523",
      "pull_request_review_id": 3390873847,
      "id": 2471097523,
      "node_id": "PRRC_kwDOABII586TSfSz",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Follow-up to this convo after some great back-and-forth via DM with Andrew.\r\nUsually, RAII works best when we donâ€™t care exactly when an object gets destroyed. In this case, though, we actually do care about that moment (or, in our terms, when itâ€™s stopped), since it marks the point where there are no pending tasks and itâ€™s safe to tear down the backend handlers.\r\nIf we donâ€™t enforce that explicitly, the shutdown procedure could continue while workers are still active, leading them to access null pointers, etc.\r\nThis is something we canâ€™t guarantee if we just let the object be destroyed whenever the program releases it using RAII. So even using RAII, we would be forced to destroy the object manually anyway. Which kinda defeats the purpose of it.",
      "created_at": "2025-10-28T21:29:59Z",
      "updated_at": "2025-10-28T21:30:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2471097523",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2471097523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473904846",
      "pull_request_review_id": 3394420645,
      "id": 2473904846,
      "node_id": "PRRC_kwDOABII586TdMrO",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> [c219b93](https://github.com/bitcoin/bitcoin/commit/c219b93c3b043de202bdf3c65b433fd17af2da89)\r\n> \r\n> I was wondering if there's any way to assert that the unblocked tasks are all executing on one single remaining worker... would it be insane to use a non-atomic `int` here?\r\n\r\nhmm, even if the non-atomic int works, that doesn't really guarantee that the increment was done in the same thread.\r\nIf we want to be 100% correct, we should store the ids of the threads that processed the tasks on a synchronized structure. Then check that only one id is there.",
      "created_at": "2025-10-29T15:43:28Z",
      "updated_at": "2025-10-29T15:43:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473904846",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473904846"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473946974",
      "pull_request_review_id": 3394471642,
      "id": 2473946974,
      "node_id": "PRRC_kwDOABII586TdW9e",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});",
      "path": "src/test/threadpool_tests.cpp",
      "position": 202,
      "original_position": 202,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469957844,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> [c219b93](https://github.com/bitcoin/bitcoin/commit/c219b93c3b043de202bdf3c65b433fd17af2da89)\r\n> \r\n> [As mentioned before](https://github.com/bitcoin/bitcoin/pull/26966#discussion_r2228839630), not a blocker but i feel like sleeps like this are test-flakiness waiting to happen ...\r\n\r\nThis is one of those \"wait and see if something happens\" scenarios (if any task gets processed). We expect no activity here since all workers are busy.\r\nI'm not sure there is another way of doing this, but if it fails (even if it is not deterministic), thatâ€™s still a useful signal because it means something unexpected happened.",
      "created_at": "2025-10-29T15:49:47Z",
      "updated_at": "2025-10-29T15:50:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473946974",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473946974"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 202,
      "original_line": 202,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473982880",
      "pull_request_review_id": 3394514584,
      "id": 2473982880,
      "node_id": "PRRC_kwDOABII586Tdfug",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to wait on\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+        for (int i = 0; i < num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            }));\n+        }\n+\n+        WaitFor(futures, /*context=*/\"test2 tasks\");\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);\n+\n+        blocker.set_value();\n+        WaitFor(blocking_tasks, /*context=*/\"test2 blocking tasks disabled\");\n+        threadPool.Stop();\n+        BOOST_CHECK_EQUAL(threadPool.WorkersCount(), 0);\n+    }\n+\n+    // Test case 3, wait for work to finish.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<bool> flag = false;\n+        std::future<void> future = threadPool.Submit([&flag]() {\n+            std::this_thread::sleep_for(std::chrono::milliseconds{200});\n+            flag.store(true);\n+        });\n+        future.wait();\n+        BOOST_CHECK(flag.load());\n+    }\n+\n+    // Test case 4, obtain result object.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::future<bool> future_bool = threadPool.Submit([]() {\n+            return true;\n+        });\n+        BOOST_CHECK(future_bool.get());\n+\n+        std::future<std::string> future_str = threadPool.Submit([]() {\n+            return std::string(\"true\");\n+        });\n+        std::string result = future_str.get();\n+        BOOST_CHECK_EQUAL(result, \"true\");\n+    }\n+\n+    // Test case 5, throw exception and catch it on the consumer side.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        int ROUNDS = 5;\n+        std::string err_msg{\"something wrong happened\"};\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(ROUNDS);\n+        for (int i = 0; i < ROUNDS; i++) {\n+            futures.emplace_back(threadPool.Submit([err_msg, i]() {\n+                throw std::runtime_error(err_msg + util::ToString(i));\n+            }));\n+        }\n+\n+        for (int i = 0; i < ROUNDS; i++) {\n+            try {\n+                futures.at(i).get();\n+                BOOST_FAIL(\"Expected exception not thrown\");\n+            } catch (const std::runtime_error& e) {\n+                BOOST_CHECK_EQUAL(e.what(), err_msg + util::ToString(i));\n+            }\n+        }\n+    }\n+\n+    // Test case 6, all workers are busy, help them by processing tasks from outside.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT, /*context=*/\"test6 blocking tasks enabled\");\n+\n+        // Now submit tasks and check that none of them are executed.\n+        int num_tasks = 20;\n+        std::atomic<int> counter = 0;\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.Submit([&counter]() {\n+                counter.fetch_add(1);\n+            });\n+        }\n+        std::this_thread::sleep_for(std::chrono::milliseconds{100});\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 20);\n+\n+        // Now process manually\n+        for (int i = 0; i < num_tasks; i++) {\n+            threadPool.ProcessTask();\n+        }\n+        BOOST_CHECK_EQUAL(counter.load(), num_tasks);",
      "path": "src/test/threadpool_tests.cpp",
      "position": 209,
      "original_position": 209,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469965455,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sounds good. Done as suggested. Thanks",
      "created_at": "2025-10-29T15:55:12Z",
      "updated_at": "2025-10-29T15:55:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473982880",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473982880"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 209,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473984516",
      "pull_request_review_id": 3394516281,
      "id": 2473984516,
      "node_id": "PRRC_kwDOABII586TdgIE",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers",
      "path": "src/test/threadpool_tests.cpp",
      "position": 1,
      "original_position": 1,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2466909255,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sure. Done as suggested.",
      "created_at": "2025-10-29T15:55:23Z",
      "updated_at": "2025-10-29T15:55:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2473984516",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2473984516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474000255",
      "pull_request_review_id": 3394534398,
      "id": 2474000255,
      "node_id": "PRRC_kwDOABII586Tdj9_",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "thread sanitizer would likely pick up on it though if you made it non-atomic.",
      "created_at": "2025-10-29T15:57:41Z",
      "updated_at": "2025-10-29T15:57:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474000255",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474000255"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474671206",
      "pull_request_review_id": 3395333045,
      "id": 2474671206,
      "node_id": "PRRC_kwDOABII586TgHxm",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "true. Closing this.",
      "created_at": "2025-10-29T18:37:02Z",
      "updated_at": "2025-10-29T18:37:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474671206",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474671206"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474735112",
      "pull_request_review_id": 3395398503,
      "id": 2474735112,
      "node_id": "PRRC_kwDOABII586TgXYI",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I mean pick up that it's being written by multiple threads if something breaks the assumptions in this test. It seems like an ok idea. Or am I wrong?",
      "created_at": "2025-10-29T18:44:45Z",
      "updated_at": "2025-10-29T18:44:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474735112",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474735112"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474919127",
      "pull_request_review_id": 3395577438,
      "id": 2474919127,
      "node_id": "PRRC_kwDOABII586ThETX",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I mean pick up that it's being written by multiple threads if something breaks the assumptions in this test. It seems like an ok idea. Or am I wrong?\r\n\r\nI don't think there is any broken assumption. `BlockWorkers()` ensure that all threads except one are blocked. We could go further and check that all tasks submitted post the `BlockWorkers` call are executed by the same thread too, but that seems to be an overkill to me. We are basically ensuring that in another way.",
      "created_at": "2025-10-29T19:05:24Z",
      "updated_at": "2025-10-29T19:05:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2474919127",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2474919127"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475135383",
      "pull_request_review_id": 3395828960,
      "id": 2475135383,
      "node_id": "PRRC_kwDOABII586Th5GX",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sorry for being unclear. I don't think there is any broken assumption either.\r\nHowever, if we made this a non-atomic as suggested, then *if* something in the future were to break this assumption and run these tasks on multiple threads the unit test would break. Thus it would act as a regression test.",
      "created_at": "2025-10-29T19:46:12Z",
      "updated_at": "2025-10-29T19:46:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2475135383",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475135383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475307568",
      "pull_request_review_id": 3396044287,
      "id": 2475307568,
      "node_id": "PRRC_kwDOABII586TijIw",
      "diff_hunk": "@@ -0,0 +1,267 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <util/string.h>\n+#include <util/threadpool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(threadpool_tests)\n+\n+constexpr auto TIMEOUT_SECS = std::chrono::seconds(120);\n+\n+template <typename T>\n+void WaitFor(const std::vector<std::future<T>>& futures, const std::string& context)\n+{\n+    for (size_t i = 0; i < futures.size(); ++i) {\n+        if (futures[i].wait_for(TIMEOUT_SECS) != std::future_status::ready) {\n+            throw std::runtime_error(\"Timeout waiting for: \" + context + \", task index \" + util::ToString(i));\n+        }\n+    }\n+}\n+\n+// Block a number of worker threads by submitting tasks that wait on `blocker_future`.\n+// Returns the futures of the blocking tasks, ensuring all have started and are waiting.\n+std::vector<std::future<void>> BlockWorkers(ThreadPool& threadPool, std::shared_future<void>& blocker_future, int num_of_threads_to_block, const std::string& context) {\n+    // Per-thread ready promises to ensure all workers are actually blocked\n+    std::vector<std::promise<void>> ready_promises(num_of_threads_to_block);\n+    std::vector<std::future<void>> ready_futures;\n+    ready_futures.reserve(num_of_threads_to_block);\n+    for (auto& p : ready_promises) ready_futures.emplace_back(p.get_future());\n+\n+    // Fill all workers with blocking tasks\n+    std::vector<std::future<void>> blocking_tasks;\n+    for (int i = 0; i < num_of_threads_to_block; i++) {\n+        std::promise<void>& ready = ready_promises[i];\n+        blocking_tasks.emplace_back(threadPool.Submit([blocker_future, &ready]() {\n+            ready.set_value();\n+            blocker_future.wait();\n+        }));\n+    }\n+\n+    // Wait until all threads are actually blocked\n+    WaitFor(ready_futures, context);\n+    return blocking_tasks;\n+}\n+\n+BOOST_AUTO_TEST_CASE(threadpool_basic)\n+{\n+    // Test Cases\n+    // 0) Submit task to a non-started pool.\n+    // 1) Submit tasks and verify completion.\n+    // 2) Maintain all threads busy except one.\n+    // 3) Wait for work to finish.\n+    // 4) Wait for result object.\n+    // 5) The task throws an exception, catch must be done in the consumer side.\n+    // 6) Busy workers, help them by processing tasks from outside.\n+    // 7) Recursive submission of tasks.\n+    // 8) Submit task when all threads are busy, stop pool and verify the task gets executed.\n+\n+    const int NUM_WORKERS_DEFAULT = 3;\n+    const std::string POOL_NAME = \"test\";\n+\n+    // Test case 0, submit task to a non-started pool\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        bool err = false;\n+        try {\n+            threadPool.Submit([]() { return false; });\n+        } catch (const std::runtime_error&) { err = true; }\n+        BOOST_CHECK(err);\n+    }\n+\n+    // Test case 1, submit tasks and verify completion.\n+    {\n+        int num_tasks = 50;\n+\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        std::atomic<int> counter = 0;\n+\n+        // Store futures to ensure completion before checking counter.\n+        std::vector<std::future<void>> futures;\n+        futures.reserve(num_tasks);\n+\n+        for (int i = 1; i <= num_tasks; i++) {\n+            futures.emplace_back(threadPool.Submit([&counter, i]() {\n+                counter.fetch_add(i);\n+            }));\n+        }\n+\n+        // Wait for all tasks to finish\n+        WaitFor(futures, /*context=*/\"test1 task\");\n+        int expected_value = (num_tasks * (num_tasks + 1)) / 2; // Gauss sum.\n+        BOOST_CHECK_EQUAL(counter.load(), expected_value);\n+        BOOST_CHECK_EQUAL(threadPool.WorkQueueSize(), 0);\n+    }\n+\n+    // Test case 2, maintain all threads busy except one.\n+    {\n+        ThreadPool threadPool(POOL_NAME);\n+        threadPool.Start(NUM_WORKERS_DEFAULT);\n+        // Single blocking future for all threads\n+        std::promise<void> blocker;\n+        std::shared_future<void> blocker_future(blocker.get_future());\n+        const auto& blocking_tasks = BlockWorkers(threadPool, blocker_future, NUM_WORKERS_DEFAULT-1, /*context=*/\"test2 blocking tasks enabled\");\n+\n+        // Now execute tasks on the single available worker\n+        // and check that all the tasks are executed.\n+        int num_tasks = 15;\n+        std::atomic<int> counter = 0;",
      "path": "src/test/threadpool_tests.cpp",
      "position": 111,
      "original_position": 111,
      "commit_id": "f5eca8d5252a68f0fbc8b5efec021c75744555b6",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469913117,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Sorry for being unclear. I don't think there is any broken assumption either.\r\n> However, if we made this a non-atomic as suggested, then _if_ something in the future were to break this assumption and run these tasks on multiple threads the unit test would break. Thus it would act as a regression test.\r\n\r\nBut as you said, the thread sanitizer would likely complain about that. Weâ€™re accessing the same variable from different threads (main and worker). The main issue, however, will probably be related to thread visibility; changes made in one thread arenâ€™t guaranteed to be visible to another. So that approach seems fragile to me.\r\n\r\nAlso, going back to my initial comment: even if we switch to a non-atomic variable, the test could still pass. If we want it to be fully deterministic, we should store the IDs of the threads that processed the tasks in a synchronized structure, and then check that only one ID is present at the end. That seems to be the most secure approach to me.\r\n\r\nI could push this if have to re-touch. But it doesn't seem to be a blocking feature (at least to me). We do ensure all threads except one are blocked in the test, and we fail if not.",
      "created_at": "2025-10-29T20:28:05Z",
      "updated_at": "2025-10-29T20:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2475307568",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2475307568"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 111,
      "original_line": 111,
      "side": "RIGHT"
    }
  ]
}