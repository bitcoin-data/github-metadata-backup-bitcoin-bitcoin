{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689",
    "id": 2940741002,
    "node_id": "PR_kwDOABII586vSCWK",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/33689",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/33689.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/33689.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/195a96258f970c384ce180d57e73616904ef5fa1",
    "number": 33689,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "http: replace WorkQueue and single threads handling for ThreadPool",
    "user": {
      "login": "furszy",
      "id": 5377650,
      "node_id": "MDQ6VXNlcjUzNzc2NTA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/furszy",
      "html_url": "https://github.com/furszy",
      "followers_url": "https://api.github.com/users/furszy/followers",
      "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
      "organizations_url": "https://api.github.com/users/furszy/orgs",
      "repos_url": "https://api.github.com/users/furszy/repos",
      "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/furszy/received_events",
      "type": "User",
      "site_admin": false,
      "patch_url": null
    },
    "body": "This has been a recent discovery; the general thread pool class created for #26966, cleanly \r\nintegrates into the HTTP server. It simplifies init, shutdown and requests execution logic.\r\nReplacing code that was never unit tested for code that is properly unit and fuzz tested.\r\nAlthough our functional test framework extensively uses this RPC interface (thatâ€™s how\r\nweâ€™ve been ensuring its correct behavior so far - which is not the best).\r\n\r\nThis clearly separates the responsibilities:\r\nThe HTTP server now focuses solely on receiving and dispatching requests, while ThreadPool handles\r\nconcurrency, queuing, and execution.\r\n\r\nThis will also allows us to experiment with further performance improvements at the task queuing and\r\nexecution level, such as a lock-free structure or task prioritization or any other implementation detail\r\nlike coroutines in the future, without having to deal with HTTP code that lives on a different layer.\r\n\r\nNote:\r\nThe rationale behind introducing the ThreadPool first is to be able to easily cherry-pick it across different\r\nworking paths. Some of the ones that are benefited from it are #26966 for the parallelization of the indexes\r\ninitial sync, #31132 for the parallelization of the inputs fetching procedure, #32061 for the libevent replacement,\r\nthe kernel API #30595 (https://github.com/bitcoin/bitcoin/pull/30595#discussion_r2413702370) to avoid blocking validation among others use cases not publicly available.\r\n\r\nNote 2:\r\nI could have created a wrapper around the existing code and replaced the `WorkQueue` in a subsequent\r\ncommit, but it didnâ€™t seem worth the extra commits and review effort. The `ThreadPool` implements\r\nessentially the same functionality in a more modern and cleaner way.",
    "labels": [
      {
        "id": 98279177,
        "node_id": "MDU6TGFiZWw5ODI3OTE3Nw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/RPC/REST/ZMQ",
        "name": "RPC/REST/ZMQ",
        "color": "0052cc",
        "default": false
      }
    ],
    "created_at": "2025-10-23T14:36:44Z",
    "updated_at": "2025-10-28T20:11:38Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merged": false,
    "merge_commit_sha": "7af50127ec8d8a268e9e63a80c7cc40799404aa3",
    "assignees": [],
    "requested_reviewers": [
      {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    ],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "furszy:2025_threadpool_http_server",
      "ref": "2025_threadpool_http_server",
      "sha": "195a96258f970c384ce180d57e73616904ef5fa1",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 143624913,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDM2MjQ5MTM=",
        "name": "bitcoin-core",
        "full_name": "furszy/bitcoin-core",
        "owner": {
          "login": "furszy",
          "id": 5377650,
          "node_id": "MDQ6VXNlcjUzNzc2NTA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/furszy",
          "html_url": "https://github.com/furszy",
          "followers_url": "https://api.github.com/users/furszy/followers",
          "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
          "organizations_url": "https://api.github.com/users/furszy/orgs",
          "repos_url": "https://api.github.com/users/furszy/repos",
          "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/furszy/received_events",
          "type": "User",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/furszy/bitcoin-core",
        "description": "Bitcoin-Core",
        "fork": true,
        "url": "https://api.github.com/repos/furszy/bitcoin-core",
        "archive_url": "https://api.github.com/repos/furszy/bitcoin-core/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/furszy/bitcoin-core/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/furszy/bitcoin-core/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/furszy/bitcoin-core/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/furszy/bitcoin-core/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/furszy/bitcoin-core/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/furszy/bitcoin-core/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/furszy/bitcoin-core/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/furszy/bitcoin-core/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/furszy/bitcoin-core/contributors",
        "deployments_url": "https://api.github.com/repos/furszy/bitcoin-core/deployments",
        "downloads_url": "https://api.github.com/repos/furszy/bitcoin-core/downloads",
        "events_url": "https://api.github.com/repos/furszy/bitcoin-core/events",
        "forks_url": "https://api.github.com/repos/furszy/bitcoin-core/forks",
        "git_commits_url": "https://api.github.com/repos/furszy/bitcoin-core/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/furszy/bitcoin-core/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/furszy/bitcoin-core/git/tags%7B/sha%7D",
        "git_url": "git://github.com/furszy/bitcoin-core.git",
        "issue_comment_url": "https://api.github.com/repos/furszy/bitcoin-core/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/furszy/bitcoin-core/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/furszy/bitcoin-core/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/furszy/bitcoin-core/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/furszy/bitcoin-core/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/furszy/bitcoin-core/languages",
        "merges_url": "https://api.github.com/repos/furszy/bitcoin-core/merges",
        "milestones_url": "https://api.github.com/repos/furszy/bitcoin-core/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/furszy/bitcoin-core/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/furszy/bitcoin-core/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/furszy/bitcoin-core/releases%7B/id%7D",
        "ssh_url": "git@github.com:furszy/bitcoin-core.git",
        "stargazers_url": "https://api.github.com/repos/furszy/bitcoin-core/stargazers",
        "statuses_url": "https://api.github.com/repos/furszy/bitcoin-core/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/furszy/bitcoin-core/subscribers",
        "subscription_url": "https://api.github.com/repos/furszy/bitcoin-core/subscription",
        "tags_url": "https://api.github.com/repos/furszy/bitcoin-core/tags",
        "teams_url": "https://api.github.com/repos/furszy/bitcoin-core/teams",
        "trees_url": "https://api.github.com/repos/furszy/bitcoin-core/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/furszy/bitcoin-core.git",
        "hooks_url": "https://api.github.com/repos/furszy/bitcoin-core/hooks",
        "svn_url": "https://github.com/furszy/bitcoin-core",
        "homepage": "",
        "language": "C++",
        "forks_count": 3,
        "stargazers_count": 5,
        "watchers_count": 5,
        "size": 438472,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-28T19:08:58Z",
        "created_at": "2018-08-05T15:28:43Z",
        "updated_at": "2025-10-26T17:51:27Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "5a58d4915e5ce53b922961b16840709686ce9996",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false,
        "patch_url": null
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false,
          "patch_url": null
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 38125,
        "stargazers_count": 86489,
        "watchers_count": 86489,
        "size": 295439,
        "default_branch": "master",
        "open_issues_count": 731,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2025-10-28T15:59:49Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2025-10-28T18:23:35Z",
        "allow_forking": true,
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 597,
    "deletions": 119,
    "changed_files": 7,
    "commits": 3,
    "review_comments": 22,
    "comments": 6
  },
  "events": [
    {
      "event": "labeled",
      "id": 20456160660,
      "node_id": "LE_lADOABII587TTDKpzwAAAATDSD2U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20456160660",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:36:49Z",
      "label": {
        "name": "RPC/REST/ZMQ",
        "color": "0052cc"
      }
    },
    {
      "event": "commented",
      "id": 3437382621,
      "node_id": "IC_kwDOABII587M4kvd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437382621",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:36:51Z",
      "updated_at": "2025-10-28T19:29:55Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33689.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [pinheadmz](https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437391085), [ismaelsadeeq](https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3390482262) |\n| Approach ACK | [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3453541325) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#31260](https://github.com/bitcoin/bitcoin/pull/31260) (scripted-diff: Type-safe settings retrieval by ryanofsky)\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo over LogPrintf [WIP, NOMERGE, DRAFT] by maflcko)\n* [#27731](https://github.com/bitcoin/bitcoin/pull/27731) (Prevent file descriptor exhaustion from too many RPC calls by fjahr)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437382621",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3437391085,
      "node_id": "IC_kwDOABII587M4mzt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437391085",
      "actor": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:38:28Z",
      "updated_at": "2025-10-23T14:38:28Z",
      "author_association": "MEMBER",
      "body": "concept ACK :-) will be reviewing this",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437391085",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "review_requested",
      "id": 20456472339,
      "node_id": "RRE_lADOABII587TTDKpzwAAAATDTP8T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20456472339",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:49:34Z",
      "requested_reviewer": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "review_requester": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      }
    },
    {
      "event": "commented",
      "id": 3437452461,
      "node_id": "IC_kwDOABII587M41yt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3437452461",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-23T14:50:33Z",
      "updated_at": "2025-10-23T14:50:33Z",
      "author_association": "MEMBER",
      "body": "Adding myself as i wrote the original shitty code.",
      "user": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3437452461",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3442252872,
      "node_id": "IC_kwDOABII587NLJxI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3442252872",
      "actor": {
        "login": "Raimo33",
        "id": 104778891,
        "node_id": "U_kgDOBj7Miw",
        "avatar_url": "https://avatars.githubusercontent.com/u/104778891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Raimo33",
        "html_url": "https://github.com/Raimo33",
        "followers_url": "https://api.github.com/users/Raimo33/followers",
        "following_url": "https://api.github.com/users/Raimo33/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Raimo33/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Raimo33/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Raimo33/subscriptions",
        "organizations_url": "https://api.github.com/users/Raimo33/orgs",
        "repos_url": "https://api.github.com/users/Raimo33/repos",
        "events_url": "https://api.github.com/users/Raimo33/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Raimo33/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-24T09:54:44Z",
      "updated_at": "2025-10-24T09:55:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "Can't we use an already existing open source library instead of reinventing the wheel?",
      "user": {
        "login": "Raimo33",
        "id": 104778891,
        "node_id": "U_kgDOBj7Miw",
        "avatar_url": "https://avatars.githubusercontent.com/u/104778891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Raimo33",
        "html_url": "https://github.com/Raimo33",
        "followers_url": "https://api.github.com/users/Raimo33/followers",
        "following_url": "https://api.github.com/users/Raimo33/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Raimo33/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Raimo33/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Raimo33/subscriptions",
        "organizations_url": "https://api.github.com/users/Raimo33/orgs",
        "repos_url": "https://api.github.com/users/Raimo33/repos",
        "events_url": "https://api.github.com/users/Raimo33/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Raimo33/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3442252872",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3444568607,
      "node_id": "IC_kwDOABII587NT_If",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3444568607",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-24T19:17:48Z",
      "updated_at": "2025-10-24T19:17:48Z",
      "author_association": "MEMBER",
      "body": "> Can't we use an already existing open source library instead of reinventing the wheel?\r\n\r\nThat's a good question. It's usually where we all start.\r\nGenerally, the project consensus is to avoid introducing new external dependencies (unless theyâ€™re maintained by us) to minimize potential attack vectors. This doesnâ€™t mean we should reinvent everything, just that we need to be very careful about what we decide to include.\r\n\r\nThat being said, for the changes introduced in this PR, can argue that weâ€™re encapsulating, documenting, and unit + fuzz testing code that wasnâ€™t covered before, while also improving separation of responsibilities. Weâ€™re not adding anything more complex or that behaves radically differently from what we currently have.\r\nThe nice property of this PR is that it will let us experiment with more complex approaches in the future without having to deal with application-specific code (like the HTTP server code). This also includes learning from other open source libraries for sure.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3444568607",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "commented",
      "id": 3453541325,
      "node_id": "IC_kwDOABII587N2NvN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/3453541325",
      "actor": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2025-10-27T22:17:47Z",
      "updated_at": "2025-10-27T22:17:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK",
      "user": {
        "login": "TheCharlatan",
        "id": 8421793,
        "node_id": "MDQ6VXNlcjg0MjE3OTM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8421793?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheCharlatan",
        "html_url": "https://github.com/TheCharlatan",
        "followers_url": "https://api.github.com/users/TheCharlatan/followers",
        "following_url": "https://api.github.com/users/TheCharlatan/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheCharlatan/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheCharlatan/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheCharlatan/subscriptions",
        "organizations_url": "https://api.github.com/users/TheCharlatan/orgs",
        "repos_url": "https://api.github.com/users/TheCharlatan/repos",
        "events_url": "https://api.github.com/users/TheCharlatan/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheCharlatan/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#issuecomment-3453541325",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/33689"
    },
    {
      "event": "reviewed",
      "id": 3389146181,
      "node_id": "PRR_kwDOABII587KAkRF",
      "url": null,
      "actor": null,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T14:51:59Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3389146181",
      "submitted_at": "2025-10-28T14:51:59Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "reviewed",
      "id": 3389972243,
      "node_id": "PRR_kwDOABII587KDt8T",
      "url": null,
      "actor": null,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T17:26:24Z",
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3389972243",
      "submitted_at": "2025-10-28T17:26:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDk3NmIzYWQzMTYwMGRlYjFmNmY4NTdjOWY1NmYwOGEyYTQ3NTk2MzU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/976b3ad31600deb1f6f857c9f56f08a2a4759635",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/976b3ad31600deb1f6f857c9f56f08a2a4759635",
      "tree": {
        "sha": "196ec5f03b199443100dedaf1f0be2c89eca518f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/196ec5f03b199443100dedaf1f0be2c89eca518f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 196ec5f03b199443100dedaf1f0be2c89eca518f\nparent d30f149360d10de31bd7f7369aa61ce8be0837b5\nauthor furszy <matiasfurszyfer@protonmail.com> 1676560833 -0300\ncommitter furszy <matiasfurszyfer@protonmail.com> 1761678409 -0400\n\nutil: introduce general purpose thread pool\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAmkBFEkACgkQXdI8zGhq\npiOOcw//UQ8TRGIYSF0qD5aRLLP2UuY29cwoFMX2B1da9isXZ5sCwO6maHLk1met\nKmvJovQvDO0fm5WhBa7+mZas7OOBnmr4xVb8c0X1XaYkad/a0yVb60Bi0X+hbVBS\nGWJ3SOlEtbAKco4YcRdIDgw2EbyvVmTE2Mk1Tc2/S2p2XrCccDR9l1nffOGR9XS6\n5aX03un+Ld3vBlEYydiw7VqmFIZgJ3G0HmSDAzrqUGVrAoIYgeRi6U8vMDqoHKAH\nz30dkX6MBUBJSSYSy4Y0x/AisMV/NGIf4/6zmLR7tNBDnqbkf0lLc9Tec2heNZBT\nt8XcfNijbVt8Zrwa5i5lpvo8qQYSkFvwnAt7f0p7W0wsRtqZUirDWc+Z9CuqKWKk\nwhrP3wnl9KR5bCWbJxFEN8+1396X2GFc4tMme2Rig0QRgCsPT3qsin9S4PCV7dF+\nWIRYKauIHxRtXnEjdLYRCcxYXJL4Idqbso++fBKCyopWE6fvnNeOEyOs1U6tt4PV\n4Uisp8TPjZKKuLhL7SFdTnWGRZe5mhc+iRkbx4PjUClyUOREhajhhfpKX7stnHp0\nxCc4QGJY18QxWl9iQasjf8EgkgB4yIo6ebdum9K3L2KODXHzQTHL64JKzUNv7rCL\nzMzmtKNAOQNn7BMCsig5JZu0J0uBQdn1RJYGrmdL61Ad1C6eghc=\n=FWVS\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d30f149360d10de31bd7f7369aa61ce8be0837b5",
          "sha": "d30f149360d10de31bd7f7369aa61ce8be0837b5",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/d30f149360d10de31bd7f7369aa61ce8be0837b5"
        }
      ],
      "message": "util: introduce general purpose thread pool",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-28T19:06:49Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2023-02-16T15:20:33Z"
      },
      "sha": "976b3ad31600deb1f6f857c9f56f08a2a4759635"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJmNzgwYzcyMTcyMTI4Njg3MDJkZjJmM2E0ZDhjMjA5MjcwMTNmOWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf780c7217212868702df2f3a4d8c20927013f9c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bf780c7217212868702df2f3a4d8c20927013f9c",
      "tree": {
        "sha": "5847742d57fdb7a9792e90df7e8755f5971f771f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5847742d57fdb7a9792e90df7e8755f5971f771f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 5847742d57fdb7a9792e90df7e8755f5971f771f\nparent 976b3ad31600deb1f6f857c9f56f08a2a4759635\nauthor TheCharlatan <seb.kung@gmail.com> 1758561710 -0400\ncommitter furszy <matiasfurszyfer@protonmail.com> 1761678409 -0400\n\nfuzz: add test case for threadpool\n\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAmkBFEkACgkQXdI8zGhq\npiPj8g//YiB0/MMvKitBL6ueDDFHc9A5KeN6JdWEmCSxRLifqcGw1mtWWQA3QBOd\n6afNaHlV385OBpRGyHMePmMqhOqb9uPdaNcEkecN82Wt+0ULAO2Rg+kNug49OSRa\nEoJ61kwlezg007GzBre8yVfA1SGI1N/vXGY/o41tj94zu2Tzww0zTeUXuxcMPqB1\nbQvv51WzDJmlK/EWNhRNv37nbYOehGVBGH7yu6NoDsZdxvFl5YwaANAW8KGGKlh0\nwg4dKKMY2ctnJIjUjfOyrygNUuYluai7eRX4Jg6nuAxMxsAcSw/uqx6AmMN7KnZf\nd20nk7nyZfpS96+089PjEBMlZ2I0GnA0W8bfqUn0EoqvU549NpF9UNWakQABBzY0\ndZQc1s+sELIAdeiIJbXxPFi/6OiIIoZdNksTBeZJ3hpIykJSVSxXBOmVXpI2oktM\nbB0Fe3L2qYDSckHRcalP6sUJ7wZQ4CZofWmp4A6KCJX4OY5kXoQh/VHysSFvzby2\npD60FMIAAeDivLp0IGYJYZE8QitHpqjgO63JMppm+ExsFMXTG+sp2wv5W2oDT8Rh\nDMj5tQoWNp9aO5WGUo1dH8lnyxTsLtoSZHaECwUtaqwDgUNhe4g3wTYLq0hMDkGu\nerWI3ygOqtTWj+TXNk2YDRQ99m9q43eWtzPDxuB7UET5w40HC28=\n=7bLa\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/976b3ad31600deb1f6f857c9f56f08a2a4759635",
          "sha": "976b3ad31600deb1f6f857c9f56f08a2a4759635",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/976b3ad31600deb1f6f857c9f56f08a2a4759635"
        }
      ],
      "message": "fuzz: add test case for threadpool\n\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-28T19:06:49Z"
      },
      "author": {
        "name": "TheCharlatan",
        "email": "seb.kung@gmail.com",
        "date": "2025-09-22T17:21:50Z"
      },
      "sha": "bf780c7217212868702df2f3a4d8c20927013f9c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE5NWE5NjI1OGY5NzBjMzg0Y2UxODBkNTdlNzM2MTY5MDRlZjVmYTE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/195a96258f970c384ce180d57e73616904ef5fa1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/195a96258f970c384ce180d57e73616904ef5fa1",
      "tree": {
        "sha": "a43ab4fc193ce31a77d38d2cc37f07123bc35822",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a43ab4fc193ce31a77d38d2cc37f07123bc35822"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a43ab4fc193ce31a77d38d2cc37f07123bc35822\nparent bf780c7217212868702df2f3a4d8c20927013f9c\nauthor furszy <matiasfurszyfer@protonmail.com> 1760791720 -0400\ncommitter furszy <matiasfurszyfer@protonmail.com> 1761678410 -0400\n\nhttp: replace WorkQueue and threads handling for ThreadPool\n\nReplace the HTTP server's WorkQueue implementation and single threads\nhandling code with ThreadPool for processing HTTP requests. The\nThreadPool class encapsulates all this functionality on a reusable\nclass, properly unit and fuzz tested (the previous code was not\nunit nor fuzz tested at all).\n\nThis cleanly separates responsibilities:\nThe HTTP server now focuses solely on receiving and dispatching requests,\nwhile ThreadPool handles concurrency, queuing, and execution.\nIt simplifies init, shutdown and requests tracking.\n\nThis also allows us to experiment with further performance improvements at\nthe task queuing and execution level, such as a lock-free structure, task\nprioritization or any other performance improvement in the future, without\nhaving to deal with HTTP code that lives on a different layer.\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEA++0fqwRHQpmlZfQXdI8zGhqpiMFAmkBFEoACgkQXdI8zGhq\npiP10A/+IpJM5DGKy32F3NGaTpZCKoIHcNkFlR8/7k1fD8yeT+m76gwjbsb118z7\nTg7YzhGpmrFhuiSCqCEJAGB6OnLN2WKLAFfJag93ZrkKP9zR76uCZWTGjuL5tKOM\nbAXdRPYYxMhjZd8BF8lijx59vGB9rRr31mjzIIzka75SNdBeBiD++fPUCVcdXIH+\nSDS1gDaHCIEkbrPmSDQi0m2PvNzY7PozZWvyRuuPckIQLXlKuSFMznbWXqFE25qL\n/JtogqU1BXKxVZaTPkdibaOmnfhRZM2y1wnMHozAFXaQNy4EE2j16suGayUOg5vT\nV+BYVc7RWB5aSb7O9zMLsjNDOImDIyZWwpr0LSIlsYq8vuKBbLZ+07zcwDQzblit\nQgtEJKdzmg9tYdLSltQ0TzEUBRekmPfBkp30o6jbylvmhqaUBWPA1x8ZibYWUqZW\nmtCtkns5QGV5dn2hJYsZVpvZN0pps/nYOWXpq/GN43SP+LvcvOVXjPzpmv6tyoiU\nqy1HujbeeDctGn0W67ajBHAuWSpZ2mujbOOhSInLI9MsOyoSQMjFBl1aT/WlDH1I\nar2iAAO5M0cvKWvGvx+R794od8F3CJjpK4obYaXm3pfCwk0umLWdTeLgKJyMvxOT\nFexzZqzbMoLBpM1KwxLLopu9lls07Xp+9ybsH5EdzGfflYuQSJw=\n=6w47\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bf780c7217212868702df2f3a4d8c20927013f9c",
          "sha": "bf780c7217212868702df2f3a4d8c20927013f9c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bf780c7217212868702df2f3a4d8c20927013f9c"
        }
      ],
      "message": "http: replace WorkQueue and threads handling for ThreadPool\n\nReplace the HTTP server's WorkQueue implementation and single threads\nhandling code with ThreadPool for processing HTTP requests. The\nThreadPool class encapsulates all this functionality on a reusable\nclass, properly unit and fuzz tested (the previous code was not\nunit nor fuzz tested at all).\n\nThis cleanly separates responsibilities:\nThe HTTP server now focuses solely on receiving and dispatching requests,\nwhile ThreadPool handles concurrency, queuing, and execution.\nIt simplifies init, shutdown and requests tracking.\n\nThis also allows us to experiment with further performance improvements at\nthe task queuing and execution level, such as a lock-free structure, task\nprioritization or any other performance improvement in the future, without\nhaving to deal with HTTP code that lives on a different layer.",
      "committer": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-28T19:06:50Z"
      },
      "author": {
        "name": "furszy",
        "email": "matiasfurszyfer@protonmail.com",
        "date": "2025-10-18T12:48:40Z"
      },
      "sha": "195a96258f970c384ce180d57e73616904ef5fa1"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 20562303395,
      "node_id": "HRFPE_lADOABII587TTDKpzwAAAATJm9mj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/20562303395",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": "https://api.github.com/repos/furszy/bitcoin-core/commits/195a96258f970c384ce180d57e73616904ef5fa1",
      "created_at": "2025-10-28T19:08:59Z"
    },
    {
      "event": "reviewed",
      "id": 3390482262,
      "node_id": "PRR_kwDOABII587KFqdW",
      "url": null,
      "actor": null,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "commit_url": null,
      "created_at": null,
      "updated_at": "2025-10-28T19:29:51Z",
      "author_association": "MEMBER",
      "body": "Concept ACK, thanks for the seperation from the initial index PR.",
      "user": {
        "login": "ismaelsadeeq",
        "id": 48946461,
        "node_id": "MDQ6VXNlcjQ4OTQ2NDYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/48946461?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ismaelsadeeq",
        "html_url": "https://github.com/ismaelsadeeq",
        "followers_url": "https://api.github.com/users/ismaelsadeeq/followers",
        "following_url": "https://api.github.com/users/ismaelsadeeq/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ismaelsadeeq/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ismaelsadeeq/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ismaelsadeeq/subscriptions",
        "organizations_url": "https://api.github.com/users/ismaelsadeeq/orgs",
        "repos_url": "https://api.github.com/users/ismaelsadeeq/repos",
        "events_url": "https://api.github.com/users/ismaelsadeeq/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ismaelsadeeq/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#pullrequestreview-3390482262",
      "submitted_at": "2025-10-28T19:29:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469840049",
      "pull_request_review_id": 3389146181,
      "id": 2469840049,
      "node_id": "PRRC_kwDOABII586TNsSx",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Isn't this comment already implied by `GUARDED_BY(m_mutex)`? Also it's written by the control thread and read by worker threads, so of course it must only be modified while holding the mutex. This comment doesn't add anything IMO.\r\n",
      "created_at": "2025-10-28T14:38:48Z",
      "updated_at": "2025-10-28T14:51:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469840049",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469840049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469885604",
      "pull_request_review_id": 3389146181,
      "id": 2469885604,
      "node_id": "PRRC_kwDOABII586TN3ak",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I'm unclear what the purpose of this function is. It interrupts the workers, like `Stop`, but doesn't join them or wait for them to finish.\r\nIf the idea is to clear the workqueue and park the threads without being able to add more tasks, it does not accomplish that since the threads will exit their loops as well and not be parked on the cv.",
      "created_at": "2025-10-28T14:51:52Z",
      "updated_at": "2025-10-28T14:52:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469885604",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469885604"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469981199",
      "pull_request_review_id": 3389342066,
      "id": 2469981199,
      "node_id": "PRRC_kwDOABII586TOOwP",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Isn't this comment already implied by `GUARDED_BY(m_mutex)`? Also it's written by the control thread and read by worker threads, so of course it must only be modified while holding the mutex. This comment doesn't add anything IMO.\r\n\r\nWhat I meant there is that the variable shouldnâ€™t be an atomic bool alone (in case someone propose to change it in the future). It must share the same mutex as the condition variable; otherwise, workers might not see the update. This is stated in the `std::condition_variable` ref.\r\nI mention it because it is very tempting to avoid locking the mutex during task submission in this way, and might seen like a harmless optimization, but it turns out to cause very subtle issues.\r\n\r\nMaybe you have a better way to state this? Happy to change it if it is not being understood as supposed.",
      "created_at": "2025-10-28T15:18:19Z",
      "updated_at": "2025-10-28T15:45:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2469981199",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2469981199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470045034",
      "pull_request_review_id": 3389433909,
      "id": 2470045034,
      "node_id": "PRRC_kwDOABII586TOeVq",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I'm unclear what the purpose of this function is. It interrupts the workers, like `Stop`, but doesn't join them or wait for them to finish.\r\n> If the idea is to clear the workqueue and park the threads without being able to add more tasks, it does not accomplish that since the threads will exit their loops as well and not be parked on the cv.\r\n\r\nActually, the goal is to keep the current shutdown semantics unchanged. The process already follows two stages: first, we stop accepting new requests and events (e.g. unregistering the libevent callback to stop incoming requests); then, once no new work can be queued, we call `Stop()` and wait for the remaining tasks to finish before tearing down the objects.\r\n\r\n`Interrupt()` belongs to the first stage. It basically block new task submissions during shutdown to avoid queue growth. Itâ€™s not intended to clear the queue or park the threads. It is there just to avoid pilling up new tasks during shutdown.",
      "created_at": "2025-10-28T15:35:33Z",
      "updated_at": "2025-10-28T15:36:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470045034",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470045034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470109463",
      "pull_request_review_id": 3389526506,
      "id": 2470109463,
      "node_id": "PRRC_kwDOABII586TOuEX",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see, so the goal is to stop the thread pool but in a non-blocking way. Could the same be done via a bool parameter to `Stop` to skip joining? Then `Stop` will be called without that bool set in the destructor to join the threads, if this behavior is desired (like it is in the http server).\r\nAlso, could we modify `Start` in that case to not assert on number of threads if `m_interrupt` is true, and instead join them if we stilll have outstanding threads?",
      "created_at": "2025-10-28T15:52:39Z",
      "updated_at": "2025-10-28T16:22:47Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470109463",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470109463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470161972",
      "pull_request_review_id": 3389600535,
      "id": 2470161972,
      "node_id": "PRRC_kwDOABII586TO640",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I see. Then perhaps more directly:\r\n```suggestion\r\n    // Note: m_interrupt must be guarded by m_mutex, and cannot be replaced by an unguarded atomic bool.\r\n```",
      "created_at": "2025-10-28T16:04:23Z",
      "updated_at": "2025-10-28T16:04:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470161972",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470161972"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470424759",
      "pull_request_review_id": 3389972243,
      "id": 2470424759,
      "node_id": "PRRC_kwDOABII586TP7C3",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": null,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Maybe we should relax this atomic operation so that it doesn't hide any issues by synchronizing them for us.\r\n```suggestion\r\n    void operator()() const { m_counter.fetch_add(1, std::memory_order_relaxed); }\r\n```",
      "created_at": "2025-10-28T17:26:23Z",
      "updated_at": "2025-10-28T17:26:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470424759",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470424759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470732607",
      "pull_request_review_id": 3390383679,
      "id": 2470732607,
      "node_id": "PRRC_kwDOABII586TRGM_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> Could the same be done via a bool parameter to Stop to skip joining?\r\n\r\nIf we do that, the threads wouldn't remain in the `m_workers` vector anymore. They'd be swapped out on the first call. That means we wouldn't be able to wait for them to finish later on, which would be quite bad since weâ€™d lose track of when all requests are fulfilled before destroying the backend objects (that's basically what joining the threads mean for us right now). And this could lead to requests accessing null pointers if we proceed with the shutdown without waiting on the threads to join, etc.\r\n\r\n> Also, could we modify Start in that case to not assert on number of threads, and instead join them if m_interrupt is true and we still have outstanding threads?\r\n\r\nWe could also help them process task by calling `ProcessTask()` if something like that happens.\r\nBut I'm not sure that's the best design. We would be integrating `Stop()` inside `Start()`, which would make callers less careful on when to call `Stop()`, which should be part of their code design.\r\n\r\nStill, I don't think we should worry nor overthink this now. The current code starts and stops the thread pool only once during the entire app's lifecycle.",
      "created_at": "2025-10-28T19:01:57Z",
      "updated_at": "2025-10-28T19:03:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470732607",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470732607"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470743689",
      "pull_request_review_id": 3390398684,
      "id": 2470743689,
      "node_id": "PRRC_kwDOABII586TRI6J",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.",
      "path": "src/util/threadpool.h",
      "position": 1,
      "original_position": 53,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469840049,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "sounds good, taken. thanks!",
      "created_at": "2025-10-28T19:07:04Z",
      "updated_at": "2025-10-28T19:07:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470743689",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470743689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470749427",
      "pull_request_review_id": 3390405551,
      "id": 2470749427,
      "node_id": "PRRC_kwDOABII586TRKTz",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) 2025-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <common/system.h>\n+#include <logging.h>\n+#include <util/threadpool.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <atomic>\n+#include <future>\n+#include <queue>\n+#include <iostream>\n+\n+struct ExpectedException : std::runtime_error {\n+    explicit ExpectedException(const std::string& msg) : std::runtime_error(msg) {}\n+};\n+\n+struct ThrowTask {\n+    void operator()() const { throw ExpectedException(\"fail\"); }\n+};\n+\n+struct CounterTask {\n+    std::atomic_uint32_t& m_counter;\n+    explicit CounterTask(std::atomic_uint32_t& counter) : m_counter{counter} {}\n+    void operator()() const { m_counter.fetch_add(1); }",
      "path": "src/test/fuzz/threadpool.cpp",
      "position": 1,
      "original_position": 28,
      "commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "original_commit_id": "bb71b0e3bf51be28be9c81fc957e3877891f1ef2",
      "in_reply_to_id": 2470424759,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "Sure, pushed. Thanks!",
      "created_at": "2025-10-28T19:09:07Z",
      "updated_at": "2025-10-28T19:09:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470749427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470749427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470750271",
      "pull_request_review_id": 3390406684,
      "id": 2470750271,
      "node_id": "PRRC_kwDOABII586TRKg_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "I was thinking like this\r\n```diff\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\nindex 94409facd5..dc1a218abd 100644\r\n--- a/src/util/threadpool.h\r\n+++ b/src/util/threadpool.h\r\n@@ -123,19 +123,19 @@ public:\r\n      *\r\n      * Must be called from a controller (non-worker) thread.\r\n      */\r\n-    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n+    void Stop(bool join_threads = true) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         // Notify workers and join them.\r\n         std::vector<std::thread> threads_to_join;\r\n         {\r\n             LOCK(m_mutex);\r\n             m_interrupt = true;\r\n-            threads_to_join.swap(m_workers);\r\n+            if (join_threads) threads_to_join.swap(m_workers);\r\n         }\r\n         m_cv.notify_all();\r\n         for (auto& worker : threads_to_join) worker.join();\r\n         // Since we currently wait for tasks completion, sanity-check empty queue\r\n-        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\r\n+         if (join_threads) WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\r\n         // Note: m_interrupt is left true until next Start()\r\n     }\r\n \r\n@@ -179,12 +179,6 @@ public:\r\n         task();\r\n     }\r\n \r\n-    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n-    {\r\n-        WITH_LOCK(m_mutex, m_interrupt = true);\r\n-        m_cv.notify_all();\r\n-    }\r\n-\r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n         return WITH_LOCK(m_mutex, return m_work_queue.size());\r\n```\r\n\r\n> Still, I don't think we should worry nor overthink this now. The current code starts and stops the thread pool only once during the entire app's lifecycle.\r\n\r\nErr, then why not have threads start during construction? Otherwise there's no need for `Start`.",
      "created_at": "2025-10-28T19:09:28Z",
      "updated_at": "2025-10-28T19:09:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470750271",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470750271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470765839",
      "pull_request_review_id": 3390429167,
      "id": 2470765839,
      "node_id": "PRRC_kwDOABII586TROUP",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "You know, we could call `ProcessTask()` during `Stop()` too, which would be a strict improvement over the current locking-wait behavior in master (since we would shut down faster by actively processing pending requests on the shutdown thread as well). This is something that hasnâ€™t been possible until now.\r\nStill, this is material for a follow-up; would say that it is better to keep this PR as contained as possible so all other PRs and working paths that depend on this structure can actually make use of it.",
      "created_at": "2025-10-28T19:15:43Z",
      "updated_at": "2025-10-28T19:17:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470765839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470765839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470784762",
      "pull_request_review_id": 3390460118,
      "id": 2470784762,
      "node_id": "PRRC_kwDOABII586TRS76",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "That is a good idea, but not related to my suggestion here :). Yes, that would be a good followup.\r\nI don't think we should have a method that would cause the node to crash if `Start` is called more than once. I disagree and think just calling `Stop` at the beginning of `Start` would be safer than the current implementation.",
      "created_at": "2025-10-28T19:22:53Z",
      "updated_at": "2025-10-28T19:22:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470784762",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470784762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470824383",
      "pull_request_review_id": 3390512679,
      "id": 2470824383,
      "node_id": "PRRC_kwDOABII586TRcm_",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "hehe, it seems we sent a message at a similar time and missed yours.\r\n\r\nre `Interrupt()` removal suggestion:\r\n\r\nI find it harder to reason about the current two stages shutdown procedure if we have to call to the same `Stop()` method twice. At that point it would be simpler to just wait for all tasks to finish on the first call and remove the second one. But that seems suboptimal as there is no rush to wait for them at that point of the shutdown sequence.\r\n\r\nAlso, a benefit of keeping `Interrupt()` is that we can build on top of it and have a faster and non-locking way of checking if the thread pool is enabled. \r\nSo callers would be able to call something like `pool.IsRunning()` to see if they can submit tasks without have to worry locking the main mutex and slowing down the workers processing. Something like:\r\n\r\n```diff\r\ndiff --git a/src/util/threadpool.h b/src/util/threadpool.h\r\n--- a/src/util/threadpool.h\t(revision e0ec3232daf2c311471a1da149821bed18853fcc)\r\n+++ b/src/util/threadpool.h\t(date 1761158485938)\r\n@@ -55,6 +55,9 @@\r\n     // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\r\n     bool m_interrupt GUARDED_BY(m_mutex){false};\r\n     std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\r\n+    // Enabled only after Start and disabled early on Stop/Interrupt.\r\n+    // This lets us do non-blocking 'IsRunning' checks.\r\n+    std::atomic<bool> m_running{false};\r\n \r\n     void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n@@ -109,9 +112,11 @@\r\n         m_interrupt = false; // Reset\r\n \r\n         // Create workers\r\n         m_workers.reserve(num_workers);\r\n         for (int i = 0; i < num_workers; i++) {\r\n             m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\r\n         }\r\n+        m_running.store(true, std::memory_order_release);\r\n     }\r\n \r\n     /**\r\n@@ -124,7 +129,9 @@\r\n      */\r\n     void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n-        // Notify workers and join them.\r\n+        // Mark as no longer accepting new tasks\r\n+        m_running.store(false, std::memory_order_release);\r\n+        // Notify workers and join them\r\n         std::vector<std::thread> threads_to_join;\r\n         {\r\n             LOCK(m_mutex);\r\n@@ -147,11 +154,16 @@\r\n     template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     auto Submit(F&& fn)\r\n     {\r\n+        // Quick rejection based on Start/Stop/Interrupt before locking\r\n+        if (!m_running.load(std::memory_order_acquire)) {\r\n+            throw std::runtime_error(\"ThreadPool not running\");\r\n+        }\r\n+\r\n         std::packaged_task task{std::forward<F>(fn)};\r\n         auto future{task.get_future()};\r\n         {\r\n             LOCK(m_mutex);\r\n             if (m_workers.empty() || m_interrupt) {\r\n                 throw std::runtime_error(\"No active workers; cannot accept new tasks\");\r\n             }\r\n             m_work_queue.emplace(std::move(task));\r\n@@ -180,7 +192,9 @@\r\n \r\n     void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n     {\r\n+        m_running.store(false, std::memory_order_release);\r\n         WITH_LOCK(m_mutex, m_interrupt = true);\r\n         m_cv.notify_all();\r\n     }\r\n \r\n     size_t WorkQueueSize() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\r\n@@ -192,6 +206,11 @@\r\n     {\r\n         return WITH_LOCK(m_mutex, return m_workers.size());\r\n     }\r\n+\r\n+    bool IsRunning() const noexcept\r\n+    {\r\n+        return m_running.load(std::memory_order_acquire);\r\n+    }\r\n };\r\n \r\n #endif // BITCOIN_UTIL_THREADPOOL_H\r\n```\r\n\r\n(this is not needed here because we are disconnecting the http callback prior to interrupting the pool but it seems useful in general).",
      "created_at": "2025-10-28T19:37:46Z",
      "updated_at": "2025-10-28T19:50:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470824383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470824383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470845344",
      "pull_request_review_id": 3390538651,
      "id": 2470845344,
      "node_id": "PRRC_kwDOABII586TRhug",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> I don't think we should have a method that would cause the node to crash if Start is called more than once. I disagree and think just calling Stop at the beginning of Start would be safer than the current implementation.\r\n\r\nWouldn't you agree that if your code calls `Start()` twice, you have a design issue? Thread pools are typically started once, maintained for the entire appâ€™s lifecycle, and reused across modules. Mainly because creating and destroying threads isnâ€™t cheap. I think itâ€™s fair to expect an exception in that case, as it would indicate poorly structured code.\r\n\r\nI also donâ€™t think anyone would expect `Start()` to wait for all existing threads to shut down and then spawn new ones. That would be a surprising behavior to me. Why would you spawn new ones if you already have threads available?",
      "created_at": "2025-10-28T19:46:09Z",
      "updated_at": "2025-10-28T19:47:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470845344",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470845344"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470851529",
      "pull_request_review_id": 3390546152,
      "id": 2470851529,
      "node_id": "PRRC_kwDOABII586TRjPJ",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "andrewtoth",
        "id": 237213,
        "node_id": "MDQ6VXNlcjIzNzIxMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/237213?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/andrewtoth",
        "html_url": "https://github.com/andrewtoth",
        "followers_url": "https://api.github.com/users/andrewtoth/followers",
        "following_url": "https://api.github.com/users/andrewtoth/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/andrewtoth/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/andrewtoth/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/andrewtoth/subscriptions",
        "organizations_url": "https://api.github.com/users/andrewtoth/orgs",
        "repos_url": "https://api.github.com/users/andrewtoth/repos",
        "events_url": "https://api.github.com/users/andrewtoth/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/andrewtoth/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "So why have `Start` and `Stop` then? Just start threads in constructor and join in destructor? Use `Interrupt` to stop new tasks from being added. This follows RAII principles.",
      "created_at": "2025-10-28T19:48:41Z",
      "updated_at": "2025-10-28T19:49:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470851529",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470851529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470902222",
      "pull_request_review_id": 3390612876,
      "id": 2470902222,
      "node_id": "PRRC_kwDOABII586TRvnO",
      "diff_hunk": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2024-present The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_THREADPOOL_H\n+#define BITCOIN_UTIL_THREADPOOL_H\n+\n+#include <sync.h>\n+#include <util/check.h>\n+#include <util/string.h>\n+#include <util/thread.h>\n+#include <util/threadinterrupt.h>\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <condition_variable>\n+#include <cstddef>\n+#include <functional>\n+#include <future>\n+#include <memory>\n+#include <stdexcept>\n+#include <utility>\n+#include <queue>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * @brief Fixed-size thread pool for running arbitrary tasks concurrently.\n+ *\n+ * The thread pool maintains a set of worker threads that consume and execute\n+ * tasks submitted through Submit(). Once started, tasks can be queued and\n+ * processed asynchronously until Stop() is called.\n+ *\n+ * ### Thread-safety and lifecycle\n+ * - `Start()` and `Stop()` must be called from a controller (non-worker) thread.\n+ *   Calling `Stop()` from a worker thread will deadlock, as it waits for all\n+ *   workers to join, including the current one.\n+ *\n+ * - `Submit()` can be called from any thread, including workers. It safely\n+ *   enqueues new work for execution as long as the pool has active workers.\n+ *\n+ * - `Stop()` prevents further task submission and wakes all worker threads.\n+ *   Workers finish processing all remaining queued tasks before exiting,\n+ *   guaranteeing that no caller waits forever on a pending future.\n+ */\n+class ThreadPool {\n+\n+private:\n+    std::string m_name;\n+    Mutex m_mutex;\n+    std::queue<std::packaged_task<void()>> m_work_queue GUARDED_BY(m_mutex);\n+    std::condition_variable m_cv;\n+    // Note: m_interrupt must be modified while holding the same mutex used by threads waiting on the condition variable.\n+    // This ensures threads blocked on m_cv reliably observe the change and proceed correctly without missing signals.\n+    // Ref: https://en.cppreference.com/w/cpp/thread/condition_variable\n+    bool m_interrupt GUARDED_BY(m_mutex){false};\n+    std::vector<std::thread> m_workers GUARDED_BY(m_mutex);\n+\n+    void WorkerThread() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        WAIT_LOCK(m_mutex, wait_lock);\n+        for (;;) {\n+            std::packaged_task<void()> task;\n+            {\n+                // Wait only if needed; avoid sleeping when a new task was submitted while we were processing another one.\n+                if (!m_interrupt && m_work_queue.empty()) {\n+                    // Block until the pool is interrupted or a task is available.\n+                    m_cv.wait(wait_lock,[&]() EXCLUSIVE_LOCKS_REQUIRED(m_mutex) { return m_interrupt || !m_work_queue.empty(); });\n+                }\n+\n+                // If stopped and no work left, exit worker\n+                if (m_interrupt && m_work_queue.empty()) {\n+                    return;\n+                }\n+\n+                task = std::move(m_work_queue.front());\n+                m_work_queue.pop();\n+            }\n+\n+            {\n+                // Execute the task without the lock\n+                REVERSE_LOCK(wait_lock, m_mutex);\n+                task();\n+            }\n+        }\n+    }\n+\n+public:\n+    explicit ThreadPool(const std::string& name) : m_name(name) {}\n+\n+    ~ThreadPool()\n+    {\n+        Stop(); // In case it hasn't been stopped.\n+    }\n+\n+    /**\n+     * @brief Start worker threads.\n+     *\n+     * Creates and launches `num_workers` threads that begin executing tasks\n+     * from the queue. If the pool is already started, throws.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Start(int num_workers) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        assert(num_workers > 0);\n+        LOCK(m_mutex);\n+        if (!m_workers.empty()) throw std::runtime_error(\"Thread pool already started\");\n+        m_interrupt = false; // Reset\n+\n+        // Create workers\n+        m_workers.reserve(num_workers);\n+        for (int i = 0; i < num_workers; i++) {\n+            m_workers.emplace_back(&util::TraceThread, m_name + \"_pool_\" + util::ToString(i), [this] { WorkerThread(); });\n+        }\n+    }\n+\n+    /**\n+     * @brief Stop all worker threads and wait for them to exit.\n+     *\n+     * Sets the interrupt flag, wakes all waiting workers, and joins them.\n+     * Any remaining tasks in the queue will be processed before returning.\n+     *\n+     * Must be called from a controller (non-worker) thread.\n+     */\n+    void Stop() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        // Notify workers and join them.\n+        std::vector<std::thread> threads_to_join;\n+        {\n+            LOCK(m_mutex);\n+            m_interrupt = true;\n+            threads_to_join.swap(m_workers);\n+        }\n+        m_cv.notify_all();\n+        for (auto& worker : threads_to_join) worker.join();\n+        // Since we currently wait for tasks completion, sanity-check empty queue\n+        WITH_LOCK(m_mutex, Assume(m_work_queue.empty()));\n+        // Note: m_interrupt is left true until next Start()\n+    }\n+\n+    /**\n+     * @brief Submit a new task for asynchronous execution.\n+     *\n+     * Enqueues a callable to be executed by one of the worker threads.\n+     * Returns a `std::future` that can be used to retrieve the taskâ€™s result.\n+     */\n+    template<class F> EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    auto Submit(F&& fn)\n+    {\n+        std::packaged_task task{std::forward<F>(fn)};\n+        auto future{task.get_future()};\n+        {\n+            LOCK(m_mutex);\n+            if (m_interrupt || m_workers.empty()) {\n+                throw std::runtime_error(\"No active workers; cannot accept new tasks\");\n+            }\n+            m_work_queue.emplace(std::move(task));\n+        }\n+        m_cv.notify_one();\n+        return future;\n+    }\n+\n+    /**\n+     * @brief Execute a single queued task synchronously.\n+     * Removes one task from the queue and executes it on the calling thread.\n+     */\n+    void ProcessTask() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    {\n+        std::packaged_task<void()> task;\n+        {\n+            LOCK(m_mutex);\n+            if (m_work_queue.empty()) return;\n+\n+            // Pop the task\n+            task = std::move(m_work_queue.front());\n+            m_work_queue.pop();\n+        }\n+        task();\n+    }\n+\n+    void Interrupt() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)",
      "path": "src/util/threadpool.h",
      "position": 182,
      "original_position": 182,
      "commit_id": "195a96258f970c384ce180d57e73616904ef5fa1",
      "original_commit_id": "c219b93c3b043de202bdf3c65b433fd17af2da89",
      "in_reply_to_id": 2469885604,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false,
        "patch_url": null
      },
      "body": "> So why have `Start` and `Stop` then? Just start threads in constructor and join in destructor? Use `Interrupt` to stop new tasks from being added. This follows RAII principles.\r\n\r\nGood question. We could easily build an RAII wrapper on top of this. The approaches arenâ€™t conflicting; it would just be an additional layer over the current code.\r\nYet, I think the current design smoothly integrates with our existing workflows. We already use the `start`, `interrupt`, and `stop` terms throughout the codebase (check `init.cpp` and all our components), so following that general convention makes it easier to reason about these components globally. Even without deep knowledge of the http server workflow, anyone familiar with this convention can quickly hook up new functionality.\r\n\r\nAlso, I suspect weâ€™ll find opportunities for improvements (or smarter shutdown behaviors) along the way that might require customizing `Stop()` with some inputs, so might be better not to enforce RAII too early.",
      "created_at": "2025-10-28T20:11:38Z",
      "updated_at": "2025-10-28T20:13:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/33689#discussion_r2470902222",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/2470902222"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/33689"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    }
  ]
}