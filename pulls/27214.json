{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214",
    "id": 1265080919,
    "node_id": "PR_kwDOABII585LZ5pX",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/27214",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/27214.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/27214.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/17e705428ddf80c7a7f31fe5430d966cf08a37d6",
    "number": 27214,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "addrman: Enable selecting addresses by network",
    "user": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "For the full context & motivation of this patch, see #27213\r\n\r\nThis is joint work with mzumsande.\r\n\r\nThis PR adds functionality to `AddrMan::Select` to enable callers to specify a network they are interested in.\r\n\r\nAlong the way, it refactors the function to deduplicate the logic, updates the local variables to match modern conventions, adds test coverage for both the new and existing `Select` logic, and adds bench tests for the worst case performance of both the new and existing `Select` logic. \r\n\r\nThis functionality is used in the parent PR. \r\n\r\n",
    "labels": [
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      }
    ],
    "milestone": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60",
      "html_url": "https://github.com/bitcoin/bitcoin/milestone/60",
      "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones/60/labels",
      "id": 9286970,
      "node_id": "MI_kwDOABII584AjbU6",
      "number": 60,
      "state": "closed",
      "title": "26.0",
      "description": "",
      "creator": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 0,
      "closed_issues": 116,
      "created_at": "2023-04-15T11:36:05Z",
      "updated_at": "2023-12-08T10:41:40Z",
      "closed_at": "2023-12-04T13:27:46Z"
    },
    "created_at": "2023-03-06T19:47:33Z",
    "updated_at": "2024-05-23T12:52:14Z",
    "closed_at": "2023-04-20T20:07:51Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merged_at": "2023-04-20T20:07:51Z",
    "merge_commit_sha": "3a93957a5dc97cb2fd0656d1e2451ebef57204df",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "amitiuttarwar:2023-03-select-by-network",
      "ref": "2023-03-select-by-network",
      "sha": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 164037357,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwMzczNTc=",
        "name": "bitcoin",
        "full_name": "amitiuttarwar/bitcoin",
        "owner": {
          "login": "amitiuttarwar",
          "id": 1500952,
          "node_id": "MDQ6VXNlcjE1MDA5NTI=",
          "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/amitiuttarwar",
          "html_url": "https://github.com/amitiuttarwar",
          "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
          "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
          "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
          "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
          "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/amitiuttarwar/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/amitiuttarwar/bitcoin",
        "archive_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/events",
        "forks_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/amitiuttarwar/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:amitiuttarwar/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/amitiuttarwar/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/amitiuttarwar/bitcoin/hooks",
        "svn_url": "https://github.com/amitiuttarwar/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 5,
        "stargazers_count": 8,
        "watchers_count": 8,
        "size": 226606,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-11-10T23:52:50Z",
        "created_at": "2019-01-04T00:31:16Z",
        "updated_at": "2024-05-19T18:56:14Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "d26a71a94ac4ae1b1a091f4412d390afba69b2f8",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 35431,
        "stargazers_count": 76503,
        "watchers_count": 76503,
        "size": 259053,
        "default_branch": "master",
        "open_issues_count": 686,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-05-23T12:50:33Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2024-05-23T12:25:24Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 259,
    "deletions": 91,
    "changed_files": 5,
    "commits": 12,
    "review_comments": 92,
    "comments": 8
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDliZjA3OGY2NmM4ZjI4NmUxYWI1ZTM0YjhlZWVkN2Q4MDI5MGE4OTc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "tree": {
        "sha": "a334c3d8260d2b6b3a00b34360cdc432d80e6fea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a334c3d8260d2b6b3a00b34360cdc432d80e6fea"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a245429d680eb95cf4c0c78e58e63e3f0f5d979a",
          "sha": "a245429d680eb95cf4c0c78e58e63e3f0f5d979a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a245429d680eb95cf4c0c78e58e63e3f0f5d979a"
        }
      ],
      "message": "refactor: update Select_ function\n\nExtract the logic that decides whether the new or the tried table is going to\nbe searched to the beginning of the function.\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-06T01:34:15Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T00:38:58Z"
      },
      "sha": "9bf078f66c8f286e1ab5e34b8eeed7d80290a897"
    },
    {
      "event": "commented",
      "id": 1456857488,
      "node_id": "IC_kwDOABII585W1eGQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456857488",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T19:47:36Z",
      "updated_at": "2023-04-19T17:35:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [vasild](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1357776792), [brunoerg](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1363419724), [ajtowns](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1382390744), [mzumsande](https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1388792230) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27213](https://github.com/bitcoin/bitcoin/pull/27213) (p2p: Diversify automatic outbound connections with respect to networks by amitiuttarwar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1456857488",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "renamed",
      "id": 8678182965,
      "node_id": "RTE_lADOABII585gFqw_zwAAAAIFQpA1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8678182965",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T19:47:38Z",
      "rename": {
        "from": "addrman: Enable selecting addresses by network ",
        "to": "addrman: Enable selecting addresses by network"
      }
    },
    {
      "event": "labeled",
      "id": 8678183129,
      "node_id": "LE_lADOABII585gFqw_zwAAAAIFQpDZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8678183129",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T19:47:39Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T19:48:35Z",
      "updated_at": "2023-03-06T19:48:35Z",
      "source": {
        "issue": {
          "id": 1612097868,
          "node_id": "PR_kwDOABII585LZ5fL",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27213",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27213/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27213/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27213/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27213",
          "number": 27213,
          "state": "closed",
          "state_reason": null,
          "title": "p2p: Diversify automatic outbound connections with respect to networks",
          "body": "This is joint work with mzumsande. \r\n\r\nThis is a proposal to diversify outbound connections with respect to reachable networks. The existing logic evaluates peers for connection based purely on the frequency of available addresses in `AddrMan`. This PR adds logic to automatically connect to alternate reachable networks and adds eviction logic that protects one existing connection to each network. \r\n\r\nFor instance, if `AddrMan` is populated primarily with IPv4 and IPv6 addresses and only a handful of onion addresses, it is likely that we won't establish any automatic outbound connections to Tor, even if we're capable of doing so. For smaller networks like CJDNS, this is even more of an issue and often requires adding manual peers to ensure regularly being connected to the network.\r\n\r\nConnecting to multiple networks improves resistance to eclipse attacks for individual nodes. It also benefits the entire p2p network by increasing partition resistance and privacy in general. \r\n\r\nThe automatic connections to alternate networks is done defensively, by first filling all outbound slots with random addresses (as in the status quo) and then adding additional peers from reachable networks the node is currently not connected to. This approach ensures that outbound slots are not left unfilled while attempting to connect to a network that may be unavailable due to a technical issue or misconfiguration that bitcoind cannot detect.\r\n\r\nOnce an additional peer is added and we have one more outbound connection than we want, outbound eviction ensures that peers are protected if they are the only ones for their network.\r\n\r\nManual connections are also taken into account: If a user already establishes manual connections to a trusted peer from a network, there is no longer a need to make extra efforts to ensure we also have an automatic connection to it (although this may of course happen by random selection). \r\n",
          "user": {
            "login": "amitiuttarwar",
            "id": 1500952,
            "node_id": "MDQ6VXNlcjE1MDA5NTI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/amitiuttarwar",
            "html_url": "https://github.com/amitiuttarwar",
            "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
            "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
            "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
            "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
            "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 49,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27213",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27213",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27213.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27213.patch"
          },
          "closed_at": "2023-08-06T16:45:11Z",
          "created_at": "2023-03-06T19:46:54Z",
          "updated_at": "2023-08-12T02:26:29Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1327229701,
      "node_id": "PRR_kwDOABII585PG-sF",
      "url": null,
      "actor": null,
      "commit_id": "fdfeac9031049e85e7d5b1393227510ce54e247d",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Concept ACK\r\n\r\ngoing to review soon",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1327229701",
      "submitted_at": "2023-03-06T21:36:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1327252882,
      "node_id": "PRR_kwDOABII585PHEWS",
      "url": null,
      "actor": null,
      "commit_id": "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1327252882",
      "submitted_at": "2023-03-06T21:53:24Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1327260528,
      "node_id": "PRR_kwDOABII585PHGNw",
      "url": null,
      "actor": null,
      "commit_id": "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1327260528",
      "submitted_at": "2023-03-06T21:59:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1327266458,
      "node_id": "PRR_kwDOABII585PHHqa",
      "url": null,
      "actor": null,
      "commit_id": "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1327266458",
      "submitted_at": "2023-03-06T22:03:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8681046935,
      "node_id": "HRFPE_lADOABII585gFqw_zwAAAAIFbkOX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8681046935",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T03:01:42Z"
    },
    {
      "event": "commented",
      "id": 1457435139,
      "node_id": "IC_kwDOABII585W3rID",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1457435139",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T03:02:51Z",
      "updated_at": "2023-03-07T03:02:51Z",
      "author_association": "CONTRIBUTOR",
      "body": "thanks for the review @brunoerg ! responded to all your feedback",
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1457435139",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "mentioned",
      "id": 8681053117,
      "node_id": "MEE_lADOABII585gFqw_zwAAAAIFblu9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8681053117",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T03:02:51Z"
    },
    {
      "event": "subscribed",
      "id": 8681053144,
      "node_id": "SE_lADOABII585gFqw_zwAAAAIFblvY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8681053144",
      "actor": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T03:02:52Z"
    },
    {
      "event": "reviewed",
      "id": 1328202519,
      "node_id": "PRR_kwDOABII585PKsMX",
      "url": null,
      "actor": null,
      "commit_id": "3a93327688aad526f9a81d214aed6e3f38415274",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1328202519",
      "submitted_at": "2023-03-07T11:39:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1329133202,
      "node_id": "PRR_kwDOABII585POPaS",
      "url": null,
      "actor": null,
      "commit_id": "3a93327688aad526f9a81d214aed6e3f38415274",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1329133202",
      "submitted_at": "2023-03-07T17:21:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8691221305,
      "node_id": "HRFPE_lADOABII585gFqw_zwAAAAIGCYM5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8691221305",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T22:52:50Z"
    },
    {
      "event": "reviewed",
      "id": 1330319151,
      "node_id": "PRR_kwDOABII585PSw8v",
      "url": null,
      "actor": null,
      "commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "crACK 25a64a20749f10ce84060f3570ad76d1a4776948",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1330319151",
      "submitted_at": "2023-03-08T10:16:34Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1330675864,
      "node_id": "PRR_kwDOABII585PUICY",
      "url": null,
      "actor": null,
      "commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Approach ACK 25a64a20749f10ce84060f3570ad76d1a4776948\r\n\r\nFeel free to ignore the nits below. I will try to assess the performance of the new `Select(network)`.\r\n\r\nThanks for working on this!",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1330675864",
      "submitted_at": "2023-03-09T11:22:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8724369835,
      "node_id": "HRFPE_lADOABII585gFqw_zwAAAAIIA1Gr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8724369835",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T17:05:55Z"
    },
    {
      "event": "commented",
      "id": 1464978015,
      "node_id": "IC_kwDOABII585XUcpf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1464978015",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T18:38:06Z",
      "updated_at": "2023-03-11T18:38:06Z",
      "author_association": "CONTRIBUTOR",
      "body": "thank you for the in-depth review @vasild ! I have addressed all your review comments (incorporated most, left questions on a couple)",
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1464978015",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "mentioned",
      "id": 8724489456,
      "node_id": "MEE_lADOABII585gFqw_zwAAAAIIBSTw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8724489456",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T18:38:07Z"
    },
    {
      "event": "subscribed",
      "id": 8724489459,
      "node_id": "SE_lADOABII585gFqw_zwAAAAIIBSTz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8724489459",
      "actor": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-11T18:38:07Z"
    },
    {
      "event": "reviewed",
      "id": 1341650337,
      "node_id": "PRR_kwDOABII585P9_Wh",
      "url": null,
      "actor": null,
      "commit_id": "09d514583f15860f3bc7ae0c89e640c94fae3c71",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 09d514583f15860f3bc7ae0c89e640c94fae3c71\r\n\r\nSuggestions remaining (non-blocker):\r\n\r\n* [Check out-of-bounds array access in AddrManImpl::GetEntry()](https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129439158).\r\n\r\n* I can't find where the [suggested test](https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130705627) was added.\r\n\r\n* Performance wise I think the change in https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130705627 would be very nice to have.\r\n\r\nThanks!\r\n",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1341650337",
      "submitted_at": "2023-03-15T14:36:05Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "review_requested",
      "id": 8756232832,
      "node_id": "RRE_lADOABII585gFqw_zwAAAAIJ6YKA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8756232832",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-15T14:36:11Z",
      "requested_reviewer": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA1MmZiY2Q1YTc5MTg1NTQwNjE0MWU4NWQzMmU0MmUyOTcyMjBmZTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/052fbcd5a791855406141e85d32e42e297220fe9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/052fbcd5a791855406141e85d32e42e297220fe9",
      "tree": {
        "sha": "9fc3e552fa0a6ca97f2ff4e0484e0ca69ebe4cc1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9fc3e552fa0a6ca97f2ff4e0484e0ca69ebe4cc1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
          "sha": "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9bf078f66c8f286e1ab5e34b8eeed7d80290a897"
        }
      ],
      "message": "addrman: Introduce helper to generalize looking up an addrman entry\n\nUnused until later commit.\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T00:59:02Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T00:46:13Z"
      },
      "sha": "052fbcd5a791855406141e85d32e42e297220fe9"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNhMmE5YzVmOGYxNGI3OTJhMTRlODFmNzNiMTkxMGE0Yzg3OTliOTM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca2a9c5f8f14b792a14e81f73b1910a4c8799b93",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ca2a9c5f8f14b792a14e81f73b1910a4c8799b93",
      "tree": {
        "sha": "c1d18609ea79b50b82aa7ecad08c185511be34d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c1d18609ea79b50b82aa7ecad08c185511be34d2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/052fbcd5a791855406141e85d32e42e297220fe9",
          "sha": "052fbcd5a791855406141e85d32e42e297220fe9",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/052fbcd5a791855406141e85d32e42e297220fe9"
        }
      ],
      "message": "refactor: generalize select logic\n\nin preparation for consolidating the logic for searching the new and tried\ntables, generalize the call paths for both\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T00:59:02Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T01:01:18Z"
      },
      "sha": "ca2a9c5f8f14b792a14e81f73b1910a4c8799b93"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDQ4ODA2NDEyZTJiY2QwMjNiNzhmYzA1ZjZjOWNlMDkyMzYwZDFkYjE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48806412e2bcd023b78fc05f6c9ce092360d1db1",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/48806412e2bcd023b78fc05f6c9ce092360d1db1",
      "tree": {
        "sha": "e77067a57e9e19bac1f11f00d6e5a457cffb38b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e77067a57e9e19bac1f11f00d6e5a457cffb38b4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca2a9c5f8f14b792a14e81f73b1910a4c8799b93",
          "sha": "ca2a9c5f8f14b792a14e81f73b1910a4c8799b93",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ca2a9c5f8f14b792a14e81f73b1910a4c8799b93"
        }
      ],
      "message": "refactor: consolidate select logic for new and tried tables\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T00:59:02Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T01:13:00Z"
      },
      "sha": "48806412e2bcd023b78fc05f6c9ce092360d1db1"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI2YzNiZjExZTI0ODdlZDBhYzU3OGZiOTI2MTljMTQ4MzM2MDAzY2I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26c3bf11e2487ed0ac578fb92619c148336003cb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/26c3bf11e2487ed0ac578fb92619c148336003cb",
      "tree": {
        "sha": "9e54581d78cc858038a43e9218e5dbf347fa7b4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9e54581d78cc858038a43e9218e5dbf347fa7b4e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48806412e2bcd023b78fc05f6c9ce092360d1db1",
          "sha": "48806412e2bcd023b78fc05f6c9ce092360d1db1",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/48806412e2bcd023b78fc05f6c9ce092360d1db1"
        }
      ],
      "message": "scripted-diff: rename local variables to match modern conventions\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/fChanceFactor/chance_factor/g' src/addrman.cpp\nsed -i 's/nBucketPos/initial_position/g' src/addrman.cpp\nsed -i 's/nBucket/bucket/g' src/addrman.cpp src/addrman_impl.h\nsed -i 's/newOnly/new_only/g' src/addrman.cpp src/addrman_impl.h src/addrman.h src/test/addrman_tests.cpp\n-END VERIFY SCRIPT-\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T00:59:02Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T17:09:28Z"
      },
      "sha": "26c3bf11e2487ed0ac578fb92619c148336003cb"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZiMjI5Mjg0ZmQyMjA5OTM4ZWU4ZmRmZmVkNGQwODAzOTViM2FhMDU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b229284fd2209938ee8fdffed4d080395b3aa05",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6b229284fd2209938ee8fdffed4d080395b3aa05",
      "tree": {
        "sha": "930526ea48150eeda675ace5e77bdecaa6c9ac46",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/930526ea48150eeda675ace5e77bdecaa6c9ac46"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26c3bf11e2487ed0ac578fb92619c148336003cb",
          "sha": "26c3bf11e2487ed0ac578fb92619c148336003cb",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/26c3bf11e2487ed0ac578fb92619c148336003cb"
        }
      ],
      "message": "addrman: add functionality to select by network\n\nAdd an optional parameter to the addrman Select function that allows callers to\nspecify which network the returned address should be on. Ensure that the proper\ntable is selected with different cases of whether the new or tried table has\nnetwork addresses that match.\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T00:59:02Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T01:29:45Z"
      },
      "sha": "6b229284fd2209938ee8fdffed4d080395b3aa05"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDVjOGI0YmFmZjI3ZTBjY2QyN2ZkYTZlOTE1Yjk1NmQxZThkZDdjZTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c8b4baff27e0ccd27fda6e915b956d1e8dd7ce2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/5c8b4baff27e0ccd27fda6e915b956d1e8dd7ce2",
      "tree": {
        "sha": "49a59c665570afe5df3d68b1254db47ff4acf1c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49a59c665570afe5df3d68b1254db47ff4acf1c2"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b229284fd2209938ee8fdffed4d080395b3aa05",
          "sha": "6b229284fd2209938ee8fdffed4d080395b3aa05",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/6b229284fd2209938ee8fdffed4d080395b3aa05"
        }
      ],
      "message": "tests: add addrman_select_by_network test\n\nthis adds coverage for the 7 different cases of which table should be selected\nwhen the network is specified. the different cases are the result of new_only\nbeing true or false and whether there are network addresses on both, neither,\nor one of new vs tried tables. the only case not covered is when new_only is\nfalse and the only network addresses are on the new table.\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>\nCo-authored-by: Vasil Dimov <vd@FreeBSD.org>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T01:02:40Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-07T03:15:50Z"
      },
      "sha": "5c8b4baff27e0ccd27fda6e915b956d1e8dd7ce2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGE5OGU1NDJlMGMxOGY3Y2IyMzQwMTc5NjMxODA2ZjE0YjA3NDMwYzM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a98e542e0c18f7cb2340179631806f14b07430c3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a98e542e0c18f7cb2340179631806f14b07430c3",
      "tree": {
        "sha": "c673581d01096307173461b348fa88f4fe22c24b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c673581d01096307173461b348fa88f4fe22c24b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5c8b4baff27e0ccd27fda6e915b956d1e8dd7ce2",
          "sha": "5c8b4baff27e0ccd27fda6e915b956d1e8dd7ce2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5c8b4baff27e0ccd27fda6e915b956d1e8dd7ce2"
        }
      ],
      "message": "test: add addrman test for special case\n\nif an addr matching the network requirements is only on the new table and\nselect is invoked with new_only = false, ensure that the code selects the new\ntable.\n\nin order to test this case, we use a non deterministic addrman. this means we\ncannot have more than one address in any addrman table, or risk sporadic\nfailures when the second address happens to conflict.\n\nif the code chose a table at random, the test would fail 50% of the time\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T01:02:40Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T01:34:06Z"
      },
      "sha": "a98e542e0c18f7cb2340179631806f14b07430c3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDIyYTRkMTQ4OWMwNjc4YTkwYzAwMzE4MjAzY2ZjZTYxNjcyZjIwYjc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/22a4d1489c0678a90c00318203cfce61672f20b7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/22a4d1489c0678a90c00318203cfce61672f20b7",
      "tree": {
        "sha": "5ee40f7eebcd47fe05483a878beef2d165c91531",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5ee40f7eebcd47fe05483a878beef2d165c91531"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a98e542e0c18f7cb2340179631806f14b07430c3",
          "sha": "a98e542e0c18f7cb2340179631806f14b07430c3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a98e542e0c18f7cb2340179631806f14b07430c3"
        }
      ],
      "message": "test: increase coverage of addrman select (without network)\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T01:02:40Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T01:41:25Z"
      },
      "sha": "22a4d1489c0678a90c00318203cfce61672f20b7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDliOTFhYWUwODU3OWM3N2QyZmQ1NTA2ODA0YzhlMmUwY2RhMGQyNzQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b91aae08579c77d2fd5506804c8e2e0cda0d274",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/9b91aae08579c77d2fd5506804c8e2e0cda0d274",
      "tree": {
        "sha": "d5a1aa47d56a125e4c55ef57adef81ddd9d56988",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d5a1aa47d56a125e4c55ef57adef81ddd9d56988"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/22a4d1489c0678a90c00318203cfce61672f20b7",
          "sha": "22a4d1489c0678a90c00318203cfce61672f20b7",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/22a4d1489c0678a90c00318203cfce61672f20b7"
        }
      ],
      "message": "bench: add coverage for addrman select with network parameter\n\nto evaluate the worst case performance with the network parameter passed\nthrough, fill the new table with addresses then add a singular I2P address to\nretrieve\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T01:02:40Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-19T00:03:56Z"
      },
      "sha": "9b91aae08579c77d2fd5506804c8e2e0cda0d274"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGIwMDEwYzgzYTFiNGEzZDIxNzE5Y2I2OGUzN2ZhZjliMTE3MjUyMmE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0010c83a1b4a3d21719cb68e37faf9b1172522a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/b0010c83a1b4a3d21719cb68e37faf9b1172522a",
      "tree": {
        "sha": "1bbff25c5d9969c6d2d202b6cf8b5462c58f184f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1bbff25c5d9969c6d2d202b6cf8b5462c58f184f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b91aae08579c77d2fd5506804c8e2e0cda0d274",
          "sha": "9b91aae08579c77d2fd5506804c8e2e0cda0d274",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/9b91aae08579c77d2fd5506804c8e2e0cda0d274"
        }
      ],
      "message": "bench: test select for a new table with only one address\n\nthe addrman select function will demonstrate it's worst case performance when\nit is almost empty, because it might have to linearly search several buckets.\nadd a bench test to cover this case\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T01:02:40Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-02-23T21:53:52Z"
      },
      "sha": "b0010c83a1b4a3d21719cb68e37faf9b1172522a"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDE3ZTcwNTQyOGRkZjgwYzdhN2YzMWZlNTQzMGQ5NjZjZjA4YTM3ZDY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "tree": {
        "sha": "3de128a1f9eb391288f5a61e93d7f94ec3379357",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3de128a1f9eb391288f5a61e93d7f94ec3379357"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b0010c83a1b4a3d21719cb68e37faf9b1172522a",
          "sha": "b0010c83a1b4a3d21719cb68e37faf9b1172522a",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/b0010c83a1b4a3d21719cb68e37faf9b1172522a"
        }
      ],
      "message": "doc: clarify new_only param for Select function\n\nCo-authored-by: Martin Zumsande <mzumsande@gmail.com>",
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-18T01:02:40Z"
      },
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2023-03-11T02:25:59Z"
      },
      "sha": "17e705428ddf80c7a7f31fe5430d966cf08a37d6"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8783212952,
      "node_id": "HRFPE_lADOABII585gFqw_zwAAAAILhTGY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8783212952",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-18T01:04:20Z"
    },
    {
      "event": "commented",
      "id": 1474557343,
      "node_id": "IC_kwDOABII585X4_Wf",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1474557343",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-18T01:10:45Z",
      "updated_at": "2023-03-18T01:10:45Z",
      "author_association": "CONTRIBUTOR",
      "body": "two small updates:\r\n- added assertions for bounds checking in `GetEntry`\r\n- added the suggested test",
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1474557343",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "reviewed",
      "id": 1356788467,
      "node_id": "PRR_kwDOABII585Q3vLz",
      "url": null,
      "actor": null,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1356788467",
      "submitted_at": "2023-03-24T14:11:44Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1357776792,
      "node_id": "PRR_kwDOABII585Q7geY",
      "url": null,
      "actor": null,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 17e705428ddf80c7a7f31fe5430d966cf08a37d6\r\n\r\nMaybe other reviewers would be interested in the performance discussion: \r\nhttps://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130844842",
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1357776792",
      "submitted_at": "2023-03-25T05:15:02Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "review_requested",
      "id": 8844697993,
      "node_id": "RRE_lADOABII585gFqw_zwAAAAIPL2GJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8844697993",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-25T05:15:07Z",
      "requested_reviewer": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1363419724,
      "node_id": "PRR_kwDOABII585RRCJM",
      "url": null,
      "actor": null,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "re-ACK 17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1363419724",
      "submitted_at": "2023-03-29T15:36:20Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1382390744,
      "node_id": "PRR_kwDOABII585SZZvY",
      "url": null,
      "actor": null,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK 17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1382390744",
      "submitted_at": "2023-04-13T01:52:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "reviewed",
      "id": 1388792230,
      "node_id": "PRR_kwDOABII585Sx0mm",
      "url": null,
      "actor": null,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Code Review ACK 17e705428ddf80c7a7f31fe5430d966cf08a37d6\r\n\r\nI reviewed the PR again -  although I'm a coauthor, so not sure about the etiquette of ack'ing.\r\n\r\nI think there is a small bug in the non-deterministic test that could make it fail on rare occasions  and should be fixed - here or in a follow-up.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#pullrequestreview-1388792230",
      "submitted_at": "2023-04-17T19:29:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
    },
    {
      "event": "commented",
      "id": 1512128741,
      "node_id": "IC_kwDOABII585aIUDl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1512128741",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-17T21:51:30Z",
      "updated_at": "2023-04-17T21:51:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "thanks for the reviews! I'll address the outstanding comments in a followup ",
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1512128741",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "milestoned",
      "id": 9032827089,
      "node_id": "MIE_lADOABII585gFqw_zwAAAAIaZgDR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9032827089",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-18T08:18:50Z",
      "milestone": {
        "title": "26.0"
      }
    },
    {
      "event": "commented",
      "id": 1512672126,
      "node_id": "IC_kwDOABII585aKYt-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1512672126",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-18T08:27:34Z",
      "updated_at": "2023-04-18T08:27:34Z",
      "author_association": "MEMBER",
      "body": "This will be merged after branch-off. It would be good to either get the follow up opened in advance, so we can avoid any time between merging, and the potential for intermittent CI failures, or, if that change is straight-forward enough, you could push an additional commit here, leaving the rest of the branch as-is.",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1512672126",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9041589174,
      "node_id": "HRFPE_lADOABII585gFqw_zwAAAAIa67O2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9041589174",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-19T02:07:55Z"
    },
    {
      "event": "commented",
      "id": 1514035359,
      "node_id": "IC_kwDOABII585aPlif",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1514035359",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-19T02:11:41Z",
      "updated_at": "2023-04-19T02:11:41Z",
      "author_association": "CONTRIBUTOR",
      "body": "added an extra commit to ensure the non-deterministic test will not fail intermittently. will incorporate the outstanding feedback separately ",
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1514035359",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9041628794,
      "node_id": "HRFPE_lADOABII585gFqw_zwAAAAIa7E56",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9041628794",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-19T02:18:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9049224247,
      "node_id": "HRFPE_lADOABII585gFqw_zwAAAAIbYDQ3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9049224247",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-19T17:35:06Z"
    },
    {
      "event": "labeled",
      "id": 9049866667,
      "node_id": "LE_lADOABII585gFqw_zwAAAAIbagGr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9049866667",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-19T18:50:41Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "merged",
      "id": 9061134978,
      "node_id": "ME_lADOABII585gFqw_zwAAAAIcFfKC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9061134978",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "3a93957a5dc97cb2fd0656d1e2451ebef57204df",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a93957a5dc97cb2fd0656d1e2451ebef57204df",
      "created_at": "2023-04-20T20:07:51Z"
    },
    {
      "event": "closed",
      "id": 9061135031,
      "node_id": "CE_lADOABII585gFqw_zwAAAAIcFfK3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9061135031",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-20T20:07:51Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-21T02:52:12Z",
      "updated_at": "2023-04-21T02:52:12Z",
      "source": {
        "issue": {
          "id": 1677690795,
          "node_id": "PR_kwDOABII585O0ZGa",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27506",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27506/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27506/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27506/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27506",
          "number": 27506,
          "state": "closed",
          "state_reason": null,
          "title": "test: prevent intermittent failures",
          "body": "Follow up to #27214 - add an address to the tried table before the new table to make sure a new table collision is not possible.",
          "user": {
            "login": "amitiuttarwar",
            "id": 1500952,
            "node_id": "MDQ6VXNlcjE1MDA5NTI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/amitiuttarwar",
            "html_url": "https://github.com/amitiuttarwar",
            "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
            "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
            "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
            "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
            "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 62963516,
              "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
              "name": "Tests",
              "color": "d4c5f9",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": true,
          "comments": 1,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27506",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27506",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27506.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27506.patch"
          },
          "closed_at": "2023-04-21T18:31:11Z",
          "created_at": "2023-04-21T02:52:12Z",
          "updated_at": "2024-04-20T12:43:39Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1517186540,
      "node_id": "IC_kwDOABII585abm3s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1517186540",
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-21T02:55:00Z",
      "updated_at": "2023-04-21T02:55:00Z",
      "author_association": "CONTRIBUTOR",
      "body": "opened #27506 for the test fix ",
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#issuecomment-1517186540",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27214"
    },
    {
      "event": "unlabeled",
      "id": 9064553743,
      "node_id": "UNLE_lADOABII585gFqw_zwAAAAIcSh0P",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9064553743",
      "actor": {
        "login": "maflcko",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/maflcko",
        "html_url": "https://github.com/maflcko",
        "followers_url": "https://api.github.com/users/maflcko/followers",
        "following_url": "https://api.github.com/users/maflcko/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/maflcko/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/maflcko/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/maflcko/subscriptions",
        "organizations_url": "https://api.github.com/users/maflcko/orgs",
        "repos_url": "https://api.github.com/users/maflcko/repos",
        "events_url": "https://api.github.com/users/maflcko/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/maflcko/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-21T07:26:19Z",
      "label": {
        "name": "CI failed",
        "color": "cccccc"
      }
    },
    {
      "event": "referenced",
      "id": 9070115852,
      "node_id": "REFE_lADOABII585gFqw_zwAAAAIcnvwM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9070115852",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "49d07ea9a1a251b44e849ebbaf91857cff0bd22a",
      "commit_url": "https://api.github.com/repos/bitcoin-core/gui/commits/49d07ea9a1a251b44e849ebbaf91857cff0bd22a",
      "created_at": "2023-04-21T18:31:08Z"
    },
    {
      "event": "referenced",
      "id": 9070256652,
      "node_id": "REFE_lADOABII585gFqw_zwAAAAIcoSIM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9070256652",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6004bb5ebe718acbd859a7a7c143078606d382d9",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/6004bb5ebe718acbd859a7a7c143078606d382d9",
      "created_at": "2023-04-21T18:56:19Z"
    },
    {
      "event": "referenced",
      "id": 9070256815,
      "node_id": "REFE_lADOABII585gFqw_zwAAAAIcoSKv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9070256815",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6b9063755954720526713302f42cff8c4267bec7",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/6b9063755954720526713302f42cff8c4267bec7",
      "created_at": "2023-04-21T18:56:21Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-24T19:22:58Z",
      "updated_at": "2023-05-24T19:22:58Z",
      "source": {
        "issue": {
          "id": 1724603816,
          "node_id": "PR_kwDOABII585RR97P",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27745",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27745/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27745/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27745/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27745",
          "number": 27745,
          "state": "closed",
          "state_reason": null,
          "title": "addrman: select addresses by network follow-up",
          "body": "this PR addresses outstanding review comments from #27214 ",
          "user": {
            "login": "amitiuttarwar",
            "id": 1500952,
            "node_id": "MDQ6VXNlcjE1MDA5NTI=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/amitiuttarwar",
            "html_url": "https://github.com/amitiuttarwar",
            "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
            "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
            "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
            "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
            "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 98298007,
              "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
              "name": "P2P",
              "color": "006b75",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 2,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27745",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27745",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27745.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27745.patch"
          },
          "closed_at": "2023-06-30T17:29:19Z",
          "created_at": "2023-05-24T19:22:58Z",
          "updated_at": "2023-06-30T17:29:19Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "unsubscribed",
      "id": 9332713969,
      "node_id": "UE_lADOABII585gFqw_zwAAAAIsRenx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9332713969",
      "actor": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-24T21:07:58Z"
    },
    {
      "event": "referenced",
      "id": 9690160151,
      "node_id": "REFE_lADOABII585gFqw_zwAAAAJBlBwX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9690160151",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "6744d840dfa30a45e0a0786932b206cf133556d4",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6744d840dfa30a45e0a0786932b206cf133556d4",
      "created_at": "2023-06-30T17:29:17Z"
    },
    {
      "event": "referenced",
      "id": 9692896412,
      "node_id": "REFE_lADOABII585gFqw_zwAAAAJBvdyc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9692896412",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "f70e00d1322f31915243c6963c263c12ca121a87",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/f70e00d1322f31915243c6963c263c12ca121a87",
      "created_at": "2023-07-01T02:08:29Z"
    },
    {
      "event": "locked",
      "id": 12909026668,
      "node_id": "LOE_lADOABII585gFqw_zwAAAAMBcB1s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/12909026668",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-05-23T12:52:14Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061",
      "pull_request_review_id": 1327252882,
      "id": 1127073061,
      "node_id": "PRRC_kwDOABII585DLcUl",
      "diff_hunk": "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "path": "src/addrman.cpp",
      "position": 72,
      "original_position": 8,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit (for 9bf078f66c8f286e1ab5e34b8eeed7d80290a897):\r\n```cpp\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex ec5b0213b..f608d60f0 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -722,15 +722,13 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\r\n     if (newOnly && nNew == 0) return {};\r\n \r\n     // Decide if we are going to search the new or tried table\r\n-    bool search_tried;\r\n+    bool search_tried{false};\r\n \r\n     // Use a 50% chance for choosing between tried and new table entries.\r\n     if (!newOnly &&\r\n        (nTried > 0 &&\r\n         (nNew == 0 || insecure_rand.randbool() == 0))) {\r\n         search_tried = true;\r\n-    } else {\r\n-        search_tried = false;\r\n     }\r\n \r\n     if (search_tried) {\r\n```",
      "created_at": "2023-03-06T21:53:24Z",
      "updated_at": "2023-03-06T21:53:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127073061",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127073061"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 740,
      "original_line": 725,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909",
      "pull_request_review_id": 1327260528,
      "id": 1127079909,
      "node_id": "PRRC_kwDOABII585DLd_l",
      "diff_hunk": "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 24,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "perhaps rename `newOnly` to `new_only`?",
      "created_at": "2023-03-06T21:59:21Z",
      "updated_at": "2023-03-06T21:59:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127079909",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079909"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746",
      "pull_request_review_id": 1327266458,
      "id": 1127083746,
      "node_id": "PRRC_kwDOABII585DLe7i",
      "diff_hunk": "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n \n     // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n     bool search_tried;\n-    int bucket_count;\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 &&\n-        (nNew == 0 || insecure_rand.randbool() == 0))) {\n+    if (newOnly || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n         search_tried = true;\n-        bucket_count = ADDRMAN_TRIED_BUCKET_COUNT;\n     } else {\n-        search_tried = false;\n-        bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\n+        search_tried = insecure_rand.randbool();\n     }\n \n+    int bucket_count;\n+    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Suggestion:\r\n```diff\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex 8c36af13f..66d54d2b4 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -746,8 +746,7 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optiona\r\n         search_tried = insecure_rand.randbool();\r\n     }\r\n \r\n-    int bucket_count;\r\n-    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\r\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n     //  Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n```",
      "created_at": "2023-03-06T22:03:42Z",
      "updated_at": "2023-03-06T22:03:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127083746",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127083746"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542",
      "pull_request_review_id": 1327548731,
      "id": 1127282542,
      "node_id": "PRRC_kwDOABII585DMPdu",
      "diff_hunk": "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "path": "src/addrman.cpp",
      "position": 72,
      "original_position": 8,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "in_reply_to_id": 1127073061,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "hm, this suggestion makes sense within the context of the first commit. however, the `search_tried` logic gets updated over the commits so it would be expanded anyways. \r\n\r\nit would be possible to rework the end state to be a bit more nifty like this, but since this logic is pretty crucial to the function working as intended, I'm more inclined to leave the explicit assignment of new vs tried. ",
      "created_at": "2023-03-07T02:42:20Z",
      "updated_at": "2023-03-07T02:43:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127282542",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127282542"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 740,
      "original_line": 725,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828",
      "pull_request_review_id": 1327561910,
      "id": 1127291828,
      "node_id": "PRRC_kwDOABII585DMRu0",
      "diff_hunk": "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n \n     // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n     bool search_tried;\n-    int bucket_count;\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 &&\n-        (nNew == 0 || insecure_rand.randbool() == 0))) {\n+    if (newOnly || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n         search_tried = true;\n-        bucket_count = ADDRMAN_TRIED_BUCKET_COUNT;\n     } else {\n-        search_tried = false;\n-        bucket_count = ADDRMAN_NEW_BUCKET_COUNT;\n+        search_tried = insecure_rand.randbool();\n     }\n \n+    int bucket_count;\n+    search_tried ? bucket_count = ADDRMAN_TRIED_BUCKET_COUNT : bucket_count = ADDRMAN_NEW_BUCKET_COUNT;",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "in_reply_to_id": 1127083746,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nice, done",
      "created_at": "2023-03-07T03:02:01Z",
      "updated_at": "2023-03-07T03:02:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291828",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 750,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922",
      "pull_request_review_id": 1327562027,
      "id": 1127291922,
      "node_id": "PRRC_kwDOABII585DMRwS",
      "diff_hunk": "@@ -714,28 +714,42 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-    if (newOnly && nNew == 0) return {};\n+\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (newOnly && new_count == 0) return {};",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 24,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "d2f12a0687472b13dfb4ddd1772b4f9cf6ffb3fd",
      "in_reply_to_id": 1127079909,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-07T03:02:11Z",
      "updated_at": "2023-03-07T03:02:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127291922",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127291922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689",
      "pull_request_review_id": 1328202519,
      "id": 1127730689,
      "node_id": "PRRC_kwDOABII585DN84B",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*newOnly*/false, NET_I2P);",
      "path": "src/bench/addrman.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "3a93327688aad526f9a81d214aed6e3f38415274",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```suggestion\r\n        const auto& address = addrman.Select(/*new_only=*/false, NET_I2P);\r\n```",
      "created_at": "2023-03-07T11:39:44Z",
      "updated_at": "2023-03-07T11:41:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127730689",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127730689"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998",
      "pull_request_review_id": 1328205378,
      "id": 1127731998,
      "node_id": "PRRC_kwDOABII585DN9Me",
      "diff_hunk": "@@ -719,12 +719,21 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n-\n     if (newOnly && nNew == 0) return {};\n \n+    // Decide if we are going to search the new or tried table\n+    bool search_tried;",
      "path": "src/addrman.cpp",
      "position": 72,
      "original_position": 8,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "9bf078f66c8f286e1ab5e34b8eeed7d80290a897",
      "in_reply_to_id": 1127073061,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, can leave this way. This suggestion I made while reviewing the first commit but considering the whole context, you can leave it.",
      "created_at": "2023-03-07T11:41:00Z",
      "updated_at": "2023-03-07T11:41:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1127731998",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127731998"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 740,
      "original_line": 725,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413",
      "pull_request_review_id": 1329133202,
      "id": 1128258413,
      "node_id": "PRRC_kwDOABII585DP9tt",
      "diff_hunk": "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "path": "src/bench/addrman.cpp",
      "position": 19,
      "original_position": 19,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "3a93327688aad526f9a81d214aed6e3f38415274",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting, perhaps #26261 would be a good fit :)",
      "created_at": "2023-03-07T17:21:30Z",
      "updated_at": "2023-03-07T17:21:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128258413",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128258413"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 82,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427",
      "pull_request_review_id": 1329678832,
      "id": 1128704427,
      "node_id": "PRRC_kwDOABII585DRqmr",
      "diff_hunk": "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "path": "src/bench/addrman.cpp",
      "position": 19,
      "original_position": 19,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "3a93327688aad526f9a81d214aed6e3f38415274",
      "in_reply_to_id": 1128258413,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ah, it looks like those changes would remove the need for this helper? ",
      "created_at": "2023-03-07T22:52:34Z",
      "updated_at": "2023-03-07T22:52:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128704427",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128704427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 82,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089",
      "pull_request_review_id": 1329679553,
      "id": 1128705089,
      "node_id": "PRRC_kwDOABII585DRqxB",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*newOnly*/false, NET_I2P);",
      "path": "src/bench/addrman.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "3a93327688aad526f9a81d214aed6e3f38415274",
      "in_reply_to_id": 1127730689,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "good catch, updated. also realized there were stale comments in the addrman unit test, so updated those too.",
      "created_at": "2023-03-07T22:53:17Z",
      "updated_at": "2023-03-07T22:53:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1128705089",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128705089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513",
      "pull_request_review_id": 1330318402,
      "id": 1129220513,
      "node_id": "PRRC_kwDOABII585DTomh",
      "diff_hunk": "@@ -71,6 +72,20 @@ static void FillAddrMan(AddrMan& addrman)\n     AddAddressesToAddrMan(addrman);\n }\n \n+static CNetAddr ResolveIP(const std::string& ip)\n+{\n+    CNetAddr addr;\n+    LookupHost(ip, addr, false);\n+    return addr;\n+}\n+\n+static CService ResolveService(const std::string& ip, uint16_t port = 0)",
      "path": "src/bench/addrman.cpp",
      "position": 19,
      "original_position": 19,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "3a93327688aad526f9a81d214aed6e3f38415274",
      "in_reply_to_id": 1128258413,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, if it makes sense for you I'd appreciate your review there btw.",
      "created_at": "2023-03-08T10:16:15Z",
      "updated_at": "2023-03-08T10:16:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129220513",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129220513"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 82,
      "original_line": 82,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505",
      "pull_request_review_id": 1330675864,
      "id": 1129434505,
      "node_id": "PRRC_kwDOABII585DUc2J",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `Addrman` in the method name is redundant. Maybe `AddrManImpl::LookupEntry()` or even `AddrManImpl::Lookup()` or `AddrManImpl::Get()`.",
      "created_at": "2023-03-08T13:32:30Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129434505",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129434505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158",
      "pull_request_review_id": 1330675864,
      "id": 1129439158,
      "node_id": "PRRC_kwDOABII585DUd-2",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would be good to have an assert that checks there is no out-of-bounds access. This method itself does not know what the callers will use for arguments or how they will be derived so better check.\r\n\r\nMaybe change the arrays to `std::array` and use `.at()` here.",
      "created_at": "2023-03-08T13:36:01Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129439158",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129439158"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 802,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 809,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167",
      "pull_request_review_id": 1330675864,
      "id": 1129442167,
      "node_id": "PRRC_kwDOABII585DUet3",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I know it was using `int` to index the array, but those should be `size_t`. Now looks like a good time to fix that:\r\n```suggestion\r\nint AddrManImpl::LookupAddrmanEntry(bool use_tried, size_t bucket, size_t position) const\r\n```",
      "created_at": "2023-03-08T13:38:17Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129442167",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129442167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848",
      "pull_request_review_id": 1330675864,
      "id": 1129522848,
      "node_id": "PRRC_kwDOABII585DUyag",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`std::string` will do heap allocation. It is an overkill in this case.\r\n\r\n```suggestion\r\n            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), search_tried ? \"tried\" : \"new\");\r\n```",
      "created_at": "2023-03-08T14:26:56Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129522848",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129522848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 787,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 789,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099",
      "pull_request_review_id": 1330675864,
      "id": 1129539099,
      "node_id": "PRRC_kwDOABII585DU2Yb",
      "diff_hunk": "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] network  Select only addresses of this network (nullopt = all)\n      * @return    CAddress The record for the selected peer.\n      *            seconds  The last time we attempted to connect to that peer.\n      */\n-    std::pair<CAddress, NodeSeconds> Select(bool newOnly = false) const;\n+    std::pair<CAddress, NodeSeconds> Select(bool new_only = false, std::optional<Network> network = {}) const;",
      "path": "src/addrman.h",
      "position": null,
      "original_position": 11,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: use `std::nullopt` instead of `{}` which I believe is more readable and consistent with the comment that says \"nullopt = all\". Like here:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/8d12127a9c19cb218d661a88ab9b6871c9d853b9/src/addrman.h#L109",
      "created_at": "2023-03-08T14:37:16Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129539099",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129539099"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 150,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711",
      "pull_request_review_id": 1330675864,
      "id": 1129547711,
      "node_id": "PRRC_kwDOABII585DU4e_",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: I think it is good to be explicit and use `network.has_value()` here. Otherwise it can get confusing, especially with booleans (`network` is not boolean, but anyway). For example:\r\n\r\n```cpp\r\nstd::optional<bool> is_odd\r\n...\r\nif (is_odd) { // did the author mean is_odd.has_value() or *is_odd?\r\n```",
      "created_at": "2023-03-08T14:42:40Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129547711",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129547711"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 726,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332",
      "pull_request_review_id": 1330675864,
      "id": 1129552332,
      "node_id": "PRRC_kwDOABII585DU5nM",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 68,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n\r\n```suggestion\r\n    if (new_count + tried_count == 0) return {};\r\n```",
      "created_at": "2023-03-08T14:45:28Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129552332",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129552332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 736,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625",
      "pull_request_review_id": 1330675864,
      "id": 1129566625,
      "node_id": "PRRC_kwDOABII585DU9Gh",
      "diff_hunk": "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.",
      "path": "src/addrman.h",
      "position": null,
      "original_position": 5,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This maybe warrants a better description:\r\n\r\n```suggestion\r\n     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` guarantees either an address from the new table or an invalid return value. Passing `false` requests 50% chance of new or tried, it does not guarantee an entry from the tried table.\r\n```",
      "created_at": "2023-03-08T14:53:56Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129566625",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129566625"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636",
      "pull_request_review_id": 1330675864,
      "id": 1129568636,
      "node_id": "PRRC_kwDOABII585DU9l8",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 106,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```suggestion\r\n    // Loop through the addrman table until we find an appropriate entry\r\n```",
      "created_at": "2023-03-08T14:55:10Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129568636",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129568636"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 751,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710",
      "pull_request_review_id": 1330675864,
      "id": 1129569710,
      "node_id": "PRRC_kwDOABII585DU92u",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: same as elsewhere: consider `network.has_value()`.",
      "created_at": "2023-03-08T14:55:51Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129569710",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129569710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 765,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204",
      "pull_request_review_id": 1330675864,
      "id": 1129577204,
      "node_id": "PRRC_kwDOABII585DU_r0",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 122,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: the code below has an assert after `find()`, good to have it here too:\r\n\r\n```suggestion\r\n                    const auto it{mapInfo.find(node_id)};\r\n                    assert(it != mapInfo.end());\r\n                    const auto info{it->second};\r\n```",
      "created_at": "2023-03-08T15:00:36Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1129577204",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129577204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 766,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 768,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248",
      "pull_request_review_id": 1330675864,
      "id": 1130661248,
      "node_id": "PRRC_kwDOABII585DZIWA",
      "diff_hunk": "@@ -127,45 +127,47 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));",
      "path": "src/test/addrman_tests.cpp",
      "position": 2,
      "original_position": 2,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: in the commit message of `tests: add addrman_select_by_network test`: `s/newOnly/new_only` since it was already renamed before that commit",
      "created_at": "2023-03-09T08:46:27Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130661248",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130661248"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 128,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213",
      "pull_request_review_id": 1330675864,
      "id": 1130664213,
      "node_id": "PRRC_kwDOABII585DZJEV",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: that should be `/*new_only=*/` for clang-tidy to check it and for consistency with the rest of the code base (here and elsewhere).",
      "created_at": "2023-03-09T08:49:03Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130664213",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130664213"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333",
      "pull_request_review_id": 1330675864,
      "id": 1130668333,
      "node_id": "PRRC_kwDOABII585DZKEt",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be better to check that the returned result is `!IsValid()` and not rely on how an invalid address would be represented by `ToStringAddrPort()` (maybe even that method should assert that the object is valid).\r\n\r\n```suggestion\r\n    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV4).first.IsValid());\r\n```",
      "created_at": "2023-03-09T08:52:40Z",
      "updated_at": "2023-03-09T11:25:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130668333",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130668333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029",
      "pull_request_review_id": 1330675864,
      "id": 1130699029,
      "node_id": "PRRC_kwDOABII585DZRkV",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `250.1.1.1` is duplicated here and above. Maybe put it in a variable or avoid comparing through strings altogether (here and elsewhere):\r\n\r\n```suggestion\r\n    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_IPV4).first == addr1);\r\n```",
      "created_at": "2023-03-09T09:18:09Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130699029",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130699029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627",
      "pull_request_review_id": 1330675864,
      "id": 1130705627,
      "node_id": "PRRC_kwDOABII585DZTLb",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 106,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"new_only=true, some_nonexistent_network\" seems untested:\r\n\r\n```cpp\r\nBOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_CJDNS).first.IsValid());\r\n```",
      "created_at": "2023-03-09T09:23:41Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130705627",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130705627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887",
      "pull_request_review_id": 1330675864,
      "id": 1130712887,
      "node_id": "PRRC_kwDOABII585DZU83",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 97,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If this is changed to:\r\n```cpp\r\nCAddress i2p_addr;\r\n```\r\nand the rest of the code left as it is, then it will still work, but then `CAddress(i2p_addr, NODE_NONE)` which is duplicated below can be replaced with `i2p_addr`.",
      "created_at": "2023-03-09T09:29:46Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130712887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130712887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456",
      "pull_request_review_id": 1330675864,
      "id": 1130731456,
      "node_id": "PRRC_kwDOABII585DZZfA",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 126,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This test will fail sporadically.\r\n\r\nAlso, if you are only going to check the size, then a counter suffices. If you are going to collect the strings, then you may as well check that they are as expected (`i2p_addr` and `i2p_addr2`).\r\n\r\nConsider this:\r\n\r\n```cpp\r\n    CAddress i2p_addr2;\r\n...\r\n    // ensure that both new and tried table are selected from\r\n    bool new_selected{false};\r\n    bool tried_selected{false};\r\n    while (!new_selected || !tried_selected) { \r\n        const CAddress selected{addrman->Select(/*new_only=*/false, NET_I2P).first};\r\n        BOOST_REQUIRE(selected == i2p_addr || selected == i2p_addr2);\r\n        if (selected == i2p_addr) {\r\n            tried_selected = true;\r\n        } else {\r\n            new_selected = true;\r\n        }\r\n    }  \r\n```",
      "created_at": "2023-03-09T09:45:08Z",
      "updated_at": "2023-03-09T11:22:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130731456",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130731456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 241,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068",
      "pull_request_review_id": 1330675864,
      "id": 1130754068,
      "node_id": "PRRC_kwDOABII585DZfAU",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 142,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For this test to be meaningful there must be some address also in the tried table. Otherwise:\r\n\r\n```\r\n740     bool search_tried;\r\n741     if (new_only || tried_count == 0) {\r\n742         search_tried = false;\r\n743     } else if (new_count == 0) {\r\n744         search_tried = true;\r\n745     } else {\r\n746         search_tried = insecure_rand.randbool();\r\n747     }\r\n```\r\n\r\nit will always go to the new table via line 742 because `tried_count == 0` and it will never execute line 746 which I guess is the purpose of this test.",
      "created_at": "2023-03-09T10:03:39Z",
      "updated_at": "2023-03-09T11:22:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130754068",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130754068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999",
      "pull_request_review_id": 1330675864,
      "id": 1130835999,
      "node_id": "PRRC_kwDOABII585DZzAf",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\n+        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");",
      "path": "src/bench/addrman.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "String comparison is very non-effective and surely has an impact of performance in such a tight-loop cases. This may better be:\r\n\r\n```suggestion\r\n        const auto address = addrman.Select(/*new_only*/false, NET_I2P).first;\r\n        assert(address == i2p_address);\r\n```\r\n\r\nI think that this also does not need to check the result - now it is mixing bench + correctness test in such a way that the correctness check may skew the benchmark. We have the unit tests to ensure correctness. Thus, this may as well be:\r\n\r\n```suggestion\r\n        (void)addrman.Select(/*new_only*/false, NET_I2P);\r\n```\r\n\r\nto reduce the amount of noise.",
      "created_at": "2023-03-09T11:05:42Z",
      "updated_at": "2023-03-09T11:22:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130835999",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130835999"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 145,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488",
      "pull_request_review_id": 1330675864,
      "id": 1130840488,
      "node_id": "PRRC_kwDOABII585DZ0Go",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);",
      "path": "src/bench/addrman.cpp",
      "position": null,
      "original_position": 46,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is checking the port an indirect way to check that `Select()` returned a valid result? You can check that the returned value `IsValid()` for that. But same as for the other bench, this may as well be just `(void)addrman.Select();` to reduce the noise (and leave correctness checks to the unit tests).",
      "created_at": "2023-03-09T11:10:13Z",
      "updated_at": "2023-03-09T11:22:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130840488",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130840488"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 125,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842",
      "pull_request_review_id": 1330675864,
      "id": 1130844842,
      "node_id": "PRRC_kwDOABII585DZ1Kq",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": null,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It is excellent to see benchmark tests added! My only concern with this PR is that it will iterate through a lot of entries in addrman before finding one from the requested network. This in theory is `O(addrman size)`. And the benchmarks will help us assess that. So, it would be nice to compare, on the same, full addrman (e.g. 70k addresses):\r\n\r\n1. the speed of a regular `Select()`\r\n2. the speed of a `Select(network)` where the searched for address is ~near the end~ rare. In other words, worst case scenario, when ~70k addresses are iterated before finding the result.\r\n\r\nSomehow I don't see that from the added benchmarks. I will play with them to see if that's possible (~how to put an address \"at the end\"?~, that is nonsense, [there is no end](https://bitcoin-irc.chaincode.com/bitcoin-core-dev/2023-03-09#903165;)).\r\n\r\nBtw the results are unstable:\r\n```\r\n:wavy_dash: `AddrManSelectByNetwork` (Unstable with ~1.2 iters. Increase `minEpochIterations` to e.g. 12)\r\n```",
      "created_at": "2023-03-09T11:14:39Z",
      "updated_at": "2023-03-10T12:20:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1130844842",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1130844842"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513",
      "pull_request_review_id": 1335246024,
      "id": 1132629513,
      "node_id": "PRRC_kwDOABII585Dgo4J",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Let me elaborate why I think comparing 1. and 2. above is important (the benchmarks in this PR don't do that):\r\n\r\n* Right now, on `master`, when we pick a peer to connect to 1. happens.\r\n* With #27213 when we pick a peer to connect to 2. happens.\r\n* I assume most of the addrmans out there are full (tens of thousands of addresses, max 80k), thus testing on an empty addrman is not representative.\r\n\r\nSo, we will add security at the cost of making it a bit slower. To assess how much slower I tweaked the benchmark as this:\r\n\r\n<details>\r\n<summary>benchmark tweaks</summary>\r\n\r\n```diff\r\ndiff --git i/src/bench/addrman.cpp w/src/bench/addrman.cpp\r\nindex 9fe50f4ec2..d1def9e520 100644\r\n--- i/src/bench/addrman.cpp\r\n+++ w/src/bench/addrman.cpp\r\n@@ -12,13 +12,13 @@\r\n \r\n #include <optional>\r\n #include <vector>\r\n \r\n /* A \"source\" is a source address from which we have received a bunch of other addresses. */\r\n \r\n-static constexpr size_t NUM_SOURCES = 64;\r\n+static constexpr size_t NUM_SOURCES = 512; // fills addrman with ~55k addresses, instead of ~15k\r\n static constexpr size_t NUM_ADDRESSES_PER_SOURCE = 256;\r\n \r\n static NetGroupManager EMPTY_NETGROUPMAN{std::vector<bool>()};\r\n static constexpr uint32_t ADDRMAN_CONSISTENCY_CHECK_RATIO{0};\r\n \r\n static std::vector<CAddress> g_sources;\r\n@@ -137,16 +137,20 @@ static void AddrManSelectByNetwork(benchmark::Bench& bench)\r\n     CAddress i2p_address(i2p_service, NODE_NONE);\r\n     i2p_address.nTime = Now<NodeSeconds>();\r\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\r\n     addrman.Add({i2p_address}, source);\r\n \r\n     FillAddrMan(addrman);\r\n-\r\n-    bench.run([&] {\r\n-        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\r\n-        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\r\n+    fprintf(stderr, \"addrman size: %zu\\n\", addrman.Size());\r\n+\r\n+    bench.minEpochIterations(300).run([&] {\r\n+#if 0\r\n+        addrman.Select(/*new_only=*/false);\r\n+#else\r\n+        addrman.Select(/*new_only=*/false, NET_I2P);\r\n+#endif\r\n     });\r\n }\r\n \r\n static void AddrManGetAddr(benchmark::Bench& bench)\r\n {\r\n     AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\r\n```\r\n</details>\r\n\r\nThe results are:\r\n\r\n1. `Select()` takes 0.18 microseconds\r\n2. `Select(network)` takes 6000 microseconds\r\n\r\nNow, this is a big difference, but maybe that is ok. We don't `Select()` in a tight loop. However, it can be improved relatively easy. I observed that in 2. we visit between ~100 and ~600k bucket positions before finding a match. Given that there are 80k in addrman it means that we visit some multiple times, which is a waste of resources. This is avoided if we don't visit already visited buckets (but still visit buckets in random order). The patch below does that (on top of this PR):\r\n\r\n<details>\r\n<summary>don't visit already visited buckets</summary>\r\n\r\n```diff\r\ndiff --git i/src/addrman.cpp w/src/addrman.cpp\r\nindex 1023c3cbdb..0e196050b9 100644\r\n--- i/src/addrman.cpp\r\n+++ w/src/addrman.cpp\r\n@@ -16,12 +16,13 @@\r\n #include <streams.h>\r\n #include <tinyformat.h>\r\n #include <uint256.h>\r\n #include <util/check.h>\r\n #include <util/time.h>\r\n \r\n+#include <array>\r\n #include <cmath>\r\n #include <optional>\r\n \r\n /** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\r\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\r\n /** Over how many buckets entries with new addresses originating from a single group are spread */\r\n@@ -745,17 +746,39 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n     } else {\r\n         search_tried = insecure_rand.randbool();\r\n     }\r\n \r\n     const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n+    // We want to search buckets in random order and also prefer visiting a\r\n+    // bucket that we have not visited before instead of visiting an already\r\n+    // visited bucket. Thus shuffle the buckets and visit that shuffled list\r\n+    // in order.\r\n+\r\n+    std::array<uint16_t, std::max(ADDRMAN_TRIED_BUCKET_COUNT, ADDRMAN_NEW_BUCKET_COUNT)>\r\n+        shuffled_bucket_indexes;\r\n+    for (uint16_t i = 0; i < bucket_count; ++i) {\r\n+        shuffled_bucket_indexes[i] = i;\r\n+    }\r\n+    Shuffle(shuffled_bucket_indexes.begin(),\r\n+            shuffled_bucket_indexes.begin() + bucket_count,\r\n+            insecure_rand);\r\n+    // If we visit a bucket and find 0 matching addresses in it, mark it with\r\n+    // this and never visit it again.\r\n+    static constexpr uint16_t ALREADY_VISITED_AND_BORING{std::numeric_limits<uint16_t>::max()};\r\n+\r\n+    static_assert(ADDRMAN_TRIED_BUCKET_COUNT < ALREADY_VISITED_AND_BORING);\r\n+    static_assert(ADDRMAN_NEW_BUCKET_COUNT < ALREADY_VISITED_AND_BORING);\r\n+\r\n     //  Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n-    while (1) {\r\n-        // Pick a bucket, and an initial position in that bucket.\r\n-        int bucket = insecure_rand.randrange(bucket_count);\r\n+    for (uint16_t b = 0;; b = (b + 1) % bucket_count) {\r\n+        if (shuffled_bucket_indexes[b] == ALREADY_VISITED_AND_BORING) {\r\n+            continue;\r\n+        }\r\n+        const size_t bucket{shuffled_bucket_indexes[b]};\r\n         int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\r\n \r\n         // Iterate over the positions of that bucket, starting at the initial one,\r\n         // and looping around.\r\n         int i;\r\n         for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\r\n@@ -769,14 +792,19 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n                 } else {\r\n                     break;\r\n                 }\r\n             }\r\n         }\r\n \r\n-        // If the bucket is entirely empty, start over with a (likely) different one.\r\n-        if (i == ADDRMAN_BUCKET_SIZE) continue;\r\n+        // Start over with a different bucket if this one is entirely empty or\r\n+        // specific network was requested and it does not contain any addresses\r\n+        // from that network.\r\n+        if (i == ADDRMAN_BUCKET_SIZE) {\r\n+            shuffled_bucket_indexes[b] = ALREADY_VISITED_AND_BORING;\r\n+            continue;\r\n+        }\r\n \r\n         // Find the entry to return.\r\n         int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n         int nId = LookupAddrmanEntry(search_tried, bucket, position);\r\n         const auto it_found{mapInfo.find(nId)};\r\n         assert(it_found != mapInfo.end());\r\n```\r\n</details>\r\n\r\nIt changes `Select(network)` to about 3000 microseconds (down from 6000), but that result from the benchmark is averaged between executions that take anything between 100 and 600k iterations. What is more important is that with the change above it never takes more than ~60k iterations, that is - anything between 100 and 60k. Worst case lowered ~10 times.\r\n\r\nThe optimization brings some complexity but IMO it is worth it.\r\n",
      "created_at": "2023-03-10T17:02:33Z",
      "updated_at": "2023-03-10T17:02:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132629513"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863",
      "pull_request_review_id": 1335415244,
      "id": 1132740863,
      "node_id": "PRRC_kwDOABII585DhED_",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This looks like a nice speedup in the case where we only have a few addresses - however, due to the constant overhead of building the shuffled list of buckets in the beginning I'd expect performance to go down a bit for the case where we have many addresses to choose from. Do you see this in your benchmark?\r\nWhy does this need `ALREADY_VISITED_AND_BORING`? If we do a for-loop through a pre-shuffled list of buckets instead of a while loop, doesn't that already guarantee that we visit each bucket at most once?",
      "created_at": "2023-03-10T18:37:32Z",
      "updated_at": "2023-03-10T18:37:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132740863",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132740863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417",
      "pull_request_review_id": 1335559840,
      "id": 1132837417,
      "node_id": "PRRC_kwDOABII585Dhbop",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129439158,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "good point about checking bounds. one way to do that is with simple checks like `assert(bucket <= ADDRMAN_TRIED_BUCKET_COUNT)` etc. \r\n\r\n> Maybe change the arrays to std::array and use .at() here.\r\n\r\nbut I'd like to understand this option better. right now `vvTried` and `vvNew` are declared as C-style arrays. is your recommendation to change those `AddrManImpl` declarations so that we can utilize the bounds checking of the `.at()` function? ",
      "created_at": "2023-03-10T20:20:42Z",
      "updated_at": "2023-03-10T20:20:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132837417",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132837417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 802,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 809,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822",
      "pull_request_review_id": 1335744428,
      "id": 1132968822,
      "node_id": "PRRC_kwDOABII585Dh7t2",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129522848,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "oh interesting, I thought that the compiler optimizes away these sort of named-variables-used-shortly-after patterns, but maybe it's different for `std::string`? I took it to compiler explorer to see if I could observe the allocation- https://godbolt.org/z/GG78zv3KT. are the calls to `std::allocator<char>` what you are referring to? ",
      "created_at": "2023-03-10T23:29:52Z",
      "updated_at": "2023-03-10T23:29:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132968822",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1132968822"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 787,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 789,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788",
      "pull_request_review_id": 1335898315,
      "id": 1133106788,
      "node_id": "PRRC_kwDOABII585DidZk",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 142,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130754068,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "this test is actually covering the `tried_count == 0` logic. if it were to hit line 746, it would sometimes select the tried table and sometimes the new table, which means it should fail 50% of the time. this coverage is ensuring that the `tried_count` has the proper interactions with `network`, which gets assigned earlier in the function-\r\n\r\n```\r\n    if (network.has_value()) {\r\n        auto it = m_network_counts.find(*network);\r\n        if (it == m_network_counts.end()) return {};\r\n\r\n        auto counts = it->second;\r\n        new_count = counts.n_new;\r\n        tried_count = counts.n_tried;\r\n    }\r\n``` \r\n\r\nlmk if that makes sense ",
      "created_at": "2023-03-11T15:29:08Z",
      "updated_at": "2023-03-11T15:29:24Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133106788",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133106788"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932",
      "pull_request_review_id": 1335901245,
      "id": 1133112932,
      "node_id": "PRRC_kwDOABII585Die5k",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "if I am understanding this thread properly, it seems like there are two concepts being discussed:\r\n1. changes to the bench tests\r\n2. optimization to `AddrManImpl::Select_`\r\n\r\nRE 1, I'm slightly confused as to the desired coverage. Without the network parameter, I would expect the worst case of the current `Select_` function to happen when addrman is practically empty, which is why we introduced `AddrManSelectFromAlmostEmpty`. On mainnet, this case would be unlikely, which is represented by `AddrManSelect`. With the network parameter, I would expect worst case to be represented by `AddrManSelectByNetwork` where theres just 1 I2P address on an addrman filled with other addresses. @vasild can you clarify what feels absent or misrepresentative?\r\n\r\nalso happy to discuss 2 further, but a question there - does it feel relevant to these patches to improve performance, or is it an orthogonal improvement (since we see similar worst cases right now)?  ",
      "created_at": "2023-03-11T15:58:51Z",
      "updated_at": "2023-03-11T15:58:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133112932",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133112932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333",
      "pull_request_review_id": 1335920167,
      "id": 1133131333,
      "node_id": "PRRC_kwDOABII585DijZF",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129434505,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "good point, updated to `GetEntry` to match the naming style of `GetAddr`",
      "created_at": "2023-03-11T18:31:04Z",
      "updated_at": "2023-03-11T18:31:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131333",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131333"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478",
      "pull_request_review_id": 1335920290,
      "id": 1133131478,
      "node_id": "PRRC_kwDOABII585DijbW",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129442167,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "updated, my understanding is that `size_t` is unsigned and better optimizes for different platforms. does that track?",
      "created_at": "2023-03-11T18:32:14Z",
      "updated_at": "2023-03-11T18:32:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131478",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131478"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507",
      "pull_request_review_id": 1335920334,
      "id": 1133131507,
      "node_id": "PRRC_kwDOABII585Dijbz",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129522848,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "updated",
      "created_at": "2023-03-11T18:32:45Z",
      "updated_at": "2023-03-11T18:32:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131507",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 787,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 789,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556",
      "pull_request_review_id": 1335920364,
      "id": 1133131556,
      "node_id": "PRRC_kwDOABII585Dijck",
      "diff_hunk": "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] network  Select only addresses of this network (nullopt = all)\n      * @return    CAddress The record for the selected peer.\n      *            seconds  The last time we attempted to connect to that peer.\n      */\n-    std::pair<CAddress, NodeSeconds> Select(bool newOnly = false) const;\n+    std::pair<CAddress, NodeSeconds> Select(bool new_only = false, std::optional<Network> network = {}) const;",
      "path": "src/addrman.h",
      "position": null,
      "original_position": 11,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129539099,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-11T18:33:05Z",
      "updated_at": "2023-03-11T18:33:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131556",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131556"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 150,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581",
      "pull_request_review_id": 1335920380,
      "id": 1133131581,
      "node_id": "PRRC_kwDOABII585Dijc9",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 58,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129547711,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-11T18:33:20Z",
      "updated_at": "2023-03-11T18:33:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131581",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131581"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 726,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605",
      "pull_request_review_id": 1335920400,
      "id": 1133131605,
      "node_id": "PRRC_kwDOABII585DijdV",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 68,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129552332,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done ",
      "created_at": "2023-03-11T18:33:30Z",
      "updated_at": "2023-03-11T18:33:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131605",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131605"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 736,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667",
      "pull_request_review_id": 1335920465,
      "id": 1133131667,
      "node_id": "PRRC_kwDOABII585DijeT",
      "diff_hunk": "@@ -146,11 +146,12 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table.",
      "path": "src/addrman.h",
      "position": null,
      "original_position": 5,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129566625,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "updated but worded it a bit differently - the 50% is only true if there are matches in both tables (with network interactions). lmk if the new language seems reasonable to you",
      "created_at": "2023-03-11T18:34:16Z",
      "updated_at": "2023-03-11T18:34:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131667",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673",
      "pull_request_review_id": 1335920475,
      "id": 1133131673,
      "node_id": "PRRC_kwDOABII585DijeZ",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 106,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129568636,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-11T18:34:25Z",
      "updated_at": "2023-03-11T18:34:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131673",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131673"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 751,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714",
      "pull_request_review_id": 1335920510,
      "id": 1133131714,
      "node_id": "PRRC_kwDOABII585DijfC",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129569710,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-11T18:34:48Z",
      "updated_at": "2023-03-11T18:34:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131714",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131714"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 765,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741",
      "pull_request_review_id": 1335920533,
      "id": 1133131741,
      "node_id": "PRRC_kwDOABII585Dijfd",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 122,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129577204,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-11T18:35:02Z",
      "updated_at": "2023-03-11T18:35:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131741",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131741"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 766,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 768,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754",
      "pull_request_review_id": 1335920546,
      "id": 1133131754,
      "node_id": "PRRC_kwDOABII585Dijfq",
      "diff_hunk": "@@ -127,45 +127,47 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));",
      "path": "src/test/addrman_tests.cpp",
      "position": 2,
      "original_position": 2,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130661248,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-11T18:35:09Z",
      "updated_at": "2023-03-11T18:35:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131754",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131754"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 128,
      "original_line": 128,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791",
      "pull_request_review_id": 1335920580,
      "id": 1133131791,
      "node_id": "PRRC_kwDOABII585DijgP",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130664213,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ah, thanks. updated lots of comments, I think I caught them all?",
      "created_at": "2023-03-11T18:35:33Z",
      "updated_at": "2023-03-11T18:35:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131791",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815",
      "pull_request_review_id": 1335920605,
      "id": 1133131815,
      "node_id": "PRRC_kwDOABII585Dijgn",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130668333,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "thanks, updated this in lots of places",
      "created_at": "2023-03-11T18:35:48Z",
      "updated_at": "2023-03-11T18:35:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131815",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847",
      "pull_request_review_id": 1335920639,
      "id": 1133131847,
      "node_id": "PRRC_kwDOABII585DijhH",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130699029,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "incorporated this in many places in the tests I touched. definitely reads better",
      "created_at": "2023-03-11T18:36:11Z",
      "updated_at": "2023-03-11T18:36:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131847",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 208,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864",
      "pull_request_review_id": 1335920643,
      "id": 1133131864,
      "node_id": "PRRC_kwDOABII585DijhY",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 106,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130705627,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "added",
      "created_at": "2023-03-11T18:36:17Z",
      "updated_at": "2023-03-11T18:36:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131864",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874",
      "pull_request_review_id": 1335920656,
      "id": 1133131874,
      "node_id": "PRRC_kwDOABII585Dijhi",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 97,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130712887,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done",
      "created_at": "2023-03-11T18:36:26Z",
      "updated_at": "2023-03-11T18:36:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131874",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929",
      "pull_request_review_id": 1335920706,
      "id": 1133131929,
      "node_id": "PRRC_kwDOABII585DijiZ",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 126,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130731456,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "great idea ! updated to use this while loop. also added you as co-author for this commit btw, thanks for the in depth review :)",
      "created_at": "2023-03-11T18:36:58Z",
      "updated_at": "2023-03-11T18:36:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131929",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131929"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 241,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961",
      "pull_request_review_id": 1335920753,
      "id": 1133131961,
      "node_id": "PRRC_kwDOABII585Diji5",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // add single I2P address to new table\n+    CService i2p_service;\n+    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    CAddress i2p_address(i2p_service, NODE_NONE);\n+    i2p_address.nTime = Now<NodeSeconds>();\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    addrman.Add({i2p_address}, source);\n+\n+    FillAddrMan(addrman);\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select(/*new_only*/false, NET_I2P);\n+        assert(address.first.ToStringAddrPort() == \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");",
      "path": "src/bench/addrman.cpp",
      "position": null,
      "original_position": 66,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130835999,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "that makes sense, updated to remove correctness tests",
      "created_at": "2023-03-11T18:37:28Z",
      "updated_at": "2023-03-11T18:37:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131961",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 145,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985",
      "pull_request_review_id": 1335920779,
      "id": 1133131985,
      "node_id": "PRRC_kwDOABII585DijjR",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);",
      "path": "src/bench/addrman.cpp",
      "position": null,
      "original_position": 46,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130840488,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yeah it was, but updated to remove that assertion. ",
      "created_at": "2023-03-11T18:37:41Z",
      "updated_at": "2023-03-11T18:37:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1133131985",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133131985"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 125,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031",
      "pull_request_review_id": 1341141202,
      "id": 1136853031,
      "node_id": "PRRC_kwDOABII585DwwAn",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@mzumsande,\r\n\r\n> I'd expect performance to go down a bit for the case where we have many addresses to choose from. Do you see this in your benchmark?\r\n\r\nYes, that slows down a bit the fast `Select()` (any network is ok). I observed that and think it is ok because it is still super fast with or without the shuffling.\r\n\r\n> Why does this need `ALREADY_VISITED_AND_BORING`?\r\n\r\nThe `for` loop could still repeat the whole array from the start if some address was found but was skipped. `ALREADY_VISITED_AND_BORING` is a further optimization to completely skip that bucket on the second and further passes through the array.\r\n\r\n@amitiuttarwar, you are right that I modified the newly added `AddrManSelectByNetwork()` so that, in general, it tests the same thing as `AddrManSelect()` which already exists in `master`. I did that in order to be sure that everything else is _identical_: the way addrman is filled, `minEpochIterations(300)` and the `GetPort()` call. Way too many times I have been bitten by chasing noise in benchmarks, so I wanted to be sure that this is the only difference in the two things I am comparing:\r\n\r\n```cpp\r\n#if 0 // flip to 1 to test the other case\r\n        addrman.Select(/*new_only=*/false);\r\n#else\r\n        addrman.Select(/*new_only=*/false, NET_I2P);\r\n#endif\r\n```\r\n\r\n> also happy to discuss 2 further, but a question there - does it feel relevant to these patches to improve performance, or is it an orthogonal improvement\r\n\r\nI think the performance improvement would be a nice addition to the work done by this PR (or maybe even a \"must have\"?)\r\n\r\n> (since we see similar worst cases right now)?\r\n\r\nHmm? Now on `master` on mainnet it takes 0.18 microseconds and with this PR on mainnet it will take 6000 microseconds. That is the average case (averaged by the benchmark executing `Select` about 3500 times). The difference in the worst case is even more pronounced.",
      "created_at": "2023-03-15T10:40:18Z",
      "updated_at": "2023-03-15T10:40:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136853031",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136853031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429",
      "pull_request_review_id": 1341177551,
      "id": 1136869429,
      "node_id": "PRRC_kwDOABII585Dw0A1",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129439158,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, but I am not saying to do it (use `std::array` and `.at()`). It is just an option, in case you have not considered it. Up to you.\r\n\r\nBtw, a difference between an `assert()` and `.at()` is that the former will call `abort()` and will inevitably cause the program to exit. OTOH `.at()` will throw `std::out_of_range` which the caller can catch and continue the execution. I don't have a strong opinion which one is more preferable to use here. Maybe either one is ok. Usually on such \"programmer error\" we want to really stop the whole program, OTOH `.at()` is much more elegant to write :) and if the exception is unhandled then it will also cause the program to exit.",
      "created_at": "2023-03-15T10:54:20Z",
      "updated_at": "2023-03-15T10:54:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136869429",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136869429"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 802,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 809,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077",
      "pull_request_review_id": 1341203111,
      "id": 1136880077,
      "node_id": "PRRC_kwDOABII585Dw2nN",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 142,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130754068,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oh, yes, now it makes sense! I was confused. I should have read the comment like:\r\n\"ensure that the new table gets selected even if new_only is false _(because the tried table is empty)_\"",
      "created_at": "2023-03-15T11:03:24Z",
      "updated_at": "2023-03-15T11:03:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136880077",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136880077"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366",
      "pull_request_review_id": 1341228747,
      "id": 1136890366,
      "node_id": "PRRC_kwDOABII585Dw5H-",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 155,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129442167,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes. Also std methods that take such \"indexes\" are usually `size_t`, e.g. https://en.cppreference.com/w/cpp/container/array/operator_at",
      "created_at": "2023-03-15T11:12:37Z",
      "updated_at": "2023-03-15T11:12:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1136890366",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136890366"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 798,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484",
      "pull_request_review_id": 1341539035,
      "id": 1137099484,
      "node_id": "PRRC_kwDOABII585DxsLc",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 106,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130705627,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Where?",
      "created_at": "2023-03-15T13:46:01Z",
      "updated_at": "2023-03-15T13:46:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137099484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137099484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909",
      "pull_request_review_id": 1341641215,
      "id": 1137181909,
      "node_id": "PRRC_kwDOABII585DyATV",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130664213,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think so, thanks!",
      "created_at": "2023-03-15T14:32:05Z",
      "updated_at": "2023-03-15T14:32:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137181909",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137181909"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957",
      "pull_request_review_id": 1342072709,
      "id": 1137526957,
      "node_id": "PRRC_kwDOABII585DzUit",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Hmm? Now on master on mainnet it takes 0.18 microseconds and with this PR on mainnet it will take 6000 microseconds. That is the average case (averaged by the benchmark executing Select about 3500 times). The difference in the worst case is even more pronounced.\r\n\r\nWe might be using slightly different terminology here: With \"worst case\", I mean the edge case where we have just one entry in AddrMan of the kind of address that we want. This is the benchmark `AddrManSelectFromAlmostEmpty` for unspecific selection and `AddrManSelectByNetwork` for network-specific selection. \r\n>#if 0 // flip to 1 to test the other case\r\n        addrman.Select(/*new_only=*/false);\r\n#else\r\n        addrman.Select(/*new_only=*/false, NET_I2P);\r\n#endif\r\n\r\nThis is not a meaningful comparison, because the first case is picking from an almost full AddrMan (\"best case\"), and the second case is the \"worst case\". If you replace `NET_I2P` by `NET_IPV4` in that example, I'd expect the network-specific performance to be basically identical to that of unspecific `Select()`, because AddrMan contains a single I2P address and ~50k IPV4 addresses in your setup.\r\n\r\nFluctuations due to RNG randomness within a given benchmark shouldn't be called \"worst case\" in my opinion, especially because there is no lower limit with the way `Select_()` currently works: for a given RNG seed, we might not visit the required bucket \"forever\" even if the probability for that will go to zero so quickly that it will never happen - there just is no distinct lower bound we could call \"worst case\" because it's probabilistic).\r\n\r\n> Yes, that slows down a bit the fast `Select()` (any network is ok).\r\n\r\nThe crucial question is by how much, because situations close to the \"worst case\" should be rather infrequent, while situations where we have multiple addresses to choose from should me much more common. With all the different methods of getting addresses, after a while of running your node you should at least know a couple dozens of addresses for each reachable network (even for CJDNS?!).\r\nSo there is the possibility that we might be optimizing for an edge case that is encountered very infrequently in the wild, while slightly slowing down the frequently encountered case at the same time. In this case, the change could be detrimental for performance overall!\r\n\r\nI'm not saying this would be the case here, but I want to do some more in-depth benchmarking myself later this week to convince myself a bit more that this would really be a clear performance improvement overall.",
      "created_at": "2023-03-15T17:48:50Z",
      "updated_at": "2023-03-15T18:07:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1137526957",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137526957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842",
      "pull_request_review_id": 1342882508,
      "id": 1138102842,
      "node_id": "PRRC_kwDOABII585D1hI6",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(CAddress(i2p_addr, NODE_NONE)));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+\n+    // add another I2P address to the new table\n+    CService i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr2, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p:0\");\n+\n+    // ensure that both new and tried table are selected from\n+    std::set<std::string> i2p_addrs;\n+    for (int i = 0; i < 10; ++i) {\n+        i2p_addrs.insert(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort());\n+    }\n+    BOOST_CHECK_EQUAL(i2p_addrs.size(), 2U);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // since the only address is on the new table, ensure that the new table\n+    // gets selected even if new_only is false. if the table was being selected\n+    // at random, this test will sporadically fail\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.3:8333\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 142,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130754068,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yeah, just to clarify- the tried table doesn't have to be empty, it just needs to have no matches for the specific network. I tried to capture that in the beginning of the comment: \"since the only ipv4 address is on the new table\", but let me know if there's something else that would help make that more clear",
      "created_at": "2023-03-16T04:29:45Z",
      "updated_at": "2023-03-16T04:29:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1138102842",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138102842"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 259,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315",
      "pull_request_review_id": 1346757351,
      "id": 1140727315,
      "node_id": "PRRC_kwDOABII585D_h4T",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I compared the performance of the PR branch with @vasild's [suggested optimization](https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513) (\"VD\") a bit more closely:\r\n\r\n**Test 1**: Reasonably full addrman (15k addresses): `./bench_bitcoin -filter=AddrManSelect -min-time=5000`\r\n=> The PR is much faster, since VD has a constant overhead due to the shuffling.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              142.41 |        7,021,818.47 |    0.2% |      5.50 | `AddrManSelect`    \r\n|              145.75 |        6,860,921.17 |    0.4% |      5.63 | `AddrManSelect`\r\n|              145.91 |        6,853,404.83 |    1.4% |      5.55 | `AddrManSelect`\r\n|              149.78 |        6,676,385.78 |    3.7% |      5.63 | `AddrManSelect`\r\n|              144.37 |        6,926,771.77 |    0.3% |      5.49 | `AddrManSelect`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           12,716.43 |           78,638.44 |    0.1% |      5.49 | `AddrManSelect`\r\n|           12,790.84 |           78,180.95 |    0.8% |      5.36 | `AddrManSelect`\r\n|           12,884.37 |           77,613.41 |    0.7% |      5.53 | `AddrManSelect`\r\n|           12,815.30 |           78,031.72 |    0.9% |      5.52 | `AddrManSelect`\r\n|           12,961.91 |           77,149.10 |    1.3% |      5.55 | `AddrManSelect`\r\n</details>\r\n\r\n\r\n<br />\r\n\r\n**Test 2**: A single address in AddrMan:  \r\n`bench_bitcoin -filter=AddrManSelectFromAlmostEmpty -min-time=5000`\r\n=> VD is faster by  a factor of 1.8\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           93,286.28 |           10,719.69 |    2.2% |      5.42 | `AddrManSelectFromAlmostEmpty`\r\n|           90,781.42 |           11,015.47 |    1.0% |      5.52 | `AddrManSelectFromAlmostEmpty`\r\n|           92,758.06 |           10,780.73 |    1.2% |      5.57 | `AddrManSelectFromAlmostEmpty`\r\n|           90,026.20 |           11,107.88 |    0.7% |      5.52 | `AddrManSelectFromAlmostEmpty`\r\n|           91,946.89 |           10,875.84 |    1.1% |      5.47 | `AddrManSelectFromAlmostEmpty`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           55,306.93 |           18,080.92 |    0.7% |      5.50 | `AddrManSelectFromAlmostEmpty`\r\n|           55,209.86 |           18,112.71 |    0.4% |      5.48 | `AddrManSelectFromAlmostEmpty`\r\n|           54,989.61 |           18,185.25 |    0.5% |      5.51 | `AddrManSelectFromAlmostEmpty`\r\n|           56,727.70 |           17,628.07 |    2.1% |      5.57 | `AddrManSelectFromAlmostEmpty`\r\n|           55,732.54 |           17,942.84 |    0.5% |      5.50 | `AddrManSelectFromAlmostEmpty`\r\n</details>\r\n\r\n**Test 3**: Three addresses in AddrMan:  set `NUM_SOURCES = 3`, `NUM_ADDRESSES_PER_SOURCE=1` then run \r\n`./bench_bitcoin -filter=AddrManSelect -min-time=5000`\r\n=> PR is slightly faster.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           30,034.99 |           33,294.50 |    0.7% |      5.51 | `AddrManSelect`\r\n|           30,370.28 |           32,926.92 |    1.1% |      5.17 | `AddrManSelect`\r\n|           30,574.52 |           32,706.98 |    2.1% |      5.20 | `AddrManSelect`\r\n|           29,883.53 |           33,463.25 |    0.7% |      5.52 | `AddrManSelect`\r\n|           29,944.31 |           33,395.33 |    0.5% |      5.52 | `AddrManSelect`\r\n\r\nVD:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|           34,126.18 |           29,303.02 |    0.7% |      5.30 | `AddrManSelect`\r\n|           34,660.26 |           28,851.49 |    0.9% |      5.32 | `AddrManSelect`\r\n|           34,075.81 |           29,346.33 |    0.7% |      5.30 | `AddrManSelect`\r\n|           34,628.06 |           28,878.31 |    1.3% |      5.36 | `AddrManSelect`\r\n|           34,300.57 |           29,154.03 |    0.6% |      5.31 | `AddrManSelect`\r\n</details>\r\n\r\n**Test 4**:\r\nQuery for a single network-specific address in an AddrMan filled with 15k IPV4 addresses we don't want\r\n`./bench_bitcoin -filter=AddrManSelectByNetwork -min-time=5000`\r\n=> VD is faster by a factor of ~2.1.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|        1,256,860.84 |              795.63 |    4.4% |      5.40 | `AddrManSelectByNetwork`\r\n|        1,269,322.70 |              787.82 |    2.6% |      5.50 | `AddrManSelectByNetwork`\r\n|        1,242,639.25 |              804.74 |    1.9% |      5.56 | `AddrManSelectByNetwork`\r\n|        1,246,311.65 |              802.37 |    2.9% |      5.69 | `AddrManSelectByNetwork`\r\n|        1,265,535.68 |              790.18 |    3.4% |      5.59 | `AddrManSelectByNetwork`\r\n\r\nVD\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          560,818.30 |            1,783.11 |    1.0% |      5.56 | `AddrManSelectByNetwork`\r\n|          558,351.91 |            1,790.99 |    0.9% |      5.53 | `AddrManSelectByNetwork`\r\n|          600,536.33 |            1,665.18 |    4.8% |      5.38 | `AddrManSelectByNetwork`\r\n|          569,208.08 |            1,756.83 |    1.7% |      5.45 | `AddrManSelectByNetwork`\r\n|          581,860.03 |            1,718.63 |    2.3% |      5.47 | `AddrManSelectByNetwork`\r\n</details>\r\n\r\n**Test 5**:\r\nQuery for 20 network-specific address in an AddrMan filled with 15k IPV4 addresses we don't want (changing the code a bit)\r\n`./bench_bitcoin -filter=AddrManSelectByNetwork -min-time=5000`\r\n=> Performance is approximately the same.\r\n<details>\r\n<summary>Details</summary>\r\n\r\nPR:\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          109,388.10 |            9,141.76 |    1.6% |      5.40 | `AddrManSelectByNetwork`\r\n|          108,804.63 |            9,190.79 |    2.1% |      5.56 | `AddrManSelectByNetwork`\r\n|          111,333.16 |            8,982.05 |    2.0% |      5.61 | `AddrManSelectByNetwork`\r\n|          110,827.61 |            9,023.02 |    1.4% |      5.55 | `AddrManSelectByNetwork`\r\n|          122,518.06 |            8,162.06 |    1.4% |      5.47 | `AddrManSelectByNetwork`\r\n\r\nVD\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|          106,806.78 |            9,362.70 |    2.5% |      5.51 | `AddrManSelectByNetwork`\r\n|          109,221.66 |            9,155.69 |    3.1% |      5.59 | `AddrManSelectByNetwork`\r\n|          107,870.77 |            9,270.35 |    3.8% |      5.41 | `AddrManSelectByNetwork`\r\n|          105,131.17 |            9,511.93 |    0.5% |      5.47 | `AddrManSelectByNetwork`\r\n|          106,080.47 |            9,426.81 |    1.2% |      5.48 | `AddrManSelectByNetwork`\r\n\r\n</details>\r\n\r\nIn conclusion, my results indicate that the suggested optimization is only faster in some specific scenarios because the pre-shuffling of the buckets adds a constant overhead that is not neglible:\r\nIn the case of non-network specific queries (which should be the bulk even after #27213 ), the PR is already faster when `AddrMan` has more than 3 addresses (which should virtually always be the case!)\r\nIn the case of network-specific queries, the tipping point is (because of the additional cost of looking up addrs in buckets that we can't use) at ~20 network-specific addresses (with 15k IPV4 addresses). This is a bit higher, but I would imagine that we should get more than 20 addresses of most alternative networks rather quickly.\r\nTo summarize, my results indicate that adding pre-shuffling AddrMan buckets to prevent repeated visits appears to be no clear performance improvement - in most cases, performance would go down.\r\n\r\n@vasild: Do you see similar numbers?\r\n",
      "created_at": "2023-03-17T21:30:32Z",
      "updated_at": "2023-03-18T00:30:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140727315",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140727315"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873089",
      "pull_request_review_id": 1346856516,
      "id": 1140873089,
      "node_id": "PRRC_kwDOABII585EAFeB",
      "diff_hunk": "@@ -181,17 +183,85 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"[::]:0\");\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+\n+    // add I2P address to the new table\n+    CService i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({CAddress(i2p_addr, NODE_NONE)}, source));\n+\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/true, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_I2P).first.ToStringAddrPort(), \"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV4).first.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_IPV6).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_ONION).first.ToStringAddrPort(), \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addrman->Select(/*new_only*/false, NET_CJDNS).first.ToStringAddrPort(), \"[::]:0\");",
      "path": "src/test/addrman_tests.cpp",
      "position": null,
      "original_position": 106,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130705627,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "maybe I was thinking of `BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_I2P).first.IsValid());`? \r\n\r\nnot sure, I [added](https://github.com/bitcoin/bitcoin/compare/09d514583f15860f3bc7ae0c89e640c94fae3c71..17e705428ddf80c7a7f31fe5430d966cf08a37d6#diff-34d1a0e093152df355fc3a6b5b06156f7a9b936bfffb26bb221e62828e44532fR211) `BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_CJDNS).first.IsValid());` for real this time ðŸ™ƒ ",
      "created_at": "2023-03-18T01:05:54Z",
      "updated_at": "2023-03-18T01:05:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140873089",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873566",
      "pull_request_review_id": 1346856667,
      "id": 1140873566,
      "node_id": "PRRC_kwDOABII585EAFle",
      "diff_hunk": "@@ -714,72 +714,95 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if ((new_count + tried_count) == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    //  Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = LookupAddrmanEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    const auto info{it->second};\n+                    if (info.GetNetwork() == *network) break;\n+                } else {\n+                    break;\n+                }\n             }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n         }\n+\n+        // If the bucket is entirely empty, start over with a (likely) different one.\n+        if (i == ADDRMAN_BUCKET_SIZE) continue;\n+\n+        // Find the entry to return.\n+        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+        int nId = LookupAddrmanEntry(search_tried, bucket, position);\n+        const auto it_found{mapInfo.find(nId)};\n+        assert(it_found != mapInfo.end());\n+        const AddrInfo& info{it_found->second};\n+\n+        // With probability GetChance() * chance_factor, return the entry.\n+        if (insecure_rand.randbits(30) < chance_factor * info.GetChance() * (1 << 30)) {\n+            std::string table_name;\n+            search_tried ? table_name = \"tried\" : table_name = \"new\";\n+            LogPrint(BCLog::ADDRMAN, \"Selected %s from %s\\n\", info.ToStringAddrPort(), table_name);\n+            return {info, info.m_last_try};\n+        }\n+\n+        // Otherwise start over with a (likely) different bucket, and increased chance factor.\n+        chance_factor *= 1.2;\n+    }\n+}\n+\n+int AddrManImpl::LookupAddrmanEntry(bool use_tried, int bucket, int position) const\n+{\n+    AssertLockHeld(cs);\n+\n+    if (use_tried) {\n+        return vvTried[bucket][position];\n+    } else {\n+        return vvNew[bucket][position];\n     }",
      "path": "src/addrman.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1129439158,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "opted for the simple assertions because its less invasive & I didn't feel like there was a big advantage of switching over",
      "created_at": "2023-03-18T01:06:51Z",
      "updated_at": "2023-03-18T01:06:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1140873566",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1140873566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": 802,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 809,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147633787",
      "pull_request_review_id": 1356788467,
      "id": 1147633787,
      "node_id": "PRRC_kwDOABII585EZ4B7",
      "diff_hunk": "@@ -714,72 +714,98 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network.has_value()) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if (new_count + tried_count == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    // Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;",
      "path": "src/addrman.cpp",
      "position": 115,
      "original_position": 115,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just a suggestion to make the code a lit bit cleaner in case you have to touch it again, perhaps we don't need to create `position` and `nId` again after the loop.\r\n\r\n```diff\r\ndiff --git a/src/addrman.cpp b/src/addrman.cpp\r\nindex cdfd079fc..30ce2cadc 100644\r\n--- a/src/addrman.cpp\r\n+++ b/src/addrman.cpp\r\n@@ -757,10 +757,10 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n \r\n         // Iterate over the positions of that bucket, starting at the initial one,\r\n         // and looping around.\r\n-        int i;\r\n+        int i, position, node_id;\r\n         for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\r\n-            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n-            int node_id = GetEntry(search_tried, bucket, position);\r\n+            position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n+            node_id = GetEntry(search_tried, bucket, position);\r\n             if (node_id != -1) {\r\n                 if (network.has_value()) {\r\n                     const auto it{mapInfo.find(node_id)};\r\n@@ -777,9 +777,7 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n         if (i == ADDRMAN_BUCKET_SIZE) continue;\r\n \r\n         // Find the entry to return.\r\n-        int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n-        int nId = GetEntry(search_tried, bucket, position);\r\n-        const auto it_found{mapInfo.find(nId)};\r\n+        const auto it_found{mapInfo.find(node_id)};\r\n         assert(it_found != mapInfo.end());\r\n         const AddrInfo& info{it_found->second};\r\n```",
      "created_at": "2023-03-24T14:11:43Z",
      "updated_at": "2023-03-24T14:37:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1147633787",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147633787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 760,
      "original_line": 760,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147671339",
      "pull_request_review_id": 1356842496,
      "id": 1147671339,
      "node_id": "PRRC_kwDOABII585EaBMr",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "About the optimization in https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513, couldn't we simply use a vector to store the visited buckets?\r\n\r\njust an example:\r\n```cpp\r\n  std::vector<int> buckets_visited;\r\n  while (1) {\r\n      // Pick a bucket, and an initial position in that bucket.\r\n      int bucket = insecure_rand.randrange(bucket_count);\r\n      if (std::find(buckets_visited.begin(), buckets_visited.end(), bucket) != buckets_visited.end()) {\r\n          continue;\r\n      } else {\r\n          buckets_visited.push_back(bucket);\r\n      }\r\n```\r\n\r\nAlso, I ran same tests that @mzumsande did and got similar results.",
      "created_at": "2023-03-24T14:36:47Z",
      "updated_at": "2023-03-24T14:36:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1147671339",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147671339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148304529",
      "pull_request_review_id": 1357774569,
      "id": 1148304529,
      "node_id": "PRRC_kwDOABII585EcbyR",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@mzumsande, I think you are missing my point, let me try to rephrase it: now on `master`, from `ThreadOpenConnections()` we call `Select()`. With the parent of this PR, we will be calling `Select(network)` which will bring some security (good) + some slowdown (bad).\r\n\r\nTry to asses how much is the slowdown. Use a full addrman (15k is not full) because that is what people out there are running on. If the slowdown is ok, then no further improvements are necessary on this PR or its parent.\r\n\r\nWhat is your \"Test 5\" doing? Does it call 20 times `Select(network)`?\r\n\r\nFurther thoughts if an improvement of performance of `Select(network)` is deemed necessary:\r\n* The shuffling can be done only if `network` is provided, to avoid slowing down of `Select()` without a network.\r\n* The shuffling can be removed altogether and just marking the buckets as boring to be left. This should still improve the 600k iterations in the worst case I observed.\r\n* The ultimate beast solution would be to have an index per network, e.g. `std::unordered_set<size_t> positions_in_vRandom_of_i2p_addresses`.\r\n\r\nI will try to compare on a snapshot of an addrman from my public full node, not on artificially filled addrman from the bench. Last time I checked it had ~70k addresses and also it will have at least a bunch of addresses from each network, not just 1 address. That would be more representative.",
      "created_at": "2023-03-25T04:51:40Z",
      "updated_at": "2023-03-25T04:51:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1148304529",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148304529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148307887",
      "pull_request_review_id": 1357777412,
      "id": 1148307887,
      "node_id": "PRRC_kwDOABII585Eccmv",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@brunoerg, yes, that should still bring some improvement. But only push it into the vector if we have visited all addresses in that bucket and found 0 from the requested network because it may happen that we visit a bucket with an address from the requested network, but only pick it up on some of the subsequent iterations, not from the first one. Change it to `std::unordered_set` so that lookup is fast (`O(1)`).",
      "created_at": "2023-03-25T05:22:50Z",
      "updated_at": "2023-03-25T05:22:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1148307887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148307887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149579411",
      "pull_request_review_id": 1359554205,
      "id": 1149579411,
      "node_id": "PRRC_kwDOABII585EhTCT",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Last time I checked it had ~70k addresses and also it will have at least a bunch of addresses from each network, not just 1 address.\r\n\r\n\"bunch of addresses from each network\", how much? Last time I checked my node (running with multiple networks) I remembered that the number of i2p addresses were so small compared to clearnet, for example.",
      "created_at": "2023-03-27T17:27:04Z",
      "updated_at": "2023-03-27T17:27:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149579411",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149579411"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149603943",
      "pull_request_review_id": 1359589822,
      "id": 1149603943,
      "node_id": "PRRC_kwDOABII585EhZBn",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> \"bunch of addresses from each network\", how much?\r\n\r\nIf helpful, my node knows 15k Tor, 1.2k I2P and 8 CJDNS recently active peers ATM for a bit more than 16k total non-clearnet peers.",
      "created_at": "2023-03-27T17:51:04Z",
      "updated_at": "2023-03-27T17:51:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149603943",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149603943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149737863",
      "pull_request_review_id": 1359793696,
      "id": 1149737863,
      "node_id": "PRRC_kwDOABII585Eh5uH",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Try to asses how much is the slowdown. Use a full addrman (15k is not full) because that is what people out there are running on. If the slowdown is ok, then no further improvements are necessary on this PR or its parent.\r\n\r\nagreed that this is the fundamental thing we are trying to evaluate - is the performance difference significant & acceptable\r\n\r\n> I will try to compare on a snapshot of an addrman from my public full node, not on artificially filled addrman from the bench. Last time I checked it had ~70k addresses and also it will have at least a bunch of addresses from each network, not just 1 address. That would be more representative.\r\n\r\nwould be awesome if you could compare based on your addrman snapshot from mainnet! \r\n\r\nmy understanding of martin's benches is its trying to observe \"normal\" as well as \"worst case\". so the examples with 1 address are aiming towards \"worst case\". but of course \"normal\" would vary widely from node to node.",
      "created_at": "2023-03-27T20:05:30Z",
      "updated_at": "2023-03-27T20:05:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149737863",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149737863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149790004",
      "pull_request_review_id": 1359870138,
      "id": 1149790004,
      "node_id": "PRRC_kwDOABII585EiGc0",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> What is your \"Test 5\" doing? Does it call 20 times `Select(network)`?\r\n\r\nNo, it calls `Select(network)` for an addrman that has 20 addresses of the selected network.\r\n\r\nI'll try to explain the idea behind my benchmarks better: \r\nStarting point is the observation that the suggested change makes `Select` slower if we already know a lot of addresses of the desired type, while making it faster if addrman has very few addresses of this type. This is true for botch `Select()` and `Select(network)`, which is why it is not obvious at first sight if the suggestion is an overall performance improvement or a degradation. \r\n\r\nSo my idea was to find the cutoff - how many addresses do we need such that both algorithms are equally fast - in situations where we have more addrs than this, the change would be a slowdown, when we have less it's a speedup. This cutoff turned out to be very small for `Select()` (3 addresses), while being a bit larger for `Select(network)` - it was approximately 20. It would be helpful to know how things change with a full addrman!\r\n\r\nSo if we used an addrman with counts similar to those reported by @jonatack, my results would suggest that the pre-shufffling change suggested [here](https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1132629513) would be a speedup for CJDNS-specific queries, while being a slowdown for clearnet, onion, i2p and unspecific queries (all compared to this PR).",
      "created_at": "2023-03-27T21:04:50Z",
      "updated_at": "2023-03-27T21:04:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1149790004",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149790004"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153482086",
      "pull_request_review_id": 1365462147,
      "id": 1153482086,
      "node_id": "PRRC_kwDOABII585EwL1m",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "vasild",
        "id": 266751,
        "node_id": "MDQ6VXNlcjI2Njc1MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vasild",
        "html_url": "https://github.com/vasild",
        "followers_url": "https://api.github.com/users/vasild/followers",
        "following_url": "https://api.github.com/users/vasild/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vasild/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vasild/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
        "organizations_url": "https://api.github.com/users/vasild/orgs",
        "repos_url": "https://api.github.com/users/vasild/repos",
        "events_url": "https://api.github.com/users/vasild/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vasild/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I ran this on a mainnet `peers.dat`:\r\n```\r\naddrman size total: 72947\r\naddrman size IPv4:  47252\r\naddrman size IPv6:  11491\r\naddrman size Tor:   13305\r\naddrman size I2P:   893\r\naddrman size CJDNS: 6\r\n```\r\n\r\n<details>\r\n<summary>[patch] How to load /tmp/peers.dat from bench_bitcoin</summary>\r\n\r\n```diff\r\ndiff --git i/src/bench/addrman.cpp w/src/bench/addrman.cpp\r\nindex 8a5cab443f..b8ec4a4071 100644\r\n--- i/src/bench/addrman.cpp\r\n+++ w/src/bench/addrman.cpp\r\n@@ -1,17 +1,22 @@\r\n // Copyright (c) 2020-2022 The Bitcoin Core developers\r\n // Distributed under the MIT software license, see the accompanying\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n+#include <addrdb.h>\r\n #include <addrman.h>\r\n #include <bench/bench.h>\r\n+#include <chainparams.h>\r\n+#include <chainparamsbase.h>\r\n #include <netbase.h>\r\n #include <netgroup.h>\r\n #include <random.h>\r\n #include <util/check.h>\r\n+#include <util/system.h>\r\n #include <util/time.h>\r\n+#include <util/translation.h>\r\n \r\n #include <optional>\r\n #include <vector>\r\n \r\n /* A \"source\" is a source address from which we have received a bunch of other addresses. */\r\n \r\n@@ -21,12 +26,23 @@ static constexpr size_t NUM_ADDRESSES_PER_SOURCE = 256;\r\n static NetGroupManager EMPTY_NETGROUPMAN{std::vector<bool>()};\r\n static constexpr uint32_t ADDRMAN_CONSISTENCY_CHECK_RATIO{0};\r\n \r\n static std::vector<CAddress> g_sources;\r\n static std::vector<std::vector<CAddress>> g_addresses;\r\n \r\n+std::unique_ptr<AddrMan> LoadAddrmanFromPeersDat()\r\n+{\r\n+    SelectBaseParams(\"main\");\r\n+    SelectParams(\"main\");\r\n+    gArgs.ForceSetArg(\"-datadir\", \"/tmp\");\r\n+    std::unique_ptr<AddrMan> addrman;\r\n+    auto err = LoadAddrman(EMPTY_NETGROUPMAN, gArgs, addrman);\r\n+    assert(!err.has_value());\r\n+    return addrman;\r\n+}\r\n+\r\n static void CreateAddresses()\r\n {\r\n     if (g_sources.size() > 0) { // already created\r\n         return;\r\n     }\r\n \r\n@@ -69,19 +85,12 @@ static void FillAddrMan(AddrMan& addrman)\r\n {\r\n     CreateAddresses();\r\n \r\n     AddAddressesToAddrMan(addrman);\r\n }\r\n \r\n-static CNetAddr ResolveIP(const std::string& ip)\r\n-{\r\n-    CNetAddr addr;\r\n-    LookupHost(ip, addr, false);\r\n-    return addr;\r\n-}\r\n-\r\n static CService ResolveService(const std::string& ip, uint16_t port = 0)\r\n {\r\n     CService serv;\r\n     Lookup(ip, serv, port, false);\r\n     return serv;\r\n }\r\n@@ -125,26 +134,24 @@ static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\r\n         (void)addrman.Select();\r\n     });\r\n }\r\n \r\n static void AddrManSelectByNetwork(benchmark::Bench& bench)\r\n {\r\n-    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\r\n-\r\n-    // add single I2P address to new table\r\n-    CService i2p_service;\r\n-    i2p_service.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\r\n-    CAddress i2p_address(i2p_service, NODE_NONE);\r\n-    i2p_address.nTime = Now<NodeSeconds>();\r\n-    CNetAddr source = ResolveIP(\"252.2.2.2\");\r\n-    addrman.Add({i2p_address}, source);\r\n-\r\n-    FillAddrMan(addrman);\r\n+    auto addrman = LoadAddrmanFromPeersDat();\r\n+    std::cout << \"addrman size total: \" << addrman->Size() << std::endl\r\n+              << \"addrman size IPv4:  \" << addrman->Size(NET_IPV4) << std::endl\r\n+              << \"addrman size IPv6:  \" << addrman->Size(NET_IPV6) << std::endl\r\n+              << \"addrman size Tor:   \" << addrman->Size(NET_ONION) << std::endl\r\n+              << \"addrman size I2P:   \" << addrman->Size(NET_I2P) << std::endl\r\n+              << \"addrman size CJDNS: \" << addrman->Size(NET_CJDNS) << std::endl;\r\n \r\n     bench.run([&] {\r\n-        (void)addrman.Select(/*new_only=*/false, NET_I2P);\r\n+        //addrman->Select(/*new_only=*/false);\r\n+        //addrman->Select(/*new_only=*/false, NET_I2P);\r\n+        addrman->Select(/*new_only=*/false, NET_CJDNS);\r\n     });\r\n }\r\n \r\n static void AddrManGetAddr(benchmark::Bench& bench)\r\n {\r\n     AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\r\n```\r\n</details>\r\n\r\nResults:\r\n\r\n* `Select(/*new_only=*/false)`: 0.265 microseconds, this is what `master` is doing before this PR\r\n\r\nAfter this PR:\r\n\r\n* `Select(/*new_only=*/false, NET_IPV4)`: 0.5 microseconds\r\n* `Select(/*new_only=*/false, NET_IPV6)`:  1.7 microseconds\r\n* `Select(/*new_only=*/false, NET_ONION)`: 3.1 microseconds\r\n* `Select(/*new_only=*/false, NET_I2P)`: 27 microseconds\r\n* `Select(/*new_only=*/false, NET_CJDNS)`: 1600 microseconds\r\n\r\nIs this slowdown acceptable? Maybe yes. We don't call `Select` in a tight loop, so maybe even the 1600 microseconds is ok.\r\n\r\nWhat happens if we mark and subsequently skip buckets we have seen to contain 0 interesting addresses, without the shuffling? I guess that should bring most of the improvement from the above patch without the downside of the shuffling. Here is the change on top of this PR:\r\n\r\n<details>\r\n<summary>[patch] Skip boring</summary>\r\n\r\n```diff\r\ndiff --git i/src/addrman.cpp w/src/addrman.cpp\r\nindex cdfd079fcd..46f4de99be 100644\r\n--- i/src/addrman.cpp\r\n+++ w/src/addrman.cpp\r\n@@ -747,15 +747,19 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n     }\r\n \r\n     const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\r\n \r\n     // Loop through the addrman table until we find an appropriate entry\r\n     double chance_factor = 1.0;\r\n+    std::unordered_set<int> already_visited_and_boring_buckets;\r\n     while (1) {\r\n         // Pick a bucket, and an initial position in that bucket.\r\n         int bucket = insecure_rand.randrange(bucket_count);\r\n+        if (already_visited_and_boring_buckets.count(bucket) > 0) {\r\n+            continue;\r\n+        }\r\n         int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\r\n \r\n         // Iterate over the positions of that bucket, starting at the initial one,\r\n         // and looping around.\r\n         int i;\r\n         for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\r\n@@ -770,14 +774,19 @@ std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::option\r\n                 } else {\r\n                     break;\r\n                 }\r\n             }\r\n         }\r\n \r\n-        // If the bucket is entirely empty, start over with a (likely) different one.\r\n-        if (i == ADDRMAN_BUCKET_SIZE) continue;\r\n+        // Start over with a different bucket if this one is entirely empty or\r\n+        // specific network was requested and it does not contain any addresses\r\n+        // from that network.\r\n+        if (i == ADDRMAN_BUCKET_SIZE) {\r\n+            already_visited_and_boring_buckets.insert(bucket);\r\n+            continue;\r\n+        }\r\n \r\n         // Find the entry to return.\r\n         int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\r\n         int nId = GetEntry(search_tried, bucket, position);\r\n         const auto it_found{mapInfo.find(nId)};\r\n         assert(it_found != mapInfo.end());\r\n```\r\n</details>\r\n\r\nResult for `NET_CJDNS` where the slowdown is most pronounced: 1200 microseconds (vs 1600). Those numbers are averaged over many runs and they do not tell the whole story. Here are the distributions without \"skip boring\" (the height of a bar indicates how many addresses were checked before finding the result, e.g. if the bar that spans between 2500 and 3500 is tall 280, it means 280 of the runs checked 2500-3500 addresses before finding the result).\r\n\r\n![1](https://user-images.githubusercontent.com/266751/228896184-9e5fe576-8c0f-44d2-9f3d-f7061ac936e3.png)\r\n\r\nwith \"skip boring\":\r\n\r\n![2](https://user-images.githubusercontent.com/266751/228896576-20b8cc6d-a121-4836-b727-adc04079a55d.png)\r\n",
      "created_at": "2023-03-30T16:04:54Z",
      "updated_at": "2023-03-30T16:04:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1153482086",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153482086"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159230852",
      "pull_request_review_id": 1373978659,
      "id": 1159230852,
      "node_id": "PRRC_kwDOABII585FGHWE",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see why 1.6 milliseconds to choose an address would be a concern.",
      "created_at": "2023-04-06T02:47:54Z",
      "updated_at": "2023-04-06T02:47:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1159230852",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159230852"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159242540",
      "pull_request_review_id": 1373996210,
      "id": 1159242540,
      "node_id": "PRRC_kwDOABII585FGKMs",
      "diff_hunk": "@@ -95,6 +110,43 @@ static void AddrManSelect(benchmark::Bench& bench)\n     });\n }\n \n+// The worst case performance of the Select() function is when there is only\n+// one address on the table, because it linearly searches every position of\n+// several buckets before identifying the correct bucket\n+static void AddrManSelectFromAlmostEmpty(benchmark::Bench& bench)\n+{\n+    AddrMan addrman{EMPTY_NETGROUPMAN, /*deterministic=*/false, ADDRMAN_CONSISTENCY_CHECK_RATIO};\n+\n+    // Add one address to the new table\n+    CService addr = ResolveService(\"250.3.1.1\", 8333);\n+    addrman.Add({CAddress(addr, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333));\n+\n+    bench.run([&] {\n+        const auto& address = addrman.Select();\n+        assert(address.first.GetPort() > 0);\n+    });\n+}\n+\n+static void AddrManSelectByNetwork(benchmark::Bench& bench)",
      "path": "src/bench/addrman.cpp",
      "position": 49,
      "original_position": 50,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "25a64a20749f10ce84060f3570ad76d1a4776948",
      "in_reply_to_id": 1130844842,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A simpler approach to skipping already tried buckets might be something like this:\r\n\r\n```c++\r\n    int n = 1 << 8; // power of 2\r\n    int initial_pos = random(n);\r\n    int step = random(n/2) * 2 + 1; // odd number\r\n    int i = initial_pos;\r\n    do {\r\n        if (check_bucket(i)) break;\r\n        i = (i + step) % n; // oops, try a new bucket\r\n    } while (i != initial_pos);\r\n```\r\n\r\nThat doesn't need a full shuffle, still hits every bucket, and only hits each bucket once (provided step and n are co-prime).\r\n\r\nBased on vasild's stats above, I think this is fine to merge without any improvement here, but it might be interesting to rebench with this approach -- performance should benefit a little from needing less randomness as well as avoiding repeated work...\r\n\r\nIf we wanted to making things actually reliably fast for cjdns-like networks lost in a sea of ipv4 addresses, then having separate addrman tables for each network might be worth exploring. That would probably help prevent an attacker from blocking valid ipv4 addresses with a mass of valid-but-sybiled tor addresses, which might be worthwhile.",
      "created_at": "2023-04-06T03:16:47Z",
      "updated_at": "2023-04-06T03:16:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1159242540",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1159242540"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 129,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1164826176",
      "pull_request_review_id": 1382390744,
      "id": 1164826176,
      "node_id": "PRRC_kwDOABII585FbdZA",
      "diff_hunk": "@@ -146,11 +146,14 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` returns\n+     *                     an address from the new table or an empty pair. Passing `false` will return an\n+     *                     address from either the new or tried table (it does not guarantee a tried entry).\n+     * @param[in] network  Select only addresses of this network (nullopt = all)",
      "path": "src/addrman.h",
      "position": 8,
      "original_position": 8,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Probably worth documenting that passing in a `network` here rather than `nullopt` can make the search significantly slower (though still fast)?",
      "created_at": "2023-04-13T01:13:56Z",
      "updated_at": "2023-04-13T01:52:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1164826176",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1164826176"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 152,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1164833780",
      "pull_request_review_id": 1382390744,
      "id": 1164833780,
      "node_id": "PRRC_kwDOABII585FbfP0",
      "diff_hunk": "@@ -714,72 +714,98 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network.has_value()) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if (new_count + tried_count == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    // Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = GetEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network.has_value()) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    assert(it != mapInfo.end());",
      "path": "src/addrman.cpp",
      "position": 122,
      "original_position": 122,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do we really want an unconditional assertion failure here, vs say:\r\n\r\n```c++\r\nif (Assume(it != mapInfo.end()) && it->second.GetNetwork() == *network) break;\r\n```\r\n\r\n(maybe a similar question for `GetEntry`)",
      "created_at": "2023-04-13T01:25:11Z",
      "updated_at": "2023-04-27T08:55:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1164833780",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1164833780"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 767,
      "original_line": 767,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1164840456",
      "pull_request_review_id": 1382390744,
      "id": 1164840456,
      "node_id": "PRRC_kwDOABII585Fbg4I",
      "diff_hunk": "@@ -127,71 +127,152 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman->Size(), 2U);\n-    bool newOnly = true;\n-    auto addr_ret3 = addrman->Select(newOnly).first;\n+    bool new_only = true;\n+    auto addr_ret3 = addrman->Select(new_only).first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToStringAddrPort(), \"250.1.1.1:8333\");\n }\n \n-\n BOOST_AUTO_TEST_CASE(addrman_select)\n {\n     auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK(!addrman->Select(false).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(true).first.IsValid());\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test: Select from new with 1 addr in new.\n+    // Add 1 address to the new table\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n \n-    bool newOnly = true;\n-    auto addr_ret1 = addrman->Select(newOnly).first;\n-    BOOST_CHECK_EQUAL(addr_ret1.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true).first == addr1);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false).first == addr1);\n \n-    // Test: move addr to tried, select from new expected nothing returned.\n+    // Move address to the tried table\n     BOOST_CHECK(addrman->Good(CAddress(addr1, NODE_NONE)));\n-    BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n-    auto addr_ret2 = addrman->Select(newOnly).first;\n-    BOOST_CHECK_EQUAL(addr_ret2.ToStringAddrPort(), \"[::]:0\");\n-\n-    auto addr_ret3 = addrman->Select().first;\n-    BOOST_CHECK_EQUAL(addr_ret3.ToStringAddrPort(), \"250.1.1.1:8333\");\n \n+    BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true).first.IsValid());\n+    BOOST_CHECK(addrman->Select().first == addr1);\n     BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n \n-\n-    // Add three addresses to new table.\n+    // Add one address to the new table\n     CService addr2 = ResolveService(\"250.3.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr2, NODE_NONE)}, addr2));\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true).first == addr2);\n+\n+    // Add two more addresses to the new table\n     CService addr3 = ResolveService(\"250.3.2.2\", 9999);\n     CService addr4 = ResolveService(\"250.3.3.3\", 9999);\n \n-    BOOST_CHECK(addrman->Add({CAddress(addr2, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n-    BOOST_CHECK(addrman->Add({CAddress(addr3, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman->Add({CAddress(addr3, NODE_NONE)}, addr2));\n     BOOST_CHECK(addrman->Add({CAddress(addr4, NODE_NONE)}, ResolveService(\"250.4.1.1\", 8333)));\n \n     // Add three addresses to tried table.\n     CService addr5 = ResolveService(\"250.4.4.4\", 8333);\n     CService addr6 = ResolveService(\"250.4.5.5\", 7777);\n     CService addr7 = ResolveService(\"250.4.6.6\", 8333);\n \n-    BOOST_CHECK(addrman->Add({CAddress(addr5, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman->Add({CAddress(addr5, NODE_NONE)}, addr3));\n     BOOST_CHECK(addrman->Good(CAddress(addr5, NODE_NONE)));\n-    BOOST_CHECK(addrman->Add({CAddress(addr6, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman->Add({CAddress(addr6, NODE_NONE)}, addr3));\n     BOOST_CHECK(addrman->Good(CAddress(addr6, NODE_NONE)));\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_IPV4).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV4).first.IsValid());\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_IPV4).first == addr1);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_IPV4).first == addr1);\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV6).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_ONION).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_I2P).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_CJDNS).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_CJDNS).first.IsValid());\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false).first == addr1);\n+\n+    // add I2P address to the new table\n+    CAddress i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({i2p_addr}, source));\n+\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_I2P).first == i2p_addr);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_I2P).first == i2p_addr);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_IPV4).first == addr1);\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV6).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_ONION).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_CJDNS).first.IsValid());\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(i2p_addr));\n+\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_I2P).first.IsValid());\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_I2P).first == i2p_addr);\n+\n+    // add another I2P address to the new table\n+    CAddress i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({i2p_addr2}, source));\n+\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_I2P).first == i2p_addr2);\n+\n+    // ensure that both new and tried table are selected from\n+    bool new_selected{false};\n+    bool tried_selected{false};\n+\n+    while (!new_selected || !tried_selected) {",
      "path": "src/test/addrman_tests.cpp",
      "position": 139,
      "original_position": 139,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Seems like having:\r\n\r\n```c++\r\nint counter = 256;\r\nwhile (--counter > 0 && (!new_selected || !tried_selected)) { ... }\r\nBOOST_CHECK(new_selected);\r\nBOOST_CHECK(tried_selected);\r\n```\r\n\r\nwould be better here than an infinite loop leading to CI timeout on error. A one-in-2**256 chance of failure is already the security of bitcoin as a whole, after all; and if our randomness generator is biassed enough that it fails more than that, it's probably better that the test case fails anyway? That we use the deterministic addrman presumably means any failures here will always be deterministic, no?",
      "created_at": "2023-04-13T01:32:24Z",
      "updated_at": "2023-04-13T01:52:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1164840456",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1164840456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 243,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1169169601",
      "pull_request_review_id": 1388792230,
      "id": 1169169601,
      "node_id": "PRRC_kwDOABII585FsBzB",
      "diff_hunk": "@@ -252,6 +252,28 @@ BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic=*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // add I2P address to the tried table\n+    CAddress i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({i2p_addr}, source));",
      "path": "src/test/addrman_tests.cpp",
      "position": 163,
      "original_position": 17,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "a98e542e0c18f7cb2340179631806f14b07430c3",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This non-deterministic test could fail intermittently, if `i2p_addr` collides with  `addr1` (I tried it, and it happened to me after ~4000 runs).\r\nIt would be good to change the order, such that we first add an address to tried (via new), and only then add another addr to new when the first has been moved over to tried.",
      "created_at": "2023-04-17T19:08:10Z",
      "updated_at": "2023-04-17T19:32:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1169169601",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1169169601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 267,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1169178603",
      "pull_request_review_id": 1388792230,
      "id": 1169178603,
      "node_id": "PRRC_kwDOABII585FsD_r",
      "diff_hunk": "@@ -146,7 +146,9 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` returns\n+     *                     an address from the new table or an empty pair. Passing `false` will return an\n+     *                     address from either the new or tried table (it does not guarantee a tried entry).",
      "path": "src/addrman.h",
      "position": 7,
      "original_position": 7,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: mentioning the \"empty pair\" only in the first case makes it sound as if this wasn't one of the possible outcomes in the second case (but it is).",
      "created_at": "2023-04-17T19:17:52Z",
      "updated_at": "2023-04-17T19:29:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1169178603",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1169178603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1169300130",
      "pull_request_review_id": 1388996877,
      "id": 1169300130,
      "node_id": "PRRC_kwDOABII585Fshqi",
      "diff_hunk": "@@ -252,6 +252,28 @@ BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_special)\n+{\n+    // use a non-deterministic addrman to ensure a passing test isn't due to setup\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, /*deterministic=*/false, GetCheckRatio(m_node));\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.3\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    // add I2P address to the tried table\n+    CAddress i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({i2p_addr}, source));",
      "path": "src/test/addrman_tests.cpp",
      "position": 163,
      "original_position": 17,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "a98e542e0c18f7cb2340179631806f14b07430c3",
      "in_reply_to_id": 1169169601,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ðŸ¤¦â€â™€ï¸ yup, agreed. will do in follow-up ",
      "created_at": "2023-04-17T21:52:23Z",
      "updated_at": "2023-04-17T21:52:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1169300130",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1169300130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 267,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661115",
      "pull_request_review_id": 1442601041,
      "id": 1204661115,
      "node_id": "PRRC_kwDOABII585Hzat7",
      "diff_hunk": "@@ -714,72 +714,98 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network.has_value()) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if (new_count + tried_count == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    // Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;",
      "path": "src/addrman.cpp",
      "position": 115,
      "original_position": 115,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": 1147633787,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in #27745",
      "created_at": "2023-05-24T19:23:20Z",
      "updated_at": "2023-05-24T19:23:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1204661115",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 760,
      "original_line": 760,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661204",
      "pull_request_review_id": 1442601151,
      "id": 1204661204,
      "node_id": "PRRC_kwDOABII585HzavU",
      "diff_hunk": "@@ -146,11 +146,14 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` returns\n+     *                     an address from the new table or an empty pair. Passing `false` will return an\n+     *                     address from either the new or tried table (it does not guarantee a tried entry).\n+     * @param[in] network  Select only addresses of this network (nullopt = all)",
      "path": "src/addrman.h",
      "position": 8,
      "original_position": 8,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": 1164826176,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in #27745",
      "created_at": "2023-05-24T19:23:25Z",
      "updated_at": "2023-05-24T19:23:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1204661204",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661204"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 152,
      "original_line": 152,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661284",
      "pull_request_review_id": 1442601258,
      "id": 1204661284,
      "node_id": "PRRC_kwDOABII585Hzawk",
      "diff_hunk": "@@ -714,72 +714,98 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, NodeSeconds\n     }\n }\n \n-std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, NodeSeconds> AddrManImpl::Select_(bool new_only, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n     if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0) return {};\n-\n-    // Use a 50% chance for choosing between tried and new table entries.\n-    if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || insecure_rand.randbool() == 0))) {\n-        // use a tried node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a tried bucket, and an initial position in that bucket.\n-            int nKBucket = insecure_rand.randrange(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvTried[nKBucket][(nKBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from tried\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n-            }\n-            // Otherwise start over with a (likely) different bucket, and increased chance factor.\n-            fChanceFactor *= 1.2;\n-        }\n+    size_t new_count = nNew;\n+    size_t tried_count = nTried;\n+\n+    if (network.has_value()) {\n+        auto it = m_network_counts.find(*network);\n+        if (it == m_network_counts.end()) return {};\n+\n+        auto counts = it->second;\n+        new_count = counts.n_new;\n+        tried_count = counts.n_tried;\n+    }\n+\n+    if (new_only && new_count == 0) return {};\n+    if (new_count + tried_count == 0) return {};\n+\n+    // Decide if we are going to search the new or tried table\n+    // If either option is viable, use a 50% chance to choose\n+    bool search_tried;\n+    if (new_only || tried_count == 0) {\n+        search_tried = false;\n+    } else if (new_count == 0) {\n+        search_tried = true;\n     } else {\n-        // use a new node\n-        double fChanceFactor = 1.0;\n-        while (1) {\n-            // Pick a new bucket, and an initial position in that bucket.\n-            int nUBucket = insecure_rand.randrange(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n-            // Iterate over the positions of that bucket, starting at the initial one,\n-            // and looping around.\n-            int i;\n-            for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n-                if (vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE] != -1) break;\n-            }\n-            // If the bucket is entirely empty, start over with a (likely) different one.\n-            if (i == ADDRMAN_BUCKET_SIZE) continue;\n-            // Find the entry to return.\n-            int nId = vvNew[nUBucket][(nUBucketPos + i) % ADDRMAN_BUCKET_SIZE];\n-            const auto it_found{mapInfo.find(nId)};\n-            assert(it_found != mapInfo.end());\n-            const AddrInfo& info{it_found->second};\n-            // With probability GetChance() * fChanceFactor, return the entry.\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n-                LogPrint(BCLog::ADDRMAN, \"Selected %s from new\\n\", info.ToStringAddrPort());\n-                return {info, info.m_last_try};\n+        search_tried = insecure_rand.randbool();\n+    }\n+\n+    const int bucket_count{search_tried ? ADDRMAN_TRIED_BUCKET_COUNT : ADDRMAN_NEW_BUCKET_COUNT};\n+\n+    // Loop through the addrman table until we find an appropriate entry\n+    double chance_factor = 1.0;\n+    while (1) {\n+        // Pick a bucket, and an initial position in that bucket.\n+        int bucket = insecure_rand.randrange(bucket_count);\n+        int initial_position = insecure_rand.randrange(ADDRMAN_BUCKET_SIZE);\n+\n+        // Iterate over the positions of that bucket, starting at the initial one,\n+        // and looping around.\n+        int i;\n+        for (i = 0; i < ADDRMAN_BUCKET_SIZE; ++i) {\n+            int position = (initial_position + i) % ADDRMAN_BUCKET_SIZE;\n+            int node_id = GetEntry(search_tried, bucket, position);\n+            if (node_id != -1) {\n+                if (network.has_value()) {\n+                    const auto it{mapInfo.find(node_id)};\n+                    assert(it != mapInfo.end());",
      "path": "src/addrman.cpp",
      "position": 122,
      "original_position": 122,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": 1164833780,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in #27745",
      "created_at": "2023-05-24T19:23:30Z",
      "updated_at": "2023-05-24T19:23:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1204661284",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 767,
      "original_line": 767,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661358",
      "pull_request_review_id": 1442601352,
      "id": 1204661358,
      "node_id": "PRRC_kwDOABII585Hzaxu",
      "diff_hunk": "@@ -127,71 +127,152 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // the specified port to tried, but not the other.\n     addrman->Good(CAddress(addr1_port, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman->Size(), 2U);\n-    bool newOnly = true;\n-    auto addr_ret3 = addrman->Select(newOnly).first;\n+    bool new_only = true;\n+    auto addr_ret3 = addrman->Select(new_only).first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToStringAddrPort(), \"250.1.1.1:8333\");\n }\n \n-\n BOOST_AUTO_TEST_CASE(addrman_select)\n {\n     auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK(!addrman->Select(false).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(true).first.IsValid());\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test: Select from new with 1 addr in new.\n+    // Add 1 address to the new table\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n \n-    bool newOnly = true;\n-    auto addr_ret1 = addrman->Select(newOnly).first;\n-    BOOST_CHECK_EQUAL(addr_ret1.ToStringAddrPort(), \"250.1.1.1:8333\");\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true).first == addr1);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false).first == addr1);\n \n-    // Test: move addr to tried, select from new expected nothing returned.\n+    // Move address to the tried table\n     BOOST_CHECK(addrman->Good(CAddress(addr1, NODE_NONE)));\n-    BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n-    auto addr_ret2 = addrman->Select(newOnly).first;\n-    BOOST_CHECK_EQUAL(addr_ret2.ToStringAddrPort(), \"[::]:0\");\n-\n-    auto addr_ret3 = addrman->Select().first;\n-    BOOST_CHECK_EQUAL(addr_ret3.ToStringAddrPort(), \"250.1.1.1:8333\");\n \n+    BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true).first.IsValid());\n+    BOOST_CHECK(addrman->Select().first == addr1);\n     BOOST_CHECK_EQUAL(addrman->Size(), 1U);\n \n-\n-    // Add three addresses to new table.\n+    // Add one address to the new table\n     CService addr2 = ResolveService(\"250.3.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr2, NODE_NONE)}, addr2));\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true).first == addr2);\n+\n+    // Add two more addresses to the new table\n     CService addr3 = ResolveService(\"250.3.2.2\", 9999);\n     CService addr4 = ResolveService(\"250.3.3.3\", 9999);\n \n-    BOOST_CHECK(addrman->Add({CAddress(addr2, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n-    BOOST_CHECK(addrman->Add({CAddress(addr3, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman->Add({CAddress(addr3, NODE_NONE)}, addr2));\n     BOOST_CHECK(addrman->Add({CAddress(addr4, NODE_NONE)}, ResolveService(\"250.4.1.1\", 8333)));\n \n     // Add three addresses to tried table.\n     CService addr5 = ResolveService(\"250.4.4.4\", 8333);\n     CService addr6 = ResolveService(\"250.4.5.5\", 7777);\n     CService addr7 = ResolveService(\"250.4.6.6\", 8333);\n \n-    BOOST_CHECK(addrman->Add({CAddress(addr5, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman->Add({CAddress(addr5, NODE_NONE)}, addr3));\n     BOOST_CHECK(addrman->Good(CAddress(addr5, NODE_NONE)));\n-    BOOST_CHECK(addrman->Add({CAddress(addr6, NODE_NONE)}, ResolveService(\"250.3.1.1\", 8333)));\n+    BOOST_CHECK(addrman->Add({CAddress(addr6, NODE_NONE)}, addr3));\n     BOOST_CHECK(addrman->Good(CAddress(addr6, NODE_NONE)));\n     BOOST_CHECK(addrman->Add({CAddress(addr7, NODE_NONE)}, ResolveService(\"250.1.1.3\", 8333)));\n     BOOST_CHECK(addrman->Good(CAddress(addr7, NODE_NONE)));\n \n-    // Test: 6 addrs + 1 addr from last test = 7.\n+    // 6 addrs + 1 addr from last test = 7.\n     BOOST_CHECK_EQUAL(addrman->Size(), 7U);\n \n-    // Test: Select pulls from new and tried regardless of port number.\n+    // Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n         ports.insert(addrman->Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n \n+BOOST_AUTO_TEST_CASE(addrman_select_by_network)\n+{\n+    auto addrman = std::make_unique<AddrMan>(EMPTY_NETGROUPMAN, DETERMINISTIC, GetCheckRatio(m_node));\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_IPV4).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV4).first.IsValid());\n+\n+    // add ipv4 address to the new table\n+    CNetAddr source = ResolveIP(\"252.2.2.2\");\n+    CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n+    BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n+\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_IPV4).first == addr1);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_IPV4).first == addr1);\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV6).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_ONION).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_I2P).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_CJDNS).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_CJDNS).first.IsValid());\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false).first == addr1);\n+\n+    // add I2P address to the new table\n+    CAddress i2p_addr;\n+    i2p_addr.SetSpecial(\"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({i2p_addr}, source));\n+\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_I2P).first == i2p_addr);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_I2P).first == i2p_addr);\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_IPV4).first == addr1);\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_IPV6).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_ONION).first.IsValid());\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/false, NET_CJDNS).first.IsValid());\n+\n+    // bump I2P address to tried table\n+    BOOST_CHECK(addrman->Good(i2p_addr));\n+\n+    BOOST_CHECK(!addrman->Select(/*new_only=*/true, NET_I2P).first.IsValid());\n+    BOOST_CHECK(addrman->Select(/*new_only=*/false, NET_I2P).first == i2p_addr);\n+\n+    // add another I2P address to the new table\n+    CAddress i2p_addr2;\n+    i2p_addr2.SetSpecial(\"c4gfnttsuwqomiygupdqqqyy5y5emnk5c73hrfvatri67prd7vyq.b32.i2p\");\n+    BOOST_CHECK(addrman->Add({i2p_addr2}, source));\n+\n+    BOOST_CHECK(addrman->Select(/*new_only=*/true, NET_I2P).first == i2p_addr2);\n+\n+    // ensure that both new and tried table are selected from\n+    bool new_selected{false};\n+    bool tried_selected{false};\n+\n+    while (!new_selected || !tried_selected) {",
      "path": "src/test/addrman_tests.cpp",
      "position": 139,
      "original_position": 139,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": 1164840456,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in #27745",
      "created_at": "2023-05-24T19:23:35Z",
      "updated_at": "2023-05-24T19:23:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1204661358",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661358"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 243,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661423",
      "pull_request_review_id": 1442601448,
      "id": 1204661423,
      "node_id": "PRRC_kwDOABII585Hzayv",
      "diff_hunk": "@@ -146,7 +146,9 @@ class AddrMan\n     /**\n      * Choose an address to connect to.\n      *\n-     * @param[in] new_only Whether to only select addresses from the new table.\n+     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` returns\n+     *                     an address from the new table or an empty pair. Passing `false` will return an\n+     *                     address from either the new or tried table (it does not guarantee a tried entry).",
      "path": "src/addrman.h",
      "position": 7,
      "original_position": 7,
      "commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "original_commit_id": "17e705428ddf80c7a7f31fe5430d966cf08a37d6",
      "in_reply_to_id": 1169178603,
      "user": {
        "login": "amitiuttarwar",
        "id": 1500952,
        "node_id": "MDQ6VXNlcjE1MDA5NTI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amitiuttarwar",
        "html_url": "https://github.com/amitiuttarwar",
        "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
        "following_url": "https://api.github.com/users/amitiuttarwar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amitiuttarwar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amitiuttarwar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
        "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
        "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
        "events_url": "https://api.github.com/users/amitiuttarwar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "done in #27745",
      "created_at": "2023-05-24T19:23:39Z",
      "updated_at": "2023-05-24T19:23:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27214#discussion_r1204661423",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1204661423"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27214"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 151,
      "original_line": 151,
      "side": "RIGHT"
    }
  ]
}